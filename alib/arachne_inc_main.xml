This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
AdjacencyListPolicy.hpp
AdjacencyMatrixPolicy.hpp
arachne_inc.xml
ArachneData.hpp
BasicBitMap.hpp
Clique.hpp
CompressedFormatPolicy.hpp
constants.hpp
display.hpp
EdgeData.hpp
EdgeListPolicy.hpp
EdgeStoragePolicy.hpp
graph_factories.hpp
graph_utilities.hpp
Graph.hpp
GraphColor.hpp
GraphPartition.hpp
Heterogenous.hpp
IteratorPolicy.hpp
main.cpp
NodeData.hpp
NodeStoragePolicy.hpp
observer_ptr.hpp
Parameters.hpp
real.hpp
Traits.hpp
Types.hpp
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AdjacencyListPolicy.hpp">
#ifndef ADJACENCY_LIST_POLICY_HPP
#define ADJACENCY_LIST_POLICY_HPP

#include <array>
#include <iomanip>
#include <iostream>
#include <map>
#include <sstream>
#include <numeric>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "display.hpp"
#include "graph_utilities.hpp"

namespace Arachne {

template <typename T>
concept HasSizeMethod = requires(T x) {
    x.size();
};

template <typename T>
concept DoesNotHaveSizeMethod = !HasSizeMethod<T>;

template <typename Graph, typename Edge, IsStorageTrait Storage, Size N>
struct AdjacencyListStoragePolicy {};

template <typename Graph, typename Edge, Size N>
struct AdjacencyListStoragePolicy<Graph, Edge, Dynamic, N> {
    template <typename InnerContainer>
    using MiddleContainer = std::list<std::pair<NodeIdx, InnerContainer>>;
    template <typename InnerContainer>
    using OuterContainer = std::vector<MiddleContainer<InnerContainer>>;

    void initialize_adjacency_list(Size n = N) {
        static_cast<Graph*>(this)->adjacency_list_.resize(n);
    }
    void add_node_to_representation_() {
        static_cast<Graph*>(this)->adjacency_list_.emplace_back();
    }

    void remove_node_from_representation_(const NodeIdx a) {
        Size removed_edges = static_cast<Graph*>(this)->degree(a);
        static_cast<Graph*>(this)->adjacency_list_.erase(
            static_cast<Graph*>(this)->adjacency_list_.begin() + a);
        for (auto outer = static_cast<Graph*>(this)->adjacency_list_.begin(),
                  end = static_cast<Graph*>(this)->adjacency_list_.end();
             outer != end; outer++) {
            for (auto inner = (*outer).begin(), end = (*outer).end();
                 inner != end; inner++) {
                if (inner->first == a) {
                    inner = outer->erase(inner);
                }
                if (inner->first > a) {
                    inner->first -= 1;
                }
            }
        }
        static_cast<Graph*>(this)->number_of_edges_ -= removed_edges;
    }

  protected:
    template <typename InnerContainer>
    Bool add_edge_to_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        Edge edge) {
        for (auto iter = middle_container.begin(), end = middle_container.end();
             iter != end; iter++) {
            if (iter->first == idx) {
                Bool ret = false;
                ret |= static_cast<Graph*>(this)->add_edge_to_inner_container_(
                    iter->second, edge);
                return ret;
            }
        }
        middle_container.push_back(std::make_pair(idx, InnerContainer()));
        static_cast<Graph*>(this)->add_edge_to_inner_container_(
            middle_container.back().second, edge);
        return true;
    }

    template <HasSizeMethod InnerContainer>
    Bool remove_edge_from_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        Edge edge) {
        for (auto iter = middle_container.begin(), end = middle_container.end();
             iter != end; iter++) {
            if (iter->first == idx) {
                if (iter->second.size() == 1) {
                    middle_container.erase(iter);
                    return true;
                } else {
                    return static_cast<Graph*>(this)
                        ->remove_edge_from_inner_container_(iter->second, edge);
                }
            }
        }
        return false;
    }

    template <DoesNotHaveSizeMethod InnerContainer>
    Bool remove_edge_from_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        ...) {
        for (auto iter = middle_container.begin(), end = middle_container.end();
             iter != end; iter++) {
            if (iter->first == idx) {
                middle_container.erase(iter);
                return true;
            }
        }
        return false;
    }
};

template <typename Graph, typename Edge, Size N>
struct AdjacencyListStoragePolicy<Graph, Edge, Static, N> {
    template <typename InnerContainer>
    using MiddleContainer = std::map<NodeIdx, InnerContainer>;
    template <typename InnerContainer>
    using OuterContainer = std::array<std::map<NodeIdx, InnerContainer>, N>;

    void initialize_adjacency_list() {}

  protected:
    template <typename InnerContainer>
    Bool add_edge_to_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        Edge edge) {
        Bool ret = !middle_container.contains(idx);
        ret |= static_cast<Graph*>(this)->add_edge_to_inner_container_(
            middle_container[idx], edge);
        return ret;
    }

    template <HasSizeMethod InnerContainer>
    Bool remove_edge_from_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        Edge edge) {
        if (middle_container[idx].size() == 1) {
            middle_container.erase(idx);
            return true;
        } else {
            return static_cast<Graph*>(this)->remove_edge_from_inner_container_(
                middle_container[idx], edge);
        }
    }

    template <DoesNotHaveSizeMethod InnerContainer>
    Bool remove_edge_from_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        ...) {
        Bool ret = middle_container.contains(idx);
        middle_container.erase(idx);
        return ret;
    }
};

template <typename Graph, typename Edge, IsDirectionalityTrait Directionality>
struct AdjacencyListDirectionalityPolicy {};

template <typename Graph, typename Edge>
struct AdjacencyListDirectionalityPolicy<Graph, Edge, Undirected> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->add_edge_to_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[source], dest,
            edge);
        if (source != dest) { // avoid duplicating self edges
            static_cast<Graph*>(this)->add_edge_to_middle_container_(
                static_cast<Graph*>(this)->adjacency_list_[dest],
                source, edge);
        }
        static_cast<Graph*>(this)->number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->remove_edge_from_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[source], dest,
            edge);
        static_cast<Graph*>(this)->remove_edge_from_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[dest], source,
            edge);
        static_cast<Graph*>(this)->number_of_edges_ -= success;
    }

    Size degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

  protected:
    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return it > it2 ? 0 : static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge>
struct AdjacencyListDirectionalityPolicy<Graph, Edge, Directed> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->add_edge_to_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[source], dest,
            edge);
        static_cast<Graph&>(*this).number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->remove_edge_from_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[source], dest,
            edge);
        static_cast<Graph&>(*this).number_of_edges_ -= success;
    }

    Size out_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

    Size in_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(i, n);
        }
        return deg;
    }

    Size degree(NodeIdx n) {
        return in_degree(n)+ out_degree(n)-static_cast<Graph*>(this)->count(n, n);
    }

  protected:
    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge, IsConnectivityTrait Connectivity>
struct AdjacencyListConnectivityPolicy {};

template <typename Graph, typename Edge>
struct AdjacencyListConnectivityPolicy<Graph, Edge, Simple> {
  protected:
    Bool
    add_edge_to_inner_container_(typename Simple::InnerContainer<Edge>& inner,
                                 Edge edge) {
        inner = edge;
        return false;
    }

  public:
    Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second;
            }
        }
        exit(EXIT_FAILURE);
    }

    const Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) const {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second;
            }
        }
        exit(EXIT_FAILURE);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return 1;
            }
        }
        return 0;
    }
};

template <typename Graph, typename Edge>
class AdjacencyListConnectivityPolicy<Graph, Edge, Multi> {
  protected:
    Bool
    add_edge_to_inner_container_(typename Multi::InnerContainer<Edge>& inner,
                                 Edge& edge) {
        inner.push_back(edge);
        return true;
    }

    // removes first encountered edge from inner container
    Bool remove_edge_from_inner_container_(
        typename Multi::template InnerContainer<Edge>& inner_container,
        Edge edge) {
        for (auto iter = inner_container.begin(), end = inner_container.end();
             iter != end; iter++) {
            if ((*iter) == edge) {
                inner_container.erase(iter);
                return true;
            }
        }
        return false;
    }

  public:
    typename Multi::template InnerContainer<Edge>&
    get_edges(const NodeIdx& source, const NodeIdx& dest) {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second;
            }
        }
        exit(EXIT_FAILURE);
    }

    const typename Multi::template InnerContainer<Edge>&
    get_edges(const NodeIdx& source, const NodeIdx& dest) const {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second;
            }
        }
        exit(EXIT_FAILURE);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second.size();
            }
        }
        return 0;
    }
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, IsStorageTrait Storage,
          IsDirectionalityTrait Directionality,
          IsConnectivityTrait Connectivity>
class AdjacencyList
    : public AdjacencyListStoragePolicy<Graph, Edge, Storage, N>,
      public AdjacencyListDirectionalityPolicy<Graph, Edge, Directionality>,
      public AdjacencyListConnectivityPolicy<Graph, Edge, Connectivity>,
      public IteratorPolicy<Graph, Node, Edge> {

    using StoragePolicy = AdjacencyListStoragePolicy<Graph, Edge, Storage, N>;
    using DirectionalityPolicy =
        AdjacencyListDirectionalityPolicy<Graph, Edge, Directionality>;
    using ConnectivityPolicy =
        AdjacencyListConnectivityPolicy<Graph, Edge, Connectivity>;
    friend StoragePolicy;
    friend DirectionalityPolicy;
    friend ConnectivityPolicy;

  public:
    using StoragePolicy::initialize_adjacency_list;
    using InnerContainer = typename Connectivity::template InnerContainer<Edge>;
    using AdjacencyListContainer =
        typename StoragePolicy::template OuterContainer<InnerContainer>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;
    explicit AdjacencyList() : number_of_edges_(0) {
        initialize_adjacency_list();
    }
    explicit AdjacencyList(Size n) : number_of_edges_(0) {
        initialize_adjacency_list(n);
    }

    const Size& number_of_edges() const { return number_of_edges_; }
    template<typename... Args>
    Size number_of_edges (NodeIdx first, Args... nodes) {
        return static_cast<Graph*>(this)->num_of_edges_({first, nodes...});
    }
    AdjacencyListContainer& get_adjacency_list() { return adjacency_list_; }
    const AdjacencyListContainer& get_adjacency_list() const {
        return adjacency_list_;
    }

    String representation_to_string() {
        std::stringstream ss;
        Size col_width =
            display(static_cast<Graph*>(this)->number_of_nodes(), "[", "]")
                .size();
        Size counter = 0;
        String col_delim = " | ";
        String iter_delim = "\n";
        for (auto iter : static_cast<Graph*>(this)->get_adjacency_list()) {
            ss << std::setw(col_width) << std::left
               << display(counter, "[", "]");
            ss << col_delim;
            ss << display(iter, " : ", ", ", "[", "]");
            ss << iter_delim;
            counter++;
        }
        return ss.str().substr(0, ss.str().size() - iter_delim.size());
    }

    template <IsIteratorTrait T>
    struct Iterator {};

    template <>
    struct Iterator<Neighbour> : public IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename AdjacencyListContainer::value_type::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename AdjacencyListContainer::value_type::iterator, Node>;
        using ListType = AdjacencyListContainer::value_type;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;
        using SuperIterator::SuperIterator;

        const Node &operator*() const override {
            return g->node(it->first);
        }

        Iterator<Neighbour> &operator++() override {
            ++(it);
            return *this;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first);
        }
    };

    template <>
    struct Iterator<Adjacent> : public IteratorPolicy::template SuperIterator<Iterator<Adjacent>, typename AdjacencyListContainer::value_type::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Adjacent>, typename AdjacencyListContainer::value_type::iterator, Node>;
        using ListType = AdjacencyListContainer::value_type;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx source;
        NodeIdx outer_it;

        Iterator<Adjacent> &operator++() override {
            if (it != g->get_adjacency_list()[outer_it].end()) ++it;
            if (source == outer_it) {
                if (it != g->get_adjacency_list()[outer_it].end()) {
                    return *this;
                }
            }
            // keep iterating until source and it->first match
            while (outer_it != g->get_adjacency_list().size()) {
                if (source == outer_it) {
                    if (it != g->get_adjacency_list()[outer_it].end()) {
                        return *this;
                    }
                }
                while (it != g->get_adjacency_list()[outer_it].end()) {
                    if (it->first == source) return *this;
                    ++it;
                }
                outer_it++;
                if (outer_it != g->get_adjacency_list().size()) it = g->get_adjacency_list()[outer_it].begin();
            }

            return *this;
        }

        Bool operator==(const Iterator<Adjacent> &other) {
            return g == other.g && it == other.it && source == other.source && outer_it == other.outer_it;
        }

        inline NodeIdx get_current_node() const {
            return source == outer_it ? it->first : outer_it;
        }

        const Node &operator*() const override {
            return  g->node(get_current_node());
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, get_current_node());
        }

        Iterator<Adjacent>(Graph *g, NodeIdx source):
            SuperIterator{g, g->get_adjacency_list()[0].begin()},
            source{source},
            outer_it{0} {
                if (it == g->get_adjacency_list()[outer_it].end() || (source != outer_it && source != it->first)) {
                    ++(*this);
                }
            }

        Iterator<Adjacent>(Graph *g, NodeIdx source, typename AdjacencyListContainer::value_type::iterator it):
            SuperIterator{g, it},
            source{source},
            outer_it{g->get_adjacency_list().size()}
            {}
    };

    std::pair<Iterator<Neighbour>, Iterator<Neighbour>> get_neighbours(NodeIdx node) {
        return std::make_pair(
            Iterator<Neighbour>(static_cast<Graph*>(this), adjacency_list_[node].begin()),
            Iterator<Neighbour>(static_cast<Graph*>(this), adjacency_list_[node].end())
        );
    }

    std::pair<Iterator<Adjacent>, Iterator<Adjacent>> get_adjacents(NodeIdx node) {
        return std::make_pair(
            Iterator<Adjacent>(static_cast<Graph *>(this), node),
            Iterator<Adjacent>(static_cast<Graph *>(this), node, adjacency_list_.back().end())
        );
    }

    template <>
    struct Iterator<EdgeIterator> : public IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename AdjacencyListContainer::value_type::iterator, typename Connectivity::template InnerContainer<Edge>> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename AdjacencyListContainer::value_type::iterator, typename Connectivity::template InnerContainer<Edge>>;
        using ListType = AdjacencyListContainer::value_type;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        // using SuperIterator::operator==;
        using SuperIterator::SuperIterator;

        NodeIdx node;

        Iterator<EdgeIterator>(Graph *g, NodeIdx node, AdjacencyListContainer::value_type::iterator it) : SuperIterator{g, it}, node{node} {
            while (this->node != g->number_of_nodes() && this->it == g->get_adjacency_list()[this->node].end()) {
                (this->node)++;
                if (this->node == g->number_of_nodes()) break;
                this->it = g->get_adjacency_list()[this->node].begin();
            }
        }

        const typename Connectivity::template InnerContainer<Edge> &operator*() const override {
            return it->second;
        }

        Iterator<EdgeIterator> &operator++() override {
            it++;
            while (node != g->number_of_nodes() && it == g->get_adjacency_list()[node].end()) {
                node++;
                if (node == g->number_of_nodes()) break;
                it = g->get_adjacency_list()[node].begin();
            }
            return *this;
        }

        Bool operator==(const Iterator<EdgeIterator> &other) {
            return g == other.g && node == other.node && (node == g->number_of_nodes() ? true : it == other.it);
        }

        typename IteratorPolicy::template Iterator<Basic> first () {
            return typename IteratorPolicy::template Iterator<Basic>(g, node);
        }

        typename IteratorPolicy::template Iterator<Basic> second () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first);
        }

        const Edge &edge () const {
            return it->second;
        }   
    };

    std::pair<Iterator<EdgeIterator>, Iterator<EdgeIterator>> get_edges() {
        return std::make_pair(
            Iterator<EdgeIterator>(static_cast<Graph*>(this), 0, adjacency_list_[0].begin()),
            Iterator<EdgeIterator>(static_cast<Graph*>(this), static_cast<Graph*>(this)->number_of_nodes(),adjacency_list_[static_cast<Graph*>(this)->number_of_nodes()-1].end())
        );
    }

  protected:
    Size number_of_edges_;
    AdjacencyListContainer adjacency_list_;
};

} // namespace Arachne

#endif // ADJACENCY_LIST_POLICY_HPP
</file>

<file path="AdjacencyMatrixPolicy.hpp">
#ifndef ADJACENCY_MATRIX_POLICY_HPP
#define ADJACENCY_MATRIX_POLICY_HPP

#include <iomanip>
#include <iostream>
#include <optional>
#include <sstream>
#include <vector>
#include <numeric>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "display.hpp"

namespace Arachne {

template <typename Graph, typename Edge, typename Storage,
          typename Connectivity, Size N>
struct AdjacencyMatrixStoragePolicy {};

template <typename Graph, typename Edge, typename Connectivity, Size N>
struct AdjacencyMatrixStoragePolicy<Graph, Edge, Dynamic, Connectivity, N> {
    template <typename InnerContainer, Size...>
    using OuterContainer = std::vector<InnerContainer>;


    void initialize_adjacency_matrix(Size n = N) {
        static_cast<Graph*>(this)->adjacency_matrix_.resize(static_cast<Graph*>(this)->number_of_elements(n));
    }

    void add_node_to_representation_() {
        Size dim = static_cast<Graph*>(this)->number_of_nodes();
        for (Size j = 0; j < dim - 1; j++) {
            static_cast<Graph*>(this)->adjacency_matrix_.insert(
                static_cast<Graph*>(this)->adjacency_matrix_.begin() +
                    static_cast<Graph*>(this)->end_of_row_(j),
                std::nullopt);
        }
        static_cast<Graph*>(this)->adjacency_matrix_.insert(
            static_cast<Graph*>(this)->adjacency_matrix_.end(),
            static_cast<Graph*>(this)->elements_in_new_row_(), std::nullopt);
    }

    void remove_node_from_representation_(const NodeIdx a) {
        Size removed_edges = static_cast<Graph*>(this)->degree(a);
        SizeSet indices_to_remove;
        for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
             j++) {
            indices_to_remove.insert(static_cast<Graph*>(this)->get_index_(j, a));
            if (j != a) {
                indices_to_remove.insert(static_cast<Graph*>(this)->get_index_(a, j));
            }
        }
        for (auto iter = indices_to_remove.rbegin(),
                  first = indices_to_remove.rend();
             iter != first; iter++) {
            static_cast<Graph*>(this)->adjacency_matrix_.erase(
                static_cast<Graph*>(this)->adjacency_matrix_.begin() + (*iter));
        }
        static_cast<Graph*>(this)->number_of_edges_ -= removed_edges;
    }
};

template <typename Graph, typename Edge, typename Connectivity, Size N>
struct AdjacencyMatrixStoragePolicy<Graph, Edge, Static, Connectivity, N> {

    template <typename InnerContainer, Size M>
    using OuterContainer = std::array<InnerContainer, M>;
    void initialize_adjacency_matrix() {}
};

template <typename Graph, typename Edge, typename Directionality, Size N>
struct AdjacencyMatrixDirectionalityPolicy {};

template <typename Graph, typename Edge, Size N>
struct AdjacencyMatrixDirectionalityPolicy<Graph, Edge, Undirected, N> {
    constexpr Size get_index_(NodeIdx a, NodeIdx b) const {
        if (a > b) {
            Size temp = a;
            a = b;
            b = temp;
        }
        return static_cast<const Graph*>(this)->start_of_row_(a) + b - a;
    }

    static constexpr Size initial_number_of_elements() {
        return N * (N + 1) / 2;
    }
    static Size number_of_elements(Size n) { return n * (n + 1) / 2; }

    constexpr Size current_number_of_elements() const {
        return (static_cast<const Graph*>(this)->number_of_nodes() *
               (static_cast<const Graph*>(this)->number_of_nodes() + 1)) / 2;
    }

  protected:
    Size start_of_row_(const Size j) const {
        return j*static_cast<const Graph*>(this)->number_of_nodes() - (j*(j-1))/2;
    }
    Size end_of_row_(const Size j) const {
        return (j+1)*static_cast<const Graph*>(this)->number_of_nodes() - (j*(j+1))/2-1;
    }
    Size elements_in_row(const Size j) const {
        return static_cast<const Graph*>(this)->number_of_nodes() - j;
    }

    Size elements_in_new_row_() const { return 1; }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return it > it2 ? 0 : static_cast<Graph*>(this)->count(it, it2); }); });
    }
  public:
    Size degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }
};

template <typename Graph, typename Edge, Size N>
struct AdjacencyMatrixDirectionalityPolicy<Graph, Edge, Directed, N> {
    constexpr Size get_index_(const NodeIdx& a, const NodeIdx b) const {
        return static_cast<const Graph*>(this)->start_of_row_(a) +
               b;
    }

    static constexpr Size initial_number_of_elements() { return N * N; }
    static Size number_of_elements(Size n) { return n * n; }
    constexpr Size current_number_of_elements() const {
        return static_cast<const Graph*>(this)->number_of_nodes() *
               static_cast<const Graph*>(this)->number_of_nodes();
    }

    const Edge& operator()(const Size j, const Size k) const {
        return static_cast<const Graph*>(this)->adjacency_matrix_.at(get_index_(j, k));
    }

  protected:
    Size start_of_row_(const Size j) const {
        return j * static_cast<const Graph*>(this)->number_of_nodes();
    }
    Size end_of_row_(const Size j) const {
        return ((j + 1) * static_cast<const Graph*>(this)->number_of_nodes()) -
               1;
    }
    Size elements_in_row_(const Size...) const {
        return static_cast<const Graph*>(this)->number_of_nodes();
    }
    Size elements_in_new_row_() const {
        return static_cast<const Graph*>(this)->number_of_nodes();
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return static_cast<Graph*>(this)->count(it, it2); }); });
    }
  public:
    Size out_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

    Size in_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(i, n);
        }
        return deg;
    }

    Size degree(NodeIdx n) {
        return in_degree(n)+ out_degree(n)-static_cast<Graph*>(this)->count(n, n);
    }
};

template <typename Graph, typename Edge, typename Directionality,
          typename Connectivity>
struct AdjacencyMatrixConnectivityPolicy {};

template <typename Graph, typename Edge, typename Directionality>
struct AdjacencyMatrixConnectivityPolicy<Graph, Edge, Directionality, Simple> {
    Bool add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        if (source >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr
                << "ARACHNE ERROR: In add_edge, idx.first node doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        if (dest >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr
                << "ARACHNE ERROR: In add_edge, idx.second node doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        static_cast<Graph*>(this)->number_of_edges_ += !(static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)).has_value());
        static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)) = edge;
        return true;
    }
    Bool remove_edge(const NodeIdx& source, const NodeIdx& dest, ...) {
        if (source >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr << "ARACHNE ERROR: In remove_edge, idx.first node "
                         "doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        if (dest >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr << "ARACHNE ERROR: In remove_edge, idx.second node "
                         "doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        static_cast<Graph*>(this)->number_of_edges_ -= static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)).has_value();
        static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)) = std::nullopt;
        return false;
    }
    Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) {
        return static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)).value();
    }
    const Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) const {
        return static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)).value();
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        return static_cast<Graph*>(this)->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest)).has_value();
    }

    String representation_to_string() {
        std::stringstream os;
        auto max_widths = std::unique_ptr<Size[]>(
            new Size[static_cast<Graph*>(this)->number_of_nodes()]);
        for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
             j++) {
            max_widths[j] = 0;
            for (Size i = 0; i < static_cast<Graph*>(this)->number_of_nodes();
                 i++) {
                std::stringstream ss;
                if (static_cast<Graph*>(this)->count(i, j)) {
                    ss << 1;
                } else {
                    ss << "0";
                }
                max_widths[j] = std::max(max_widths[j], ss.str().size() + 1);
            }
        }
        for (Size i = 0; i < static_cast<Graph*>(this)->number_of_nodes();
             i++) {
            for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
                 j++) {
                std::stringstream ss;
                if (static_cast<Graph*>(this)->count(i, j)) {
                    ss << 1;
                } else {
                    ss << "0";
                }
                os << std::setw(max_widths[j]) << std::left << ss.str();
                if (j < (static_cast<Graph*>(this)->number_of_nodes() - 1)) {
                    os << " ";
                }
            }
            if (i < (static_cast<Graph*>(this)->number_of_nodes() - 1)) {
                os << '\n';
            }
        }
        return os.str();
    }
};

template <typename Graph, typename Edge, typename Directionality>
struct AdjacencyMatrixConnectivityPolicy<Graph, Edge, Directionality, Multi> {
    Bool add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        if (source >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr
                << "ARACHNE ERROR: In add_edge, idx.first node doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        if (dest >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr
                << "ARACHNE ERROR: In add_edge, idx.second node doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        Size index = static_cast<Graph*>(this)->get_index_(source, dest);
        if (!static_cast<Graph*>(this)
                 ->adjacency_matrix_.at(index)
                 .has_value()) {
            static_cast<Graph*>(this)->adjacency_matrix_.at(index) =
                typename Multi::template InnerContainer<Edge>{edge};
        } else {
            static_cast<Graph*>(this)
                ->adjacency_matrix_.at(index)
                .value()
                .push_back(edge);
        }
        static_cast<Graph*>(this)->number_of_edges_++;
        return true;
    }
    Bool remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        if (source >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr << "ARACHNE ERROR: In remove_edge, idx.first node "
                         "doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        if (dest >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr << "ARACHNE ERROR: In remove_edge, idx.second node "
                         "doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        Size index = static_cast<Graph*>(this)->get_index_(source, dest);
        if (!static_cast<Graph*>(this)
                 ->adjacency_matrix_.at(index)
                 .has_value()) {
            return false;
        }
        for (auto iter = static_cast<Graph*>(this)
                             ->adjacency_matrix_.at(index)
                             .value()
                             .begin(),
                  end = static_cast<Graph*>(this)
                            ->adjacency_matrix_.at(index)
                            .value()
                            .end();
             iter != end; iter++) {
            if ((*iter) == edge) {
                static_cast<Graph*>(this)
                    ->adjacency_matrix_.at(index)
                    .value()
                    .erase(iter);
                if (static_cast<Graph*>(this)
                        ->adjacency_matrix_.at(index)
                        .value()
                        .size() == 0) {
                    static_cast<Graph*>(this)->adjacency_matrix_.at(index) =
                        std::nullopt;
                }
                static_cast<Graph*>(this)->number_of_edges_--;
                return true;
            }
        }
        return false;
    }
    typename Multi::template InnerContainer<std::optional<Edge>>&
    get_edges(const NodeIdx& source, const NodeIdx& dest) {
        return static_cast<Graph*>(this)
            ->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest))
            .value();
    }
    const typename Multi::template InnerContainer<std::optional<Edge>>&
    get_edges(const NodeIdx& source, const NodeIdx& dest) const {
        return static_cast<Graph*>(this)
            ->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest))
            .value();
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        return static_cast<Graph*>(this)->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest)).has_value() ? static_cast<Graph*>(this)->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest)).value().size() : 0;
    }

    String representation_to_string() {
        std::stringstream os;
        auto max_widths = std::unique_ptr<Size[]>(
            new Size[static_cast<Graph*>(this)->number_of_nodes()]);
        for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
             j++) {
            max_widths[j] = 0;
            for (Size i = 0; i < static_cast<Graph*>(this)->number_of_nodes();
                 i++) {
                std::stringstream ss;
                if (static_cast<Graph*>(this)->count(i, j)) {
                    ss << static_cast<Graph*>(this)->at(i, j).value().size();
                } else {
                    ss << "0";
                }
                max_widths[j] = std::max(max_widths[j], ss.str().size() + 1);
            }
        }
        for (Size i = 0; i < static_cast<Graph*>(this)->number_of_nodes();
             i++) {
            for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
                 j++) {
                std::stringstream ss;
                if (static_cast<Graph*>(this)->count(i, j)) {
                    ss << static_cast<Graph*>(this)->at(i, j).value().size();
                } else {
                    ss << "0";
                }
                os << std::setw(max_widths[j]) << std::left << ss.str();
                if (j < (static_cast<Graph*>(this)->number_of_nodes() - 1)) {
                    os << " ";
                }
            }
            if (i < (static_cast<Graph*>(this)->number_of_nodes() - 1)) {
                os << '\n';
            }
        }
        return os.str();
    }
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, typename Storage,
          typename Directionality, typename Connectivity>
class AdjacencyMatrix
    : public AdjacencyMatrixStoragePolicy<Graph, Edge, Storage, Connectivity,
                                          N>,
      public AdjacencyMatrixDirectionalityPolicy<Graph, Edge, Directionality,
                                                 N>,
      public AdjacencyMatrixConnectivityPolicy<Graph, Edge, Directionality,
                                               Connectivity>,
      public IteratorPolicy<Graph, Node, Edge> {
    using StoragePolicy =
        AdjacencyMatrixStoragePolicy<Graph, Edge, Storage, Connectivity, N>;
    using DirectionalityPolicy =
        AdjacencyMatrixDirectionalityPolicy<Graph, Edge, Directionality, N>;
    using ConnectivityPolicy =
        AdjacencyMatrixConnectivityPolicy<Graph, Edge, Directionality,
                                          Connectivity>;
    friend StoragePolicy;
    friend DirectionalityPolicy;
    friend ConnectivityPolicy;

  public:
    using DirectionalityPolicy::get_index_;
    using StoragePolicy::initialize_adjacency_matrix;
    using ElementType =
        std::optional<typename Connectivity::template InnerContainer<Edge>>;
    using AdjacencyMatrixContainer =
        typename StoragePolicy::template OuterContainer<
            ElementType, DirectionalityPolicy::initial_number_of_elements()>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;

    explicit AdjacencyMatrix() : number_of_edges_(0) { initialize_adjacency_matrix(); }
    explicit AdjacencyMatrix(Size n) : number_of_edges_(0) {
        initialize_adjacency_matrix(n);
    }

    const Size& number_of_edges() const { return number_of_edges_; }

    template<typename... Args>
    Size number_of_edges (NodeIdx first, Args... nodes) {
        return static_cast<Graph*>(this)->num_of_edges_({first, nodes...});
    }
    AdjacencyMatrixContainer& get_adjacency_matrix() {
        return adjacency_matrix_;
    }
    const AdjacencyMatrixContainer& get_adjacency_matrix() const {
        return adjacency_matrix_;
    }

  protected:
    const ElementType& at(const Size j, const Size k) const {
        return adjacency_matrix_.at(get_index_(j, k));
    }
    ElementType& at(const Size j, const Size k) {
        return adjacency_matrix_.at(get_index_(j, k));
    }
  public:
    template<IsIteratorTrait T, IsIteratorParameters ParamList = IteratorParameters<>>
    struct Iterator {};

    template <>
    struct Iterator<Neighbour> : public IteratorPolicy::template SuperIterator<Iterator<Neighbour>, NodeIdx, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Neighbour>, NodeIdx, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx source;

        Iterator<Neighbour>(Graph *g, NodeIdx source, NodeIdx dest) : SuperIterator{g, dest}, source{source} {
            while (it != g->number_of_nodes() && not g->count(source, it)) { it++; }
        }

        const Node &operator *() const { return g->node(it); }

        Iterator<Neighbour> &operator++() {
            while (++it != g->number_of_nodes() && not g->count(source, it));
            return *this;
        }

        Bool operator==(const Iterator<Neighbour> &other) {
            return g == other.g && it == other.it && source == other.source;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it);
        }
    };

    template <>
    struct Iterator<Adjacent> : public IteratorPolicy::template SuperIterator<Iterator<Adjacent>, NodeIdx, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Adjacent>, NodeIdx, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx source;

        Iterator<Adjacent>(Graph *g, NodeIdx source, NodeIdx dest) : SuperIterator{g, dest}, source{source} {
            while (it != g->number_of_nodes() && !(g->count(source, it) || g->count(it, source))) { it++; }
        }

        const Node &operator *() const { return g->node(it); }

        Iterator<Adjacent> &operator++() {
            if (it == g->number_of_nodes()) return *this;
            do it++; while (it != g->number_of_nodes() && !(g->count(source, it) || g->count(it, source)));
            return *this;
        }

        Bool operator==(const Iterator<Adjacent> &other) {
            return g == other.g && it == other.it && source == other.source;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it);
        }
    };

    std::pair<Iterator<Neighbour>, Iterator<Neighbour>> get_neighbours(NodeIdx node) {
        return std::make_pair(
            Iterator<Neighbour>(static_cast<Graph*>(this), node, 0),
            Iterator<Neighbour>(static_cast<Graph*>(this), node, static_cast<Graph*>(this)->number_of_nodes())
        );
    }

    std::pair<Iterator<Adjacent>, Iterator<Adjacent>> get_adjacents(NodeIdx node) {
        return std::make_pair(
            Iterator<Adjacent>(static_cast<Graph*>(this), node, 0),
            Iterator<Adjacent>(static_cast<Graph*>(this), node, static_cast<Graph*>(this)->number_of_nodes())
        );
    }
    template <>
    struct Iterator<EdgeIterator> : public IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, NodeIdx, typename Connectivity::template InnerContainer<Edge>> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, NodeIdx, typename Connectivity::template InnerContainer<Edge>>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx source;

        Iterator<EdgeIterator>(Graph *g, NodeIdx source, NodeIdx dest) : SuperIterator{g, dest}, source{source} {
            while (this->source != g->number_of_nodes() && it != g->number_of_nodes() && not g->count(this->source, it)) {
                it++;
                if (it == g->number_of_nodes()) {
                    it = 0;
                    (this->source)++;
                }
            }
        }

        const typename Connectivity::template InnerContainer<Edge> &operator *() const { return g->at(source, it).value(); }

        Iterator<EdgeIterator> &operator++() {
            do { 
                it++;
                if (it == g->number_of_nodes()) {
                    it = 0;
                    source++;
                }
            } while (source != g->number_of_nodes() && it != g->number_of_nodes() && !g->count(source, it));
            
            return *this;
        }

        Bool operator==(const Iterator<EdgeIterator> &other) {
            return g == other.g && it == other.it && source == other.source;
        }

        typename IteratorPolicy::template Iterator<Basic> first () {
            return typename IteratorPolicy::template Iterator<Basic>(g, source);
        }

        typename IteratorPolicy::template Iterator<Basic> second () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it);
        }

        const Connectivity::template InnerContainer<Edge> &edge () const {
            return g->at(source, it).value();
        }  
    };

    std::pair<Iterator<EdgeIterator>, Iterator<EdgeIterator>> get_edges() {
        return std::make_pair(
            Iterator<EdgeIterator>(static_cast<Graph*>(this), 0, 0),
            Iterator<EdgeIterator>(static_cast<Graph*>(this), static_cast<Graph*>(this)->number_of_nodes(), 0)
        );
    }



  protected:
    Size number_of_edges_;
    AdjacencyMatrixContainer adjacency_matrix_;
};

} // namespace Arachne

#endif // ADJACENCY_MATRIX_POLICY_HPP
</file>

<file path="arachne_inc.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
AdjacencyListPolicy.hpp
AdjacencyMatrixPolicy.hpp
ArachneData.hpp
BasicBitMap.hpp
Clique.hpp
CompressedFormatPolicy.hpp
constants.hpp
display.hpp
EdgeData.hpp
EdgeListPolicy.hpp
EdgeStoragePolicy.hpp
graph_factories.hpp
graph_utilities.hpp
Graph.hpp
GraphColor.hpp
GraphPartition.hpp
Heterogenous.hpp
IteratorPolicy.hpp
NodeData.hpp
NodeStoragePolicy.hpp
observer_ptr.hpp
Parameters.hpp
real.hpp
Traits.hpp
Types.hpp
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AdjacencyListPolicy.hpp">
#ifndef ADJACENCY_LIST_POLICY_HPP
#define ADJACENCY_LIST_POLICY_HPP

#include <array>
#include <iomanip>
#include <iostream>
#include <map>
#include <sstream>
#include <numeric>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "display.hpp"
#include "graph_utilities.hpp"

namespace Arachne {

template <typename T>
concept HasSizeMethod = requires(T x) {
    x.size();
};

template <typename T>
concept DoesNotHaveSizeMethod = !HasSizeMethod<T>;

template <typename Graph, typename Edge, IsStorageTrait Storage, Size N>
struct AdjacencyListStoragePolicy {};

template <typename Graph, typename Edge, Size N>
struct AdjacencyListStoragePolicy<Graph, Edge, Dynamic, N> {
    template <typename InnerContainer>
    using MiddleContainer = std::list<std::pair<NodeIdx, InnerContainer>>;
    template <typename InnerContainer>
    using OuterContainer = std::vector<MiddleContainer<InnerContainer>>;

    void initialize_adjacency_list(Size n = N) {
        static_cast<Graph*>(this)->adjacency_list_.resize(n);
    }
    void add_node_to_representation_() {
        static_cast<Graph*>(this)->adjacency_list_.emplace_back();
    }

    void remove_node_from_representation_(const NodeIdx a) {
        Size removed_edges = static_cast<Graph*>(this)->degree(a);
        static_cast<Graph*>(this)->adjacency_list_.erase(
            static_cast<Graph*>(this)->adjacency_list_.begin() + a);
        for (auto outer = static_cast<Graph*>(this)->adjacency_list_.begin(),
                  end = static_cast<Graph*>(this)->adjacency_list_.end();
             outer != end; outer++) {
            for (auto inner = (*outer).begin(), end = (*outer).end();
                 inner != end; inner++) {
                if (inner->first == a) {
                    inner = outer->erase(inner);
                }
                if (inner->first > a) {
                    inner->first -= 1;
                }
            }
        }
        static_cast<Graph*>(this)->number_of_edges_ -= removed_edges;
    }

  protected:
    template <typename InnerContainer>
    Bool add_edge_to_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        Edge edge) {
        for (auto iter = middle_container.begin(), end = middle_container.end();
             iter != end; iter++) {
            if (iter->first == idx) {
                Bool ret = false;
                ret |= static_cast<Graph*>(this)->add_edge_to_inner_container_(
                    iter->second, edge);
                return ret;
            }
        }
        middle_container.push_back(std::make_pair(idx, InnerContainer()));
        static_cast<Graph*>(this)->add_edge_to_inner_container_(
            middle_container.back().second, edge);
        return true;
    }

    template <HasSizeMethod InnerContainer>
    Bool remove_edge_from_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        Edge edge) {
        for (auto iter = middle_container.begin(), end = middle_container.end();
             iter != end; iter++) {
            if (iter->first == idx) {
                if (iter->second.size() == 1) {
                    middle_container.erase(iter);
                    return true;
                } else {
                    return static_cast<Graph*>(this)
                        ->remove_edge_from_inner_container_(iter->second, edge);
                }
            }
        }
        return false;
    }

    template <DoesNotHaveSizeMethod InnerContainer>
    Bool remove_edge_from_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        ...) {
        for (auto iter = middle_container.begin(), end = middle_container.end();
             iter != end; iter++) {
            if (iter->first == idx) {
                middle_container.erase(iter);
                return true;
            }
        }
        return false;
    }
};

template <typename Graph, typename Edge, Size N>
struct AdjacencyListStoragePolicy<Graph, Edge, Static, N> {
    template <typename InnerContainer>
    using MiddleContainer = std::map<NodeIdx, InnerContainer>;
    template <typename InnerContainer>
    using OuterContainer = std::array<std::map<NodeIdx, InnerContainer>, N>;

    void initialize_adjacency_list() {}

  protected:
    template <typename InnerContainer>
    Bool add_edge_to_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        Edge edge) {
        Bool ret = !middle_container.contains(idx);
        ret |= static_cast<Graph*>(this)->add_edge_to_inner_container_(
            middle_container[idx], edge);
        return ret;
    }

    template <HasSizeMethod InnerContainer>
    Bool remove_edge_from_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        Edge edge) {
        if (middle_container[idx].size() == 1) {
            middle_container.erase(idx);
            return true;
        } else {
            return static_cast<Graph*>(this)->remove_edge_from_inner_container_(
                middle_container[idx], edge);
        }
    }

    template <DoesNotHaveSizeMethod InnerContainer>
    Bool remove_edge_from_middle_container_(
        MiddleContainer<InnerContainer>& middle_container, const NodeIdx idx,
        ...) {
        Bool ret = middle_container.contains(idx);
        middle_container.erase(idx);
        return ret;
    }
};

template <typename Graph, typename Edge, IsDirectionalityTrait Directionality>
struct AdjacencyListDirectionalityPolicy {};

template <typename Graph, typename Edge>
struct AdjacencyListDirectionalityPolicy<Graph, Edge, Undirected> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->add_edge_to_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[source], dest,
            edge);
        if (source != dest) { // avoid duplicating self edges
            static_cast<Graph*>(this)->add_edge_to_middle_container_(
                static_cast<Graph*>(this)->adjacency_list_[dest],
                source, edge);
        }
        static_cast<Graph*>(this)->number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->remove_edge_from_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[source], dest,
            edge);
        static_cast<Graph*>(this)->remove_edge_from_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[dest], source,
            edge);
        static_cast<Graph*>(this)->number_of_edges_ -= success;
    }

    Size degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

  protected:
    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return it > it2 ? 0 : static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge>
struct AdjacencyListDirectionalityPolicy<Graph, Edge, Directed> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->add_edge_to_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[source], dest,
            edge);
        static_cast<Graph&>(*this).number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->remove_edge_from_middle_container_(
            static_cast<Graph*>(this)->adjacency_list_[source], dest,
            edge);
        static_cast<Graph&>(*this).number_of_edges_ -= success;
    }

    Size out_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

    Size in_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(i, n);
        }
        return deg;
    }

    Size degree(NodeIdx n) {
        return in_degree(n)+ out_degree(n)-static_cast<Graph*>(this)->count(n, n);
    }

  protected:
    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge, IsConnectivityTrait Connectivity>
struct AdjacencyListConnectivityPolicy {};

template <typename Graph, typename Edge>
struct AdjacencyListConnectivityPolicy<Graph, Edge, Simple> {
  protected:
    Bool
    add_edge_to_inner_container_(typename Simple::InnerContainer<Edge>& inner,
                                 Edge edge) {
        inner = edge;
        return false;
    }

  public:
    Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second;
            }
        }
        exit(EXIT_FAILURE);
    }

    const Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) const {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second;
            }
        }
        exit(EXIT_FAILURE);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return 1;
            }
        }
        return 0;
    }
};

template <typename Graph, typename Edge>
class AdjacencyListConnectivityPolicy<Graph, Edge, Multi> {
  protected:
    Bool
    add_edge_to_inner_container_(typename Multi::InnerContainer<Edge>& inner,
                                 Edge& edge) {
        inner.push_back(edge);
        return true;
    }

    // removes first encountered edge from inner container
    Bool remove_edge_from_inner_container_(
        typename Multi::template InnerContainer<Edge>& inner_container,
        Edge edge) {
        for (auto iter = inner_container.begin(), end = inner_container.end();
             iter != end; iter++) {
            if ((*iter) == edge) {
                inner_container.erase(iter);
                return true;
            }
        }
        return false;
    }

  public:
    typename Multi::template InnerContainer<Edge>&
    get_edges(const NodeIdx& source, const NodeIdx& dest) {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second;
            }
        }
        exit(EXIT_FAILURE);
    }

    const typename Multi::template InnerContainer<Edge>&
    get_edges(const NodeIdx& source, const NodeIdx& dest) const {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second;
            }
        }
        exit(EXIT_FAILURE);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        for (auto& iter :
             static_cast<Graph*>(this)->adjacency_list_.at(source)) {
            if (iter.first == dest) {
                return iter.second.size();
            }
        }
        return 0;
    }
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, IsStorageTrait Storage,
          IsDirectionalityTrait Directionality,
          IsConnectivityTrait Connectivity>
class AdjacencyList
    : public AdjacencyListStoragePolicy<Graph, Edge, Storage, N>,
      public AdjacencyListDirectionalityPolicy<Graph, Edge, Directionality>,
      public AdjacencyListConnectivityPolicy<Graph, Edge, Connectivity>,
      public IteratorPolicy<Graph, Node, Edge> {

    using StoragePolicy = AdjacencyListStoragePolicy<Graph, Edge, Storage, N>;
    using DirectionalityPolicy =
        AdjacencyListDirectionalityPolicy<Graph, Edge, Directionality>;
    using ConnectivityPolicy =
        AdjacencyListConnectivityPolicy<Graph, Edge, Connectivity>;
    friend StoragePolicy;
    friend DirectionalityPolicy;
    friend ConnectivityPolicy;

  public:
    using StoragePolicy::initialize_adjacency_list;
    using InnerContainer = typename Connectivity::template InnerContainer<Edge>;
    using AdjacencyListContainer =
        typename StoragePolicy::template OuterContainer<InnerContainer>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;
    explicit AdjacencyList() : number_of_edges_(0) {
        initialize_adjacency_list();
    }
    explicit AdjacencyList(Size n) : number_of_edges_(0) {
        initialize_adjacency_list(n);
    }

    const Size& number_of_edges() const { return number_of_edges_; }
    template<typename... Args>
    Size number_of_edges (NodeIdx first, Args... nodes) {
        return static_cast<Graph*>(this)->num_of_edges_({first, nodes...});
    }
    AdjacencyListContainer& get_adjacency_list() { return adjacency_list_; }
    const AdjacencyListContainer& get_adjacency_list() const {
        return adjacency_list_;
    }

    String representation_to_string() {
        std::stringstream ss;
        Size col_width =
            display(static_cast<Graph*>(this)->number_of_nodes(), "[", "]")
                .size();
        Size counter = 0;
        String col_delim = " | ";
        String iter_delim = "\n";
        for (auto iter : static_cast<Graph*>(this)->get_adjacency_list()) {
            ss << std::setw(col_width) << std::left
               << display(counter, "[", "]");
            ss << col_delim;
            ss << display(iter, " : ", ", ", "[", "]");
            ss << iter_delim;
            counter++;
        }
        return ss.str().substr(0, ss.str().size() - iter_delim.size());
    }

    template <IsIteratorTrait T>
    struct Iterator {};

    template <>
    struct Iterator<Neighbour> : public IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename AdjacencyListContainer::value_type::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename AdjacencyListContainer::value_type::iterator, Node>;
        using ListType = AdjacencyListContainer::value_type;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;
        using SuperIterator::SuperIterator;

        const Node &operator*() const override {
            return g->node(it->first);
        }

        Iterator<Neighbour> &operator++() override {
            ++(it);
            return *this;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first);
        }
    };

    template <>
    struct Iterator<Adjacent> : public IteratorPolicy::template SuperIterator<Iterator<Adjacent>, typename AdjacencyListContainer::value_type::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Adjacent>, typename AdjacencyListContainer::value_type::iterator, Node>;
        using ListType = AdjacencyListContainer::value_type;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx source;
        NodeIdx outer_it;

        Iterator<Adjacent> &operator++() override {
            if (it != g->get_adjacency_list()[outer_it].end()) ++it;
            if (source == outer_it) {
                if (it != g->get_adjacency_list()[outer_it].end()) {
                    return *this;
                }
            }
            // keep iterating until source and it->first match
            while (outer_it != g->get_adjacency_list().size()) {
                if (source == outer_it) {
                    if (it != g->get_adjacency_list()[outer_it].end()) {
                        return *this;
                    }
                }
                while (it != g->get_adjacency_list()[outer_it].end()) {
                    if (it->first == source) return *this;
                    ++it;
                }
                outer_it++;
                if (outer_it != g->get_adjacency_list().size()) it = g->get_adjacency_list()[outer_it].begin();
            }

            return *this;
        }

        Bool operator==(const Iterator<Adjacent> &other) {
            return g == other.g && it == other.it && source == other.source && outer_it == other.outer_it;
        }

        inline NodeIdx get_current_node() const {
            return source == outer_it ? it->first : outer_it;
        }

        const Node &operator*() const override {
            return  g->node(get_current_node());
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, get_current_node());
        }

        Iterator<Adjacent>(Graph *g, NodeIdx source):
            SuperIterator{g, g->get_adjacency_list()[0].begin()},
            source{source},
            outer_it{0} {
                if (it == g->get_adjacency_list()[outer_it].end() || (source != outer_it && source != it->first)) {
                    ++(*this);
                }
            }

        Iterator<Adjacent>(Graph *g, NodeIdx source, typename AdjacencyListContainer::value_type::iterator it):
            SuperIterator{g, it},
            source{source},
            outer_it{g->get_adjacency_list().size()}
            {}
    };

    std::pair<Iterator<Neighbour>, Iterator<Neighbour>> get_neighbours(NodeIdx node) {
        return std::make_pair(
            Iterator<Neighbour>(static_cast<Graph*>(this), adjacency_list_[node].begin()),
            Iterator<Neighbour>(static_cast<Graph*>(this), adjacency_list_[node].end())
        );
    }

    std::pair<Iterator<Adjacent>, Iterator<Adjacent>> get_adjacents(NodeIdx node) {
        return std::make_pair(
            Iterator<Adjacent>(static_cast<Graph *>(this), node),
            Iterator<Adjacent>(static_cast<Graph *>(this), node, adjacency_list_.back().end())
        );
    }

    template <>
    struct Iterator<EdgeIterator> : public IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename AdjacencyListContainer::value_type::iterator, typename Connectivity::template InnerContainer<Edge>> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename AdjacencyListContainer::value_type::iterator, typename Connectivity::template InnerContainer<Edge>>;
        using ListType = AdjacencyListContainer::value_type;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        // using SuperIterator::operator==;
        using SuperIterator::SuperIterator;

        NodeIdx node;

        Iterator<EdgeIterator>(Graph *g, NodeIdx node, AdjacencyListContainer::value_type::iterator it) : SuperIterator{g, it}, node{node} {
            while (this->node != g->number_of_nodes() && this->it == g->get_adjacency_list()[this->node].end()) {
                (this->node)++;
                if (this->node == g->number_of_nodes()) break;
                this->it = g->get_adjacency_list()[this->node].begin();
            }
        }

        const typename Connectivity::template InnerContainer<Edge> &operator*() const override {
            return it->second;
        }

        Iterator<EdgeIterator> &operator++() override {
            it++;
            while (node != g->number_of_nodes() && it == g->get_adjacency_list()[node].end()) {
                node++;
                if (node == g->number_of_nodes()) break;
                it = g->get_adjacency_list()[node].begin();
            }
            return *this;
        }

        Bool operator==(const Iterator<EdgeIterator> &other) {
            return g == other.g && node == other.node && (node == g->number_of_nodes() ? true : it == other.it);
        }

        typename IteratorPolicy::template Iterator<Basic> first () {
            return typename IteratorPolicy::template Iterator<Basic>(g, node);
        }

        typename IteratorPolicy::template Iterator<Basic> second () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first);
        }

        const Edge &edge () const {
            return it->second;
        }   
    };

    std::pair<Iterator<EdgeIterator>, Iterator<EdgeIterator>> get_edges() {
        return std::make_pair(
            Iterator<EdgeIterator>(static_cast<Graph*>(this), 0, adjacency_list_[0].begin()),
            Iterator<EdgeIterator>(static_cast<Graph*>(this), static_cast<Graph*>(this)->number_of_nodes(),adjacency_list_[static_cast<Graph*>(this)->number_of_nodes()-1].end())
        );
    }

  protected:
    Size number_of_edges_;
    AdjacencyListContainer adjacency_list_;
};

} // namespace Arachne

#endif // ADJACENCY_LIST_POLICY_HPP
</file>

<file path="AdjacencyMatrixPolicy.hpp">
#ifndef ADJACENCY_MATRIX_POLICY_HPP
#define ADJACENCY_MATRIX_POLICY_HPP

#include <iomanip>
#include <iostream>
#include <optional>
#include <sstream>
#include <vector>
#include <numeric>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "display.hpp"

namespace Arachne {

template <typename Graph, typename Edge, typename Storage,
          typename Connectivity, Size N>
struct AdjacencyMatrixStoragePolicy {};

template <typename Graph, typename Edge, typename Connectivity, Size N>
struct AdjacencyMatrixStoragePolicy<Graph, Edge, Dynamic, Connectivity, N> {
    template <typename InnerContainer, Size...>
    using OuterContainer = std::vector<InnerContainer>;


    void initialize_adjacency_matrix(Size n = N) {
        static_cast<Graph*>(this)->adjacency_matrix_.resize(static_cast<Graph*>(this)->number_of_elements(n));
    }

    void add_node_to_representation_() {
        Size dim = static_cast<Graph*>(this)->number_of_nodes();
        for (Size j = 0; j < dim - 1; j++) {
            static_cast<Graph*>(this)->adjacency_matrix_.insert(
                static_cast<Graph*>(this)->adjacency_matrix_.begin() +
                    static_cast<Graph*>(this)->end_of_row_(j),
                std::nullopt);
        }
        static_cast<Graph*>(this)->adjacency_matrix_.insert(
            static_cast<Graph*>(this)->adjacency_matrix_.end(),
            static_cast<Graph*>(this)->elements_in_new_row_(), std::nullopt);
    }

    void remove_node_from_representation_(const NodeIdx a) {
        Size removed_edges = static_cast<Graph*>(this)->degree(a);
        SizeSet indices_to_remove;
        for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
             j++) {
            indices_to_remove.insert(static_cast<Graph*>(this)->get_index_(j, a));
            if (j != a) {
                indices_to_remove.insert(static_cast<Graph*>(this)->get_index_(a, j));
            }
        }
        for (auto iter = indices_to_remove.rbegin(),
                  first = indices_to_remove.rend();
             iter != first; iter++) {
            static_cast<Graph*>(this)->adjacency_matrix_.erase(
                static_cast<Graph*>(this)->adjacency_matrix_.begin() + (*iter));
        }
        static_cast<Graph*>(this)->number_of_edges_ -= removed_edges;
    }
};

template <typename Graph, typename Edge, typename Connectivity, Size N>
struct AdjacencyMatrixStoragePolicy<Graph, Edge, Static, Connectivity, N> {

    template <typename InnerContainer, Size M>
    using OuterContainer = std::array<InnerContainer, M>;
    void initialize_adjacency_matrix() {}
};

template <typename Graph, typename Edge, typename Directionality, Size N>
struct AdjacencyMatrixDirectionalityPolicy {};

template <typename Graph, typename Edge, Size N>
struct AdjacencyMatrixDirectionalityPolicy<Graph, Edge, Undirected, N> {
    constexpr Size get_index_(NodeIdx a, NodeIdx b) const {
        if (a > b) {
            Size temp = a;
            a = b;
            b = temp;
        }
        return static_cast<const Graph*>(this)->start_of_row_(a) + b - a;
    }

    static constexpr Size initial_number_of_elements() {
        return N * (N + 1) / 2;
    }
    static Size number_of_elements(Size n) { return n * (n + 1) / 2; }

    constexpr Size current_number_of_elements() const {
        return (static_cast<const Graph*>(this)->number_of_nodes() *
               (static_cast<const Graph*>(this)->number_of_nodes() + 1)) / 2;
    }

  protected:
    Size start_of_row_(const Size j) const {
        return j*static_cast<const Graph*>(this)->number_of_nodes() - (j*(j-1))/2;
    }
    Size end_of_row_(const Size j) const {
        return (j+1)*static_cast<const Graph*>(this)->number_of_nodes() - (j*(j+1))/2-1;
    }
    Size elements_in_row(const Size j) const {
        return static_cast<const Graph*>(this)->number_of_nodes() - j;
    }

    Size elements_in_new_row_() const { return 1; }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return it > it2 ? 0 : static_cast<Graph*>(this)->count(it, it2); }); });
    }
  public:
    Size degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }
};

template <typename Graph, typename Edge, Size N>
struct AdjacencyMatrixDirectionalityPolicy<Graph, Edge, Directed, N> {
    constexpr Size get_index_(const NodeIdx& a, const NodeIdx b) const {
        return static_cast<const Graph*>(this)->start_of_row_(a) +
               b;
    }

    static constexpr Size initial_number_of_elements() { return N * N; }
    static Size number_of_elements(Size n) { return n * n; }
    constexpr Size current_number_of_elements() const {
        return static_cast<const Graph*>(this)->number_of_nodes() *
               static_cast<const Graph*>(this)->number_of_nodes();
    }

    const Edge& operator()(const Size j, const Size k) const {
        return static_cast<const Graph*>(this)->adjacency_matrix_.at(get_index_(j, k));
    }

  protected:
    Size start_of_row_(const Size j) const {
        return j * static_cast<const Graph*>(this)->number_of_nodes();
    }
    Size end_of_row_(const Size j) const {
        return ((j + 1) * static_cast<const Graph*>(this)->number_of_nodes()) -
               1;
    }
    Size elements_in_row_(const Size...) const {
        return static_cast<const Graph*>(this)->number_of_nodes();
    }
    Size elements_in_new_row_() const {
        return static_cast<const Graph*>(this)->number_of_nodes();
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return static_cast<Graph*>(this)->count(it, it2); }); });
    }
  public:
    Size out_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

    Size in_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(i, n);
        }
        return deg;
    }

    Size degree(NodeIdx n) {
        return in_degree(n)+ out_degree(n)-static_cast<Graph*>(this)->count(n, n);
    }
};

template <typename Graph, typename Edge, typename Directionality,
          typename Connectivity>
struct AdjacencyMatrixConnectivityPolicy {};

template <typename Graph, typename Edge, typename Directionality>
struct AdjacencyMatrixConnectivityPolicy<Graph, Edge, Directionality, Simple> {
    Bool add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        if (source >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr
                << "ARACHNE ERROR: In add_edge, idx.first node doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        if (dest >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr
                << "ARACHNE ERROR: In add_edge, idx.second node doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        static_cast<Graph*>(this)->number_of_edges_ += !(static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)).has_value());
        static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)) = edge;
        return true;
    }
    Bool remove_edge(const NodeIdx& source, const NodeIdx& dest, ...) {
        if (source >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr << "ARACHNE ERROR: In remove_edge, idx.first node "
                         "doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        if (dest >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr << "ARACHNE ERROR: In remove_edge, idx.second node "
                         "doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        static_cast<Graph*>(this)->number_of_edges_ -= static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)).has_value();
        static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)) = std::nullopt;
        return false;
    }
    Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) {
        return static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)).value();
    }
    const Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) const {
        return static_cast<Graph*>(this)->adjacency_matrix_.at(
            static_cast<Graph*>(this)->get_index_(source, dest)).value();
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        return static_cast<Graph*>(this)->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest)).has_value();
    }

    String representation_to_string() {
        std::stringstream os;
        auto max_widths = std::unique_ptr<Size[]>(
            new Size[static_cast<Graph*>(this)->number_of_nodes()]);
        for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
             j++) {
            max_widths[j] = 0;
            for (Size i = 0; i < static_cast<Graph*>(this)->number_of_nodes();
                 i++) {
                std::stringstream ss;
                if (static_cast<Graph*>(this)->count(i, j)) {
                    ss << 1;
                } else {
                    ss << "0";
                }
                max_widths[j] = std::max(max_widths[j], ss.str().size() + 1);
            }
        }
        for (Size i = 0; i < static_cast<Graph*>(this)->number_of_nodes();
             i++) {
            for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
                 j++) {
                std::stringstream ss;
                if (static_cast<Graph*>(this)->count(i, j)) {
                    ss << 1;
                } else {
                    ss << "0";
                }
                os << std::setw(max_widths[j]) << std::left << ss.str();
                if (j < (static_cast<Graph*>(this)->number_of_nodes() - 1)) {
                    os << " ";
                }
            }
            if (i < (static_cast<Graph*>(this)->number_of_nodes() - 1)) {
                os << '\n';
            }
        }
        return os.str();
    }
};

template <typename Graph, typename Edge, typename Directionality>
struct AdjacencyMatrixConnectivityPolicy<Graph, Edge, Directionality, Multi> {
    Bool add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        if (source >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr
                << "ARACHNE ERROR: In add_edge, idx.first node doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        if (dest >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr
                << "ARACHNE ERROR: In add_edge, idx.second node doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        Size index = static_cast<Graph*>(this)->get_index_(source, dest);
        if (!static_cast<Graph*>(this)
                 ->adjacency_matrix_.at(index)
                 .has_value()) {
            static_cast<Graph*>(this)->adjacency_matrix_.at(index) =
                typename Multi::template InnerContainer<Edge>{edge};
        } else {
            static_cast<Graph*>(this)
                ->adjacency_matrix_.at(index)
                .value()
                .push_back(edge);
        }
        static_cast<Graph*>(this)->number_of_edges_++;
        return true;
    }
    Bool remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        if (source >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr << "ARACHNE ERROR: In remove_edge, idx.first node "
                         "doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        if (dest >= static_cast<Graph*>(this)->number_of_nodes()) {
            std::cerr << "ARACHNE ERROR: In remove_edge, idx.second node "
                         "doesn't exist\n";
            exit(EXIT_FAILURE);
        }
        Size index = static_cast<Graph*>(this)->get_index_(source, dest);
        if (!static_cast<Graph*>(this)
                 ->adjacency_matrix_.at(index)
                 .has_value()) {
            return false;
        }
        for (auto iter = static_cast<Graph*>(this)
                             ->adjacency_matrix_.at(index)
                             .value()
                             .begin(),
                  end = static_cast<Graph*>(this)
                            ->adjacency_matrix_.at(index)
                            .value()
                            .end();
             iter != end; iter++) {
            if ((*iter) == edge) {
                static_cast<Graph*>(this)
                    ->adjacency_matrix_.at(index)
                    .value()
                    .erase(iter);
                if (static_cast<Graph*>(this)
                        ->adjacency_matrix_.at(index)
                        .value()
                        .size() == 0) {
                    static_cast<Graph*>(this)->adjacency_matrix_.at(index) =
                        std::nullopt;
                }
                static_cast<Graph*>(this)->number_of_edges_--;
                return true;
            }
        }
        return false;
    }
    typename Multi::template InnerContainer<std::optional<Edge>>&
    get_edges(const NodeIdx& source, const NodeIdx& dest) {
        return static_cast<Graph*>(this)
            ->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest))
            .value();
    }
    const typename Multi::template InnerContainer<std::optional<Edge>>&
    get_edges(const NodeIdx& source, const NodeIdx& dest) const {
        return static_cast<Graph*>(this)
            ->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest))
            .value();
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        return static_cast<Graph*>(this)->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest)).has_value() ? static_cast<Graph*>(this)->adjacency_matrix_.at(static_cast<Graph*>(this)->get_index_(source, dest)).value().size() : 0;
    }

    String representation_to_string() {
        std::stringstream os;
        auto max_widths = std::unique_ptr<Size[]>(
            new Size[static_cast<Graph*>(this)->number_of_nodes()]);
        for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
             j++) {
            max_widths[j] = 0;
            for (Size i = 0; i < static_cast<Graph*>(this)->number_of_nodes();
                 i++) {
                std::stringstream ss;
                if (static_cast<Graph*>(this)->count(i, j)) {
                    ss << static_cast<Graph*>(this)->at(i, j).value().size();
                } else {
                    ss << "0";
                }
                max_widths[j] = std::max(max_widths[j], ss.str().size() + 1);
            }
        }
        for (Size i = 0; i < static_cast<Graph*>(this)->number_of_nodes();
             i++) {
            for (Size j = 0; j < static_cast<Graph*>(this)->number_of_nodes();
                 j++) {
                std::stringstream ss;
                if (static_cast<Graph*>(this)->count(i, j)) {
                    ss << static_cast<Graph*>(this)->at(i, j).value().size();
                } else {
                    ss << "0";
                }
                os << std::setw(max_widths[j]) << std::left << ss.str();
                if (j < (static_cast<Graph*>(this)->number_of_nodes() - 1)) {
                    os << " ";
                }
            }
            if (i < (static_cast<Graph*>(this)->number_of_nodes() - 1)) {
                os << '\n';
            }
        }
        return os.str();
    }
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, typename Storage,
          typename Directionality, typename Connectivity>
class AdjacencyMatrix
    : public AdjacencyMatrixStoragePolicy<Graph, Edge, Storage, Connectivity,
                                          N>,
      public AdjacencyMatrixDirectionalityPolicy<Graph, Edge, Directionality,
                                                 N>,
      public AdjacencyMatrixConnectivityPolicy<Graph, Edge, Directionality,
                                               Connectivity>,
      public IteratorPolicy<Graph, Node, Edge> {
    using StoragePolicy =
        AdjacencyMatrixStoragePolicy<Graph, Edge, Storage, Connectivity, N>;
    using DirectionalityPolicy =
        AdjacencyMatrixDirectionalityPolicy<Graph, Edge, Directionality, N>;
    using ConnectivityPolicy =
        AdjacencyMatrixConnectivityPolicy<Graph, Edge, Directionality,
                                          Connectivity>;
    friend StoragePolicy;
    friend DirectionalityPolicy;
    friend ConnectivityPolicy;

  public:
    using DirectionalityPolicy::get_index_;
    using StoragePolicy::initialize_adjacency_matrix;
    using ElementType =
        std::optional<typename Connectivity::template InnerContainer<Edge>>;
    using AdjacencyMatrixContainer =
        typename StoragePolicy::template OuterContainer<
            ElementType, DirectionalityPolicy::initial_number_of_elements()>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;

    explicit AdjacencyMatrix() : number_of_edges_(0) { initialize_adjacency_matrix(); }
    explicit AdjacencyMatrix(Size n) : number_of_edges_(0) {
        initialize_adjacency_matrix(n);
    }

    const Size& number_of_edges() const { return number_of_edges_; }

    template<typename... Args>
    Size number_of_edges (NodeIdx first, Args... nodes) {
        return static_cast<Graph*>(this)->num_of_edges_({first, nodes...});
    }
    AdjacencyMatrixContainer& get_adjacency_matrix() {
        return adjacency_matrix_;
    }
    const AdjacencyMatrixContainer& get_adjacency_matrix() const {
        return adjacency_matrix_;
    }

  protected:
    const ElementType& at(const Size j, const Size k) const {
        return adjacency_matrix_.at(get_index_(j, k));
    }
    ElementType& at(const Size j, const Size k) {
        return adjacency_matrix_.at(get_index_(j, k));
    }
  public:
    template<IsIteratorTrait T, IsIteratorParameters ParamList = IteratorParameters<>>
    struct Iterator {};

    template <>
    struct Iterator<Neighbour> : public IteratorPolicy::template SuperIterator<Iterator<Neighbour>, NodeIdx, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Neighbour>, NodeIdx, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx source;

        Iterator<Neighbour>(Graph *g, NodeIdx source, NodeIdx dest) : SuperIterator{g, dest}, source{source} {
            while (it != g->number_of_nodes() && not g->count(source, it)) { it++; }
        }

        const Node &operator *() const { return g->node(it); }

        Iterator<Neighbour> &operator++() {
            while (++it != g->number_of_nodes() && not g->count(source, it));
            return *this;
        }

        Bool operator==(const Iterator<Neighbour> &other) {
            return g == other.g && it == other.it && source == other.source;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it);
        }
    };

    template <>
    struct Iterator<Adjacent> : public IteratorPolicy::template SuperIterator<Iterator<Adjacent>, NodeIdx, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Adjacent>, NodeIdx, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx source;

        Iterator<Adjacent>(Graph *g, NodeIdx source, NodeIdx dest) : SuperIterator{g, dest}, source{source} {
            while (it != g->number_of_nodes() && !(g->count(source, it) || g->count(it, source))) { it++; }
        }

        const Node &operator *() const { return g->node(it); }

        Iterator<Adjacent> &operator++() {
            if (it == g->number_of_nodes()) return *this;
            do it++; while (it != g->number_of_nodes() && !(g->count(source, it) || g->count(it, source)));
            return *this;
        }

        Bool operator==(const Iterator<Adjacent> &other) {
            return g == other.g && it == other.it && source == other.source;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it);
        }
    };

    std::pair<Iterator<Neighbour>, Iterator<Neighbour>> get_neighbours(NodeIdx node) {
        return std::make_pair(
            Iterator<Neighbour>(static_cast<Graph*>(this), node, 0),
            Iterator<Neighbour>(static_cast<Graph*>(this), node, static_cast<Graph*>(this)->number_of_nodes())
        );
    }

    std::pair<Iterator<Adjacent>, Iterator<Adjacent>> get_adjacents(NodeIdx node) {
        return std::make_pair(
            Iterator<Adjacent>(static_cast<Graph*>(this), node, 0),
            Iterator<Adjacent>(static_cast<Graph*>(this), node, static_cast<Graph*>(this)->number_of_nodes())
        );
    }
    template <>
    struct Iterator<EdgeIterator> : public IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, NodeIdx, typename Connectivity::template InnerContainer<Edge>> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, NodeIdx, typename Connectivity::template InnerContainer<Edge>>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx source;

        Iterator<EdgeIterator>(Graph *g, NodeIdx source, NodeIdx dest) : SuperIterator{g, dest}, source{source} {
            while (this->source != g->number_of_nodes() && it != g->number_of_nodes() && not g->count(this->source, it)) {
                it++;
                if (it == g->number_of_nodes()) {
                    it = 0;
                    (this->source)++;
                }
            }
        }

        const typename Connectivity::template InnerContainer<Edge> &operator *() const { return g->at(source, it).value(); }

        Iterator<EdgeIterator> &operator++() {
            do { 
                it++;
                if (it == g->number_of_nodes()) {
                    it = 0;
                    source++;
                }
            } while (source != g->number_of_nodes() && it != g->number_of_nodes() && !g->count(source, it));
            
            return *this;
        }

        Bool operator==(const Iterator<EdgeIterator> &other) {
            return g == other.g && it == other.it && source == other.source;
        }

        typename IteratorPolicy::template Iterator<Basic> first () {
            return typename IteratorPolicy::template Iterator<Basic>(g, source);
        }

        typename IteratorPolicy::template Iterator<Basic> second () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it);
        }

        const Connectivity::template InnerContainer<Edge> &edge () const {
            return g->at(source, it).value();
        }  
    };

    std::pair<Iterator<EdgeIterator>, Iterator<EdgeIterator>> get_edges() {
        return std::make_pair(
            Iterator<EdgeIterator>(static_cast<Graph*>(this), 0, 0),
            Iterator<EdgeIterator>(static_cast<Graph*>(this), static_cast<Graph*>(this)->number_of_nodes(), 0)
        );
    }



  protected:
    Size number_of_edges_;
    AdjacencyMatrixContainer adjacency_matrix_;
};

} // namespace Arachne

#endif // ADJACENCY_MATRIX_POLICY_HPP
</file>

<file path="ArachneData.hpp">
#ifndef ARACHNE_DATA_HPP
#define ARACHNE_DATA_HPP

#include "Types.hpp"

namespace Arachne {

template <typename T>
concept HasIndex = requires(T x) {
    {x.index};
};

template <typename T>
concept HasWeight = requires(T x) {
    {x.weight};
};

template <typename T>
concept HasColor = requires(T x) {
    {x.color};
};

template <typename T>
concept HasName = requires(T x) {
    {x.name};
};

struct Index {
    using Data = Size;
    Data index{};

    template <HasIndex T>
    void set_value(Data value, T* x) {
        x->index = value;
    }

    template <HasIndex T>
    String to_string(const T* x) const {
        return "Index: " + std::to_string(x->index);
    }
};

struct Weight {
    using Data = Real;
    Data weight{};

    template <HasWeight T>
    void set_value(Data value, T* x) {
        x->weight = value;
    }

    template <HasWeight T>
    String to_string(const T* x) const {
        return "Weight: " + std::to_string(x->weight);
    }
};

struct Color {
    using Data = Int32;
    Data color{};

    template <HasColor T>
    void set_value(Data value, T* x) {
        x->color = value;
    }

    template <HasColor T>
    String to_string(const T* x) const {
        return "Color: " + std::to_string(x->color);
    }
};

struct Name {
    using Data = String;
    Data name{};

    template <HasName T>
    void set_value(Data value, T* x) {
        x->name = value;
    }

    template <HasName T>
    String to_string(const T* x) const {
        return "Name: " + x->name;
    }
};

template <typename T>
concept IsArachneData = std::same_as<T, Weight> || std::same_as<T, Color> ||
                        std::same_as<T, Name> || std::same_as<T, Index>;

template <typename T>
concept IsNotArachneData = not IsArachneData<T>;

} // namespace Arachne

#endif // ARACHNE_DATA_HPP
</file>

<file path="BasicBitMap.hpp">
#ifndef ARACHNE_BASICBITMAP_HPP
#define ARACHNE_BASICBITMAP_HPP

#include "Types.hpp"

namespace Arachne {

struct BasicBitMap {
    using value_type = NodeIdx;

    std::vector<Bool> bitmap;
    Size n;

    BasicBitMap(Size n, Bool b = false) : bitmap(n, b), n{b ? n : 0} {}

    BasicBitMap() : bitmap(), n{0} {}

    std::pair<value_type, Bool> insert(const value_type& it) {
        Bool b = !bitmap.at(it);
        n += b;
        bitmap[it] = true;
        return std::make_pair(it, b);
    }

    Bool erase(const value_type &it) {
        Bool b = bitmap.at(it);
        n -= b;
        bitmap[it] = false;
        return b;
    }

    Bool contains(const value_type& it) const { return bitmap.at(it); }

    Size size() const { return n; }

    Bool empty() const { return n == 0; }

    class iterator {
        std::vector<Bool> &bitmap;
        value_type posn;

    public:
        iterator(std::vector<Bool> &bitmap, value_type posn): bitmap{bitmap}, posn{posn} {}

        iterator operator++() {
            if (posn == bitmap.size()) return *this;
            while (!bitmap[++posn] && posn != bitmap.size());
            return *this;
        }
        iterator operator++(int) {
            iterator tmp = *this;
            ++(*this);
            return tmp;
        }
        iterator operator--() {
            while (!bitmap[--posn]);
            return *this;
        }
        iterator operator--(int) {
            iterator tmp = *this;
            --(*this);
            return tmp;
        }
        bool operator==(const iterator &other) const {
            return &bitmap == &(other.bitmap) && posn == other.posn;
        }
        bool operator!=(const iterator &other) const {
            return !(*this == other);
        }
        value_type operator*() {
            return posn;
        }
    };

    iterator begin() {
        Size start = 0;
        while (start != bitmap.size() && !bitmap[start]) ++start;
        return iterator(bitmap, start);
    }

    iterator end() {
        return iterator(bitmap, bitmap.size());
    }
};

} // namespace Arachne

#endif // ARACHNE_BASICBITMAP_HPP
</file>

<file path="Clique.hpp">
#ifndef ARACHNE_CLIQUE_HPP
#define ARACHNE_CLIQUE_HPP

#include <functional>
#include "BasicBitMap.hpp"
#include "Traits.hpp"

namespace Arachne {

struct Backtracking {};

template <typename Graph>
BasicBitMap get_free_neighbours(const typename Graph::IteratorPolicy::template Iterator<Basic>& node, const std::function<Bool(const typename Graph::IteratorPolicy::template Iterator<Basic>&)>& pred) {
    BasicBitMap c(node.g->number_of_nodes());
    auto neighbours = node.g->get_neighbours(node);
    for (auto it = neighbours.first; it != neighbours.second; ++it) {
        if (pred(it)) {
            c.insert((typename Graph::IteratorPolicy::template Iterator<Basic>)it);
        }
    }
    return c;
}

template <typename Graph>
void clique_backtracking(
    Graph& g, BasicBitMap candidates,
    BasicBitMap& current_clique, std::vector<NodeIdx>& max_clique, std::vector<Size>& degree_map) {
    if (candidates.empty() || candidates.size() + current_clique.size() <= max_clique.size()) {
        if (current_clique.size() > max_clique.size()) {
            max_clique.clear();
            for (auto i : current_clique) max_clique.push_back(i);
        }
        return;
    }

    for (auto node : candidates) {
        current_clique.insert(node);
        clique_backtracking(
            g,
            get_free_neighbours<Graph>(g.template begin<Basic>() + node, [&] (const auto & n) { return candidates.contains(n) && !current_clique.contains(n) && g.count(n, node) && degree_map[node] >= max_clique.size();}),
            current_clique, max_clique, degree_map);
        current_clique.erase(node);
    }
}

template <typename B, typename Graph>
requires std::same_as<Backtracking, B>
std::vector<typename Graph::IteratorPolicy::template Iterator<Basic>> maximum_clique(Graph& g) {
    BasicBitMap map(g.number_of_nodes());
    for (auto i = 0; i < g.number_of_nodes(); i++) {
        map.insert(i);
    }
    std::vector<Size> deg(g.number_of_nodes());
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); node++) deg[node] = g.degree(node);
    std::vector<NodeIdx> max_clique;
    BasicBitMap current_clique(g.number_of_nodes());
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>();
         node++) {
        if (node == 0) {
            max_clique.push_back(node);
        }
        current_clique.insert(node);
        clique_backtracking(g, get_free_neighbours<Graph>(node, [&] (const auto & n) { return !current_clique.contains(n) && g.count(n, node);}), current_clique, max_clique, deg);
        current_clique.erase(node);
    }

    std::vector<typename Graph::IteratorPolicy::template Iterator<Basic>> retval;
    for (auto i : max_clique) {
        retval.push_back(g.template begin<Basic>() + i);
    }
    return retval;
}

template <typename Graph>
void BronKerbosch (Graph& g, std::vector<std::vector<NodeIdx>>& cliques, BasicBitMap& R, BasicBitMap P, BasicBitMap X) {
    if (P.empty() && X.empty()) {
        cliques.emplace_back();
        for (auto i : R) cliques.back().push_back(i);
        return;
    }
    auto pivot = P.empty() ? g.template begin<Basic>() + *X.begin() : g.template begin<Basic>() + *P.begin();
    auto N_pivot = get_free_neighbours<Graph>(pivot, [] (const auto & n) { return true; });
    for (auto v: P) {
        if (N_pivot.contains(v)) continue;
        R.insert(v);
        BronKerbosch(g, cliques, R, get_free_neighbours<Graph>(g.template begin<Basic>() + v, [&](const auto & n) { return P.contains(n); }), get_free_neighbours<Graph>(g.template begin<Basic>() + v, [&](auto & n) { return X.contains(n); }));
        R.erase(v);
        P.erase(v);
        X.insert(v);
    }
}

template <typename Graph>
std::vector<std::vector<NodeIdx>> maximal_cliques (Graph& g) {
    std::vector<std::vector<NodeIdx>> retval;
    BasicBitMap R(g.number_of_nodes());
    BasicBitMap P(g.number_of_nodes(), true);
    for (auto i = 0; i < g.number_of_nodes(); i++) {
        P.insert(i);
    }
    BasicBitMap X(g.number_of_nodes());
    BronKerbosch(g, retval, R, P, BasicBitMap(g.number_of_nodes()));
    return retval;
}

} // namespace Arachne

#endif // ARACHNE_CLIQUE_HPP
</file>

<file path="CompressedFormatPolicy.hpp">
#ifndef COMPRESSED_FORMAT_POLICY_HPP
#define COMPRESSED_FORMAT_POLICY_HPP

#include <numeric>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "graph_utilities.hpp"

namespace Arachne {

template <typename Graph, typename Edge, IsStorageTrait Storage, Size N>
struct CompressedFormatStoragePolicy {};

template <typename Graph, typename Edge, Size N>
struct CompressedFormatStoragePolicy<Graph, Edge, Dynamic, N> {
    using NodeContainer = std::vector<unsigned>;

    void initialize_node_list(Size n = N) {
        static_cast<Graph*>(this)->node_list_ = NodeContainer(n+1, 0);
    }

    void add_node_to_representation_() {
        static_cast<Graph*>(this)->node_list_.push_back(static_cast<Graph*>(this)->edge_list_.size());
    }
    void remove_node_from_representation_(const NodeIdx a) {
        Size removed_edges = static_cast<Graph*>(this)->degree(a);
        int diff = static_cast<Graph*>(this)->node_list_.at(a + 1) - static_cast<Graph*>(this)->node_list_.at(a);
        static_cast<Graph*>(this)->edge_list_.erase(static_cast<Graph*>(this)->edge_list_.begin() + static_cast<Graph*>(this)->node_list_.at(a), static_cast<Graph*>(this)->edge_list_.begin() + static_cast<Graph*>(this)->node_list_.at(a + 1));
        static_cast<Graph*>(this)->node_list_.erase(static_cast<Graph*>(this)->node_list_.begin() + a);
        for (Size i = a; i < static_cast<Graph*>(this)->node_list_.size(); i++) static_cast<Graph*>(this)->node_list_.at(i) -= diff;

        NodeIdx j = 0;
        for (int i = 0; i < static_cast<Graph*>(this)->edge_list_.size(); i++) {
            while (static_cast<Graph*>(this)->node_list_[j] == i) j++;
            if (a == static_cast<Graph*>(this)->edge_list_.at(i).first) {
                static_cast<Graph*>(this)->edge_list_.erase(static_cast<Graph*>(this)->edge_list_.begin() + i);
                for(NodeIdx k = j; k < static_cast<Graph*>(this)->node_list_.size(); k++) static_cast<Graph*>(this)->node_list_[k] -= 1;
                i--;
            }
            else if (static_cast<Graph*>(this)->edge_list_.at(i).first > a) {
                static_cast<Graph*>(this)->edge_list_.at(i).first -= 1;
            }
        }

        static_cast<Graph*>(this)->number_of_edges_ -= removed_edges;
    }
};

template <typename Graph, typename Edge, Size N>
struct CompressedFormatStoragePolicy<Graph, Edge, Static, N> {
    using NodeContainer = std::array<unsigned, N+1>;

    void initialize_node_list() {
        static_cast<Graph*>(this)->node_list_.fill(0);
    }
};

template <typename Graph, typename Edge, IsDirectionalityTrait Directionality>
struct CompressedFormatDirectionalityPolicy {};

template <typename Graph, typename Edge>
struct CompressedFormatDirectionalityPolicy<Graph, Edge, Undirected> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        EdgeIdx reversed = reverse_edge_idx(std::make_pair(source, dest));
        Bool success = static_cast<Graph*>(this)->add_edge_to_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph*>(this)->add_edge_to_inner_container_(reversed, edge);
        static_cast<Graph*>(this)->number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        EdgeIdx reversed = reverse_edge_idx(std::make_pair(source, dest));
        Bool success = static_cast<Graph*>(this)->remove_edge_from_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph*>(this)->remove_edge_from_inner_container_(reversed, edge);
        static_cast<Graph*>(this)->number_of_edges_ -= success;
    }

    Size degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

protected:
    static Bool contains_neighbour_(NodeIdx node, EdgeIdx edge) {
        return node == edge.first || node == edge.second;
    }

    EdgeIdx order_edge_ (const EdgeIdx& idx) {
        return order_edge_idx(idx);
    }

    EdgeIdx reverse_edge_ (const EdgeIdx& idx) {
        return reverse_edge_idx(idx);
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return it > it2 ? 0 : static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge>
struct CompressedFormatDirectionalityPolicy<Graph, Edge, Directed> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->add_edge_to_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph&>(*this).number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->remove_edge_from_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph&>(*this).number_of_edges_ -= success;
    }

    Size out_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

    Size in_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(i, n);
        }
        return deg;
    }

    Size degree(NodeIdx n) {
        return in_degree(n)+ out_degree(n)-static_cast<Graph*>(this)->count(n, n);
    }

protected:
    static Bool contains_neighbour_(NodeIdx node, EdgeIdx edge) {
        return node == edge.first;
    }

    EdgeIdx order_edge_ (const EdgeIdx& idx) {
        return idx;
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge, IsConnectivityTrait Connectivity>
struct CompressedFormatConnectivityPolicy {};

template <typename Graph, typename Edge>
struct CompressedFormatConnectivityPolicy<Graph, Edge, Simple> {

  protected:
    Bool add_edge_to_inner_container_(const EdgeIdx& idx, Edge& edge) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(idx.first);index != static_cast<Graph*>(this)->node_list_.at(idx.first+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == idx.second) {
                static_cast<Graph*>(this)->edge_list_.at(index) = std::make_pair(idx.second, edge);
                return false;
            }
        }
        static_cast<Graph*>(this)->edge_list_.insert(static_cast<Graph*>(this)->edge_list_.begin() + static_cast<Graph*>(this)->node_list_.at(idx.first), std::make_pair(idx.second, edge));
        for (NodeIdx i = idx.first + 1;i <= static_cast<Graph*>(this)->number_of_nodes(); i++) {
            static_cast<Graph*>(this)->node_list_.at(i)++;
        }
        return true;
    }

    Bool remove_edge_from_inner_container_(const EdgeIdx& idx, ...) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(idx.first);index != static_cast<Graph*>(this)->node_list_.at(idx.first+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == idx.second) {
                static_cast<Graph*>(this)->edge_list_.erase(static_cast<Graph*>(this)->edge_list_.begin() + index);
                for (NodeIdx i = idx.first + 1;i <= static_cast<Graph*>(this)->number_of_nodes(); i++) {
                    static_cast<Graph*>(this)->node_list_.at(i)--;
                }
                return true;
            }
        }
        return false;
    }
  public:
    Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(source);index != static_cast<Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<Graph*>(this)->edge_list_.at(index).second;
        }
        exit(EXIT_FAILURE);
    }
    const Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) const {
        for (unsigned index = static_cast<const Graph*>(this)->node_list_.at(source);index != static_cast<const Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<const Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<const Graph*>(this)->edge_list_.at(index).second;
        }
        exit(EXIT_FAILURE);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        for (unsigned index = static_cast<const Graph*>(this)->node_list_.at(source);index != static_cast<const Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<const Graph*>(this)->edge_list_.at(index).first == dest) return 1;
        }
        return 0;
    }
};

template <typename Graph, typename Edge>
struct CompressedFormatConnectivityPolicy<Graph, Edge, Multi> {
  protected:
    Bool add_edge_to_inner_container_(const EdgeIdx& idx, Edge edge = Edge()) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(idx.first);index != static_cast<Graph*>(this)->node_list_.at(idx.first+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == idx.second) {
                static_cast<Graph*>(this)->edge_list_.at(index).second.push_back(edge);
                return true;
            }
        }
        static_cast<Graph*>(this)->edge_list_.insert(static_cast<Graph*>(this)->edge_list_.begin() + static_cast<Graph*>(this)->node_list_.at(idx.first), std::make_pair(idx.second, Multi::InnerContainer<Edge>{edge}));
        for (NodeIdx i = idx.first + 1;i <= static_cast<Graph*>(this)->number_of_nodes(); i++) {
            static_cast<Graph*>(this)->node_list_.at(i)++;
        }
        return true;
    }

    Bool remove_edge_from_inner_container_(const EdgeIdx& idx, Edge edge = Edge()) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(idx.first);index != static_cast<Graph*>(this)->node_list_.at(idx.first+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == idx.second) {
                for (auto & iter : static_cast<Graph*>(this)->edge_list_.at(index).second) {
                    if (iter == edge) {
                        static_cast<Graph*>(this)->edge_list_.at(index).second.at(idx).erase(iter);
                        if (static_cast<Graph*>(this)->edge_list_.at(index).second.size() == 0) {
                            static_cast<Graph*>(this)->edge_list_.erase(static_cast<Graph*>(this)->edge_list_.begin() + index);
                            for (NodeIdx i = idx.first + 1; i <= static_cast<Graph*>(this)->number_of_nodes(); i++) {
                                static_cast<Graph*>(this)->node_list_.at(i)--;
                            }
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    }
  public:
    Edge& get_edges(const NodeIdx& source, const NodeIdx& dest) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(source);index != static_cast<Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<Graph*>(this)->edge_list_.at(index).second;
        }
    }
    const Edge& get_edges(const NodeIdx& source, const NodeIdx& dest) const {
        for (unsigned index = static_cast<const Graph*>(this)->node_list_.at(source);index != static_cast<const Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<const Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<const Graph*>(this)->edge_list_.at(index).second;
        }
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        for (unsigned index = static_cast<const Graph*>(this)->node_list_.at(source);index != static_cast<const Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<const Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<const Graph*>(this)->edge_list_.at(index).second.size();
        }
        return 0;
    }
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, IsStorageTrait Storage,
          IsDirectionalityTrait Directionality,
          IsConnectivityTrait Connectivity>
class CompressedFormat
    : public CompressedFormatStoragePolicy<Graph, Edge, Storage, N>,
      public CompressedFormatDirectionalityPolicy<Graph, Edge, Directionality>,
      public CompressedFormatConnectivityPolicy<Graph, Edge, Connectivity>,
      public IteratorPolicy<Graph, Node, Edge> {
    using StoragePolicy = CompressedFormatStoragePolicy<Graph, Edge, Storage, N>;
    using DirectionalityPolicy =
        CompressedFormatDirectionalityPolicy<Graph, Edge, Directionality>;
    using ConnectivityPolicy =
        CompressedFormatConnectivityPolicy<Graph, Edge, Connectivity>;
    friend StoragePolicy;
    friend DirectionalityPolicy;
    friend ConnectivityPolicy;

  public:
    using StoragePolicy::initialize_node_list;
    using CompressedFormatNodeContainer = typename StoragePolicy::NodeContainer;
    using CompressedFormatEdgeContainer =
        std::vector<std::pair<NodeIdx, typename Connectivity::template InnerContainer<Edge>>>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;

    explicit CompressedFormat() : number_of_edges_(0) {
        initialize_node_list();
    }
    explicit CompressedFormat(Size n) : number_of_edges_(0) {
        initialize_node_list(n);
    }

    const Size& number_of_edges() const { return number_of_edges_; }
    template<typename... Args>
    Size number_of_edges (NodeIdx first, Args... nodes) {
        return static_cast<Graph*>(this)->num_of_edges_({first, nodes...});
    }
    CompressedFormatEdgeContainer& edge_list() { return edge_list_; }
    const CompressedFormatEdgeContainer& edge_list() const { return edge_list_; }
    CompressedFormatNodeContainer& node_list() { return node_list_; }
    const CompressedFormatNodeContainer& node_list() const { return node_list_; }

    String representation_to_string(const String col_delim = " | ",
                                    const String iter_delim = "\n") {
        std::stringstream ss;

        Size col_width = 0;
        for (unsigned i = 0; i < node_list_.size(); i++) {
            col_width = std::max(col_width, display(i).size());
        }
        for (unsigned i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            ss << std::setw(col_width) << std::left << display(i);
            for (unsigned j = node_list_.at(i); j < node_list_.at(i+1); j++) {
                ss << col_delim;
                ss << std::setw(col_width) << std::left << display(edge_list_.at(j).first);
                ss << " ";
                ss << display(edge_list_.at(j).second);
            }
            ss << iter_delim;
        }
        return ss.str().substr(0, ss.str().size() - iter_delim.size());
    }

    template<IsIteratorTrait T>
    struct Iterator {};

    template<>
    struct Iterator<Neighbour> : public IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename CompressedFormatEdgeContainer::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename CompressedFormatEdgeContainer::iterator, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx node;

        Iterator<Neighbour>(Graph *g, NodeIdx node, CompressedFormatEdgeContainer::iterator it) : SuperIterator{g, it}, node{node} {}

        const Node &operator *() const {
            return g->node(it->first);
        }

        Iterator<Neighbour> &operator++() {
            ++it;
            return *this;
        }

        Bool operator==(const Iterator<Neighbour> &other) {
            return g == other.g && it == other.it && node == other.node;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first);
        }
    };

    template<>
    struct Iterator<Adjacent> : public IteratorPolicy::template SuperIterator<Iterator<Adjacent>, NodeIdx, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Adjacent>, NodeIdx, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx node;
        NodeIdx source;

        const Node &operator *() const {
            return g->node(node == source ? g->edge_list()[it].first : source);
        }

        Iterator<Adjacent> &operator++() {
            while (it < g->edge_list().size()) {
                if (source+1 < g->node_list_.size() && it < g->node_list()[source + 1]) {
                    ++it;
                    if (it == g->edge_list().size()) return *this;
                    while (g->node_list_[source+1] == it) source++;
                    if (node == source || node == g->edge_list_[it].first) return *this;
                }
            }
            return *this;
        }

        Bool operator==(const Iterator<Adjacent> &other) {
            return g == other.g && it == other.it && node == other.node;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, node == source ? g->edge_list()[it].first : source);
        }

        Iterator<Adjacent>(Graph *g, NodeIdx node) : 
            SuperIterator{g, 0}, 
            node{node}, 
            source{0} {
                if (it == g->edge_list_.size()) return;
                while (g->node_list_[source+1] == it) source++;
                if (node != source && node != g->edge_list()[it].first) {
                    ++(*this);
                }
            }
        Iterator<Adjacent>(Graph *g, NodeIdx node, NodeIdx it) : SuperIterator{g, it}, node{node}  {}
    };

    std::pair<Iterator<Neighbour>, Iterator<Neighbour>> get_neighbours(NodeIdx node) {
        return std::make_pair(
            Iterator<Neighbour>(static_cast<Graph*>(this), node, edge_list_.begin()+node_list_.at(node)),
            Iterator<Neighbour>(static_cast<Graph*>(this), node, edge_list_.begin()+node_list_.at(node+1))
        );
    }

    std::pair<Iterator<Adjacent>, Iterator<Adjacent>> get_adjacents(NodeIdx node) {
        return std::make_pair(
            Iterator<Adjacent>(static_cast<Graph*>(this), node),
            Iterator<Adjacent>(static_cast<Graph*>(this), node, edge_list().size())
        );
    }

    template<>
    struct Iterator<EdgeIterator> : public IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename CompressedFormatEdgeContainer::iterator, typename Connectivity::template InnerContainer<Edge>> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename CompressedFormatEdgeContainer::iterator, typename Connectivity::template InnerContainer<Edge>>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        CompressedFormatNodeContainer::iterator node_it;

        Iterator<EdgeIterator>(Graph *g, typename CompressedFormatEdgeContainer::iterator it, typename CompressedFormatNodeContainer::iterator node_it) : SuperIterator{g, it}, node_it{node_it} {
            while (this->node_it != this->g->node_list_.end() && this->node_it != (this->g->node_list_.end()-1) && this->it == g->edge_list_.begin() + *(this->node_it+1)) this->node_it++;
        }

        const typename Connectivity::template InnerContainer<Edge> &operator *() const {
            return it->second;
        }

        Iterator<EdgeIterator> &operator++() {
            ++it;
            while (node_it != (g->node_list_.end()-1) && it == g->edge_list_.begin() + *(node_it+1)) node_it++;
            return *this;
        }

        Bool operator==(const Iterator<Neighbour> &other) {
            return g == other.g && it == other.it;
        }

        typename IteratorPolicy::template Iterator<Basic> first () {
            return typename IteratorPolicy::template Iterator<Basic>(g, std::distance(g->node_list_.begin(), node_it) );
        }

        typename IteratorPolicy::template Iterator<Basic> second () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first);
        }

        const Edge &edge () const {
            return it->second;
        }
    };

    std::pair<Iterator<EdgeIterator>, Iterator<EdgeIterator>> get_edges() {
        return std::make_pair(
            Iterator<EdgeIterator>(static_cast<Graph*>(this), edge_list_.begin(), node_list_.begin()),
            Iterator<EdgeIterator>(static_cast<Graph*>(this), edge_list_.end(), node_list_.end())
        );
    }

  protected:
    Size number_of_edges_;
    CompressedFormatNodeContainer node_list_;
    CompressedFormatEdgeContainer edge_list_;
};

} // namespace Arachne

#endif // COMPRESSED_FORMAT_POLICY_HPP
</file>

<file path="constants.hpp">
#ifndef CONSTANTS_HPP
#define CONSTANTS_HPP

#include "Types.hpp"

namespace Arachne {

constexpr inline Bool DIRECTED = true;
constexpr inline Bool UNDIRECTED = false;
constexpr inline Uint32 NODE_COLW = 10;
constexpr inline Size DEFAULT_CONTAINER_SIZE = 1;
constexpr inline Size DEFAULT_MATRIX_SIZE = 1;

} // namespace Arachne

#endif // CONSTANTS_HPP
</file>

<file path="display.hpp">
#ifndef DISPLAY_HPP
#define DISPLAY_HPP

#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <sstream>
#include <string>
#include <type_traits>

#include "Types.hpp"

namespace Arachne {

/* CONCEPTS */
template <typename T>
concept IsDereferenceable = requires(T a) {
    {*a};
};

template <typename T>
concept IsDisplayable = requires(T a) {
    {display(a)};
};

template <typename T>
concept IsNone = std::same_as<T, None>;

template <typename T>
concept HasForwardIterator = std::forward_iterator<typename T::iterator>;

template <typename T>
concept HasBidirectionalIterator =
    std::bidirectional_iterator<typename T::iterator>;

template <typename T>
concept HasToStringMethod = requires(T x) {
    { x.to_string() } -> std::convertible_to<String>;
};

template <typename T>
concept HasRandomAccessIterator =
    std::random_access_iterator<typename T::iterator>;

template <typename T>
concept IsAtleastForwardIterable =
    HasForwardIterator<T> || HasBidirectionalIterator<T> ||
    HasRandomAccessIterator<T>;

template <typename T>
concept IsNotAtleastForwardIterable = !IsAtleastForwardIterable<T>;

template <typename T>
concept IsPair = requires(T x) {
    typename T::first_type;
    typename T::second_type;
    x.first;
    x.second;
    { x.first } -> std::same_as<typename T::first_type&>;
    { x.second } -> std::same_as<typename T::second_type&>;
};

template <typename T>
concept IsEdgeIdx = std::same_as<typename T::first_type, NodeIdx> &&
                    std::same_as<typename T::second_type, NodeIdx>;

template <typename T>
concept IsContainerOfPairs =
    IsAtleastForwardIterable<T> && IsPair<typename T::value_type>;

template <typename T>
concept IsNotContainerOfPairs = not IsContainerOfPairs<T>;

template <typename T>
concept IsFundamental = std::is_fundamental_v<T>;

/* DISPLAY OVERLOADS */
template <typename T>
requires IsNone<T> inline String display(const T...) {
    return "None";
}

template <typename T>
requires IsFundamental<T> inline String display(const T x,
                                                const String left_delim = "",
                                                const String right_delim = "") {
    return left_delim + std::to_string(x) + right_delim;
}

template <typename T>
requires IsDereferenceable<T> inline String
display(const T x, const String left_delim = "",
        const String right_delim = "") {
    return left_delim + std::to_string(*x) + right_delim;
}

template <typename T>
requires HasToStringMethod<T> inline String
display(const T x, const String left_delim = "",
        const String right_delim = "") {
    return left_delim + x.to_string() + right_delim;
}

template <typename T>
requires IsEdgeIdx<T> inline String display(const T x,
                                            const String left_delim = "(",
                                            const String right_delim = ")") {
    return left_delim + std::to_string(x.first) + "," +
           std::to_string(x.second) + right_delim;
}

template <typename T>
requires IsAtleastForwardIterable<T> inline String
display(T& forward_iterable_container, const String iter_delim = "\n") {
    std::stringstream ss;
    for (auto iter : forward_iterable_container) {
        ss << display(iter) << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

template <typename T>
requires IsAtleastForwardIterable<T> inline String
display(const std::list<std::pair<NodeIdx, T>>& container,
        const String col_delim = " : ", const String iter_delim = ", ",
        const String left_delim = "[", const String right_delim = "]") {

    std::stringstream ss;
    for (auto iter : container) {
        ss << display(iter.first, left_delim, right_delim);
        ss << col_delim;
        ss << display(iter.second, iter_delim);
        ss << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

template <typename T>
requires IsAtleastForwardIterable<T> inline String
display(const std::map<NodeIdx, T>& container, const String col_delim = " : ",
        const String iter_delim = ", ", const String left_delim = "[",
        const String right_delim = "]") {

    std::stringstream ss;
    for (auto iter : container) {
        ss << display(iter.first, left_delim, right_delim);
        ss << col_delim;
        ss << display(iter.second, iter_delim);
        ss << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

template <typename T>
requires IsNotAtleastForwardIterable<T> inline String
display(const std::list<std::pair<NodeIdx, T>>& container,
        const String col_delim = " : ", const String iter_delim = ", ",
        const String left_delim = "[", const String right_delim = "]") {

    std::stringstream ss;
    for (auto iter : container) {
        ss << display(iter.first, left_delim, right_delim);
        ss << col_delim;
        ss << display(iter.second);
        ss << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

template <typename T>
requires IsNotAtleastForwardIterable<T> inline String
display(const std::map<NodeIdx, T>& container, const String col_delim = " : ",
        const String iter_delim = ", ", const String left_delim = "[",
        const String right_delim = "]") {

    std::stringstream ss;
    for (auto iter : container) {
        ss << display(iter.first, left_delim, right_delim);
        ss << col_delim;
        ss << display(iter.second);
        ss << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

} // namespace Arachne

#endif // DISPLAY_HPP
</file>

<file path="EdgeData.hpp">
#ifndef ARACHNE_EDGE_DATA_HPP
#define ARACHNE_EDGE_DATA_HPP

#include <sstream>

#include "ArachneData.hpp"
#include "Types.hpp"
#include "display.hpp"

namespace Arachne {

template <typename... Data>
struct EdgeData;

template <IsNotArachneData NotArachneData, typename... OtherData>
struct EdgeData<NotArachneData, OtherData...> {
    static_assert(
        false, "EdgeData cannot hold more than one non-arachne data type.\n");
};

// this partially orders the input types so that the user data is first. It
// makes things easier.
template <IsArachneData ArachneData, typename... OtherData>
struct EdgeData<ArachneData, OtherData...> {
    static_assert(false, "In EdgeData template arguments, user specified data "
                         "(if any) must come first.\n");
};

// Thanks to the above template specialization, all the ArachneData has been
// captured in the parameter pack.
template <IsNotArachneData UserData, IsArachneData... ArachneData>
struct EdgeData<UserData, ArachneData...> : public ArachneData... {
    static constexpr bool is_edge_data = true;
    UserData data;

    explicit EdgeData() {}

    explicit EdgeData(UserData user_data, ArachneData::Data... arachne_data): data{user_data} {
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << "User Data: " << data << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <IsArachneData First, IsArachneData... ArachneData>
struct EdgeData<First, ArachneData...> : public First, public ArachneData... {
    static constexpr bool is_edge_data = true;
    explicit EdgeData() {}
    explicit EdgeData(First::Data first, ArachneData::Data... arachne_data) {
        First::set_value(first, this);
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << First::to_string(this) << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <IsArachneData... ArachneData>
struct EdgeData<None, ArachneData...> : public ArachneData... {
    using UserData = None;
    explicit EdgeData() {}

    explicit EdgeData(ArachneData::Data... arachne_data) {
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << "User Data: None" << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <>
struct EdgeData<None> {
    static constexpr bool is_edge_data = true;
    using UserData = None;
    UserData data;

    String to_string(...) const { return display(data); }
};

template <>
struct EdgeData<> {
    static constexpr bool is_edge_data = true;
    using UserData = None;
    UserData data;

    String to_string(...) const { return display(data); }
};

template <typename T>
concept IsEdgeData = T::is_edge_data;

template <typename T>
concept IsNotEdgeData = not IsEdgeData<T>;
} // namespace Arachne

#endif // ARACHNE_EDGE_DATA_HPP
</file>

<file path="EdgeListPolicy.hpp">
#ifndef EDGE_LIST_POLICY_HPP
#define EDGE_LIST_POLICY_HPP

#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <sstream>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "graph_utilities.hpp"

namespace Arachne {

template <typename Graph, typename Edge, IsStorageTrait Storage>
struct EdgeListStoragePolicy {};

template <typename Graph, typename Edge>
struct EdgeListStoragePolicy<Graph, Edge, Dynamic> {
    void add_node_to_representation_() {}
    void remove_node_from_representation_(const NodeIdx a) {
        Size removed_edges = static_cast<Graph*>(this)->degree(a);
        std::erase_if(static_cast<Graph*>(this)->edge_list_, [&] (const auto & c) {
            return a == c.first.first || a == c.first.second;});

        for (auto & edge: static_cast<Graph*>(this)->edge_list_) {
            if (edge.first.first > a || edge.first.second > a) {
                auto edge_to_move =
                    static_cast<Graph*>(this)->edge_list_.extract(edge.first);
                if (edge_to_move.key().first > a) edge_to_move.key().first -= 1;
                if (edge_to_move.key().second > a) edge_to_move.key().second -= 1;
                static_cast<Graph*>(this)->edge_list_.insert(std::move(edge_to_move));
            }
        }
        static_cast<Graph*>(this)->number_of_edges_ -= removed_edges;
    }
};

template <typename Graph, typename Edge, IsDirectionalityTrait Directionality>
struct EdgeListDirectionalityPolicy {};

template <typename Graph, typename Edge>
struct EdgeListDirectionalityPolicy<Graph, Edge, Undirected> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        EdgeIdx ordered = order_edge_idx(std::make_pair(source, dest));
        Bool success = static_cast<Graph*>(this)->add_edge_to_inner_container_(ordered, edge);
        static_cast<Graph*>(this)->number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        EdgeIdx ordered = order_edge_idx(std::make_pair(source, dest));
        Bool success = static_cast<Graph*>(this)->remove_edge_from_inner_container(ordered, edge);
        static_cast<Graph*>(this)->number_of_edges_ -= success;
    }

    Size degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

protected:
    static Bool contains_neighbour_(NodeIdx node, EdgeIdx edge) {
        return node == edge.first || node == edge.second;
    }

    EdgeIdx order_edge_ (const EdgeIdx& idx) {
        return order_edge_idx(idx);
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return it > it2 ? 0 : static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge>
struct EdgeListDirectionalityPolicy<Graph, Edge, Directed> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->add_edge_to_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph&>(*this).number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->remove_edge_from_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph&>(*this).number_of_edges_ -= success;
    }

    Size out_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

    Size in_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(i, n);
        }
        return deg;
    }

    Size degree(NodeIdx n) {
        return in_degree(n)+ out_degree(n)-static_cast<Graph*>(this)->count(n, n);
    }

protected:
    static Bool contains_neighbour_(NodeIdx node, EdgeIdx edge) {
        return node == edge.first;
    }

    EdgeIdx order_edge_ (const EdgeIdx& idx) {
        return idx;
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge, IsConnectivityTrait Connectivity>
struct EdgeListConnectivityPolicy {};

template <typename Graph, typename Edge>
struct EdgeListConnectivityPolicy<Graph, Edge, Simple> {

  protected:
    Bool add_edge_to_inner_container_(const EdgeIdx& idx, Edge& edge) {
        Bool ret = !static_cast<Graph*>(this)->edge_list_.contains(idx);
        static_cast<Graph*>(this)->edge_list_[idx] = edge;
        return ret;
    }
    Bool remove_edge_from_inner_container_(const EdgeIdx& idx, ...) {
        Bool ret = static_cast<Graph*>(this)->edge_list_.contains(idx);
        static_cast<Graph*>(this)->edge_list_.erase(idx);
        return ret;
    }

  public:
    Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<Graph*>(this)->edge_list_.at(ordered);
    }
    const Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) const {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<const Graph*>(this)->edge_list_.at(ordered);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<const Graph*>(this)->edge_list_.contains(ordered);
    }
};

template <typename Graph, typename Edge>
struct EdgeListConnectivityPolicy<Graph, Edge, Multi> {
  protected:
    Bool add_edge_to_inner_container_(const EdgeIdx& idx, Edge edge = Edge()) {
        static_cast<Graph*>(this)->edge_list_[idx].push_back(edge);
        return true;
    }
    Bool remove_edge_from_inner_container_(const EdgeIdx& idx,
                                           Edge edge = Edge()) {
        for (auto const& iter : static_cast<Graph*>(this)->edge_list_.at(idx)) {
            if ((*iter) == edge) {
                static_cast<Graph*>(this)->edge_list_.at(idx).erase(iter);
                return true;
            }
        }
        return false;
    }
  public:
    Edge& get_edges(const NodeIdx& source, const NodeIdx& dest) {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<Graph*>(this)->edge_list_.at(ordered);
    }
    const Edge& get_edges(const NodeIdx& source, const NodeIdx& dest) const {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<const Graph*>(this)->edge_list_.at(ordered);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<Graph*>(this)->edge_list_.contains(ordered) ? static_cast<Graph*>(this)->edge_list_.at(ordered).size() : 0;
    }
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, IsStorageTrait Storage,
          IsDirectionalityTrait Directionality,
          IsConnectivityTrait Connectivity>
class EdgeList
    : public EdgeListStoragePolicy<Graph, Edge, Storage>,
      public EdgeListDirectionalityPolicy<Graph, Edge, Directionality>,
      public EdgeListConnectivityPolicy<Graph, Edge, Connectivity>,
      public IteratorPolicy<Graph, Node, Edge> {
    using StoragePolicy = EdgeListStoragePolicy<Graph, Edge, Storage>;
    using DirectionalityPolicy =
        EdgeListDirectionalityPolicy<Graph, Edge, Directionality>;
    using ConnectivityPolicy =
        EdgeListConnectivityPolicy<Graph, Edge, Connectivity>;
    friend StoragePolicy;
    friend DirectionalityPolicy;
    friend ConnectivityPolicy;

  public:
    using EdgeListContainer =
        std::map<EdgeIdx, typename Connectivity::template InnerContainer<Edge>>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;

    explicit EdgeList(Size _ = 0) : number_of_edges_(0) {}

    const Size& number_of_edges() const { return number_of_edges_; }
    template<typename... Args>
    Size number_of_edges (NodeIdx first, Args... nodes) {
        return static_cast<Graph*>(this)->num_of_edges_({first, nodes...});
    }
    EdgeListContainer& edge_list() { return edge_list_; }
    const EdgeListContainer& edge_list() const { return edge_list_; }

    String representation_to_string(const String col_delim = " | ",
                                    const String iter_delim = "\n") {
        std::stringstream ss;

        Size col_width = 0;
        for (auto iter : edge_list_) {
            col_width = std::max(col_width, display(iter.first).size());
        }
        for (auto iter : edge_list_) {
            ss << std::setw(col_width) << std::left << display(iter.first);
            ss << col_delim;
            ss << display(iter.second);
            ss << iter_delim;
        }
        return ss.str().substr(0, ss.str().size() - iter_delim.size());
    }

    template<IsIteratorTrait T>
    struct Iterator {};

    template<>
    struct Iterator<Neighbour> : public IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename EdgeListContainer::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename EdgeListContainer::iterator, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx node;
        
        Iterator<Neighbour>(Graph *g, NodeIdx node, EdgeListContainer::iterator it) : SuperIterator{g, it}, node{node} {
            while (this->it != g->edge_list().end() && !EdgeList::contains_neighbour_(node, this->it->first)) { this->it++; }
        }
        
        const Node &operator *() const {
            return g->node(it->first.first == node ? it->first.second : it->first.first);
        }
        
        Iterator<Neighbour> &operator++() {
            while (++it != g->edge_list().end() && !EdgeList::contains_neighbour_(node, it->first));
            return *this;
        }

        Bool operator==(const Iterator<Neighbour> &other) {
            return g == other.g && it == other.it && node == other.node;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first.first == node ? it->first.second : it->first.first);
        }
    };

    template<>
    struct Iterator<Adjacent> : public IteratorPolicy::template SuperIterator<Iterator<Adjacent>, typename EdgeListContainer::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Adjacent>, typename EdgeListContainer::iterator, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx node;
        
        Iterator<Adjacent>(Graph *g, NodeIdx node, EdgeListContainer::iterator it) : SuperIterator{g, it}, node{node} {
            while (this->it != g->edge_list().end() && node != this->it->first.first && node != this->it->first.second) { this->it++; }
        }
        
        const Node &operator *() const {
            return g->node(it->first.first == node ? it->first.second : it->first.first);
        }
        
        Iterator<Adjacent> &operator++() {
            while (++it != g->edge_list().end() && node != it->first.first && node != it->first.second);
            return *this;
        }

        Bool operator==(const Iterator<Adjacent> &other) {
            return g == other.g && it == other.it && node == other.node;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first.first == node ? it->first.second : it->first.first);
        }
    };


    std::pair<Iterator<Neighbour>, Iterator<Neighbour>> get_neighbours(NodeIdx node) {
        return std::make_pair(
            Iterator<Neighbour>(static_cast<Graph*>(this), node, edge_list_.begin()), 
            Iterator<Neighbour>(static_cast<Graph*>(this), node, edge_list_.end())
        );
    }

    std::pair<Iterator<Adjacent>, Iterator<Adjacent>> get_adjacents(NodeIdx node) {
        return std::make_pair(
            Iterator<Adjacent>(static_cast<Graph*>(this), node, edge_list_.begin()), 
            Iterator<Adjacent>(static_cast<Graph*>(this), node, edge_list_.end())
        );
    }

    template<>
    struct Iterator<EdgeIterator> : public IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename EdgeListContainer::iterator, typename Connectivity::template InnerContainer<Edge>> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename EdgeListContainer::iterator, typename Connectivity::template InnerContainer<Edge>>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        Iterator<EdgeIterator>(Graph *g, typename EdgeListContainer::iterator it) : SuperIterator{g, it} {}
        
        const typename Connectivity::template InnerContainer<Edge> &operator *() const {
            return it->second;
        }
        
        Iterator<EdgeIterator> &operator++() {
            ++it;
            return *this;
        }

        typename IteratorPolicy::template Iterator<Basic> first () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first.first);
        }

        typename IteratorPolicy::template Iterator<Basic> second () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first.second);
        }

        const Edge &edge () const {
            return it->second;
        }
    };

    std::pair<Iterator<EdgeIterator>, Iterator<EdgeIterator>> get_edges() {
        return std::make_pair(
            Iterator<EdgeIterator>(static_cast<Graph*>(this), edge_list_.begin()), 
            Iterator<EdgeIterator>(static_cast<Graph*>(this), edge_list_.end())
        );
    }

  protected:
    Size number_of_edges_;
    EdgeListContainer edge_list_;
};

} // namespace Arachne

#endif // EDGE_LIST_POLICY_HPP
</file>

<file path="EdgeStoragePolicy.hpp">
#ifndef EDGE_STORAGE_POLICY_HPP
#define EDGE_STORAGE_POLICY_HPP

namespace Arachne {} // namespace Arachne

#endif // EDGE_STORAGE_POLICY_HPP
</file>

<file path="graph_factories.hpp">
#ifndef ARACHNE_GRAPH_FACTORIES_HPP
#define ARACHNE_GRAPH_FACTORIES_HPP

#include "Graph.hpp"
#include "Traits.hpp"
#include "Types.hpp"

namespace Arachne {} // namespace Arachne

#endif // ARACHNE_GRAPH_FACTORIES_HPP
</file>

<file path="graph_utilities.hpp">
#ifndef GRAPH_UTILITIES_HPP
#define GRAPH_UTILITIES_HPP

#include "Types.hpp"
#include "real.hpp"

namespace Arachne {

// Reverses order of edge index (a,b) -> (b,a)
inline EdgeIdx reverse_edge_idx(const EdgeIdx& idx) {
    return std::make_pair(idx.second, idx.first);
}

// Returns the given edge index in order of smallest to largest,
// (a,b) -> (min(a,b),max(a,b))
inline EdgeIdx order_edge_idx(const EdgeIdx& idx) {
    if (idx.first > idx.second) {
        return reverse_edge_idx(idx);
    }
    return idx;
}

template <typename Container, typename T>
inline typename Container::const_iterator find(const Container& container,
                                               const T& value) {
    for (auto it = container.begin(); it != container.end(); it++) {
        if ((*it) == value) {
            return it;
        }
    }
    return container.cend();
}

template <typename Container>
inline typename Container::const_iterator find(const Container& container,
                                               const Real value) {
    for (auto it = container.begin(); it != container.end(); it++) {
        if (real_eq((*it), value)) {
            return it;
        }
    }
    return container.cend();
}

}; // namespace Arachne

#endif // GRAPH_UTILITIES_HPP
</file>

<file path="Graph.hpp">
#ifndef ARACHNE_GRAPH_HPP
#define ARACHNE_GRAPH_HPP

#include <optional>
#include <queue>

#include "EdgeListPolicy.hpp"
#include "AdjacencyListPolicy.hpp"
#include "AdjacencyMatrixPolicy.hpp"
#include "CompressedFormatPolicy.hpp"
#include "NodeStoragePolicy.hpp"
#include "Parameters.hpp"
#include "Traits.hpp"
#include "Types.hpp"

#define ITER_PARAM_LIST IteratorParameters<P...>

namespace Arachne {

template <Size N, IsParameters ParameterList = Parameters<>,
          template <Size, typename...> typename RepresentationPolicy = EdgeList>
class Graph
    : public RepresentationPolicy<
          N, Graph<N, ParameterList, RepresentationPolicy>,
          typename ParameterList::NodeData,
          typename ParameterList::EdgeData,
          typename ParameterList::Storage,
          typename ParameterList::Directionality,
          typename ParameterList::Connectivity>,
      public NodePolicy<N, Graph<N, ParameterList, RepresentationPolicy>,
                        typename ParameterList::NodeData,
                        typename ParameterList::EdgeData,
                        typename ParameterList::Storage> {
    using Rep = RepresentationPolicy<
            N, Graph<N, ParameterList, RepresentationPolicy>,
            typename ParameterList::NodeData,
            typename ParameterList::EdgeData,
            typename ParameterList::Storage,
            typename ParameterList::Directionality,
            typename ParameterList::Connectivity>;
    using NodePol = NodePolicy<N, Graph<N, ParameterList, RepresentationPolicy>,
                        typename ParameterList::NodeData,
                        typename ParameterList::EdgeData,
                        typename ParameterList::Storage>;
    friend Rep;
    friend NodePol;
    friend IteratorPolicy<Graph, typename ParameterList::NodeData, typename ParameterList::EdgeData>;

  public:
    using IteratorPolicy = IteratorPolicy<Graph, typename ParameterList::NodeData, typename ParameterList::EdgeData>;
    using NodePol::initialize_node_container;
    using typename NodePol::NodeContainer;
    using NodePol::begin;
    using NodePol::end;
    
    explicit Graph() { initialize_node_container(); }
    explicit Graph(Size n) : Rep{n} {
        initialize_node_container(n);
    }
    explicit Graph(NodePol::NodeContainer& node_container) {
        initialize_node_container(node_container);
    }

    std::pair<typename Rep::template Iterator<Neighbour>, typename Rep::template Iterator<Neighbour>> get_neighbours(const NodePol::template Iterator<Basic> &it) {
        return Rep::get_neighbours(NodePol::nodeId(it));
    }

    template <typename Iterator, IsIteratorParameters ItParamList>
    struct BasicSearchIterator : public IteratorPolicy::template SuperIterator<Iterator, typename NodePol::template Iterator<Basic>, typename ParameterList::NodeData> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using NeighbourIterator = Rep::template Iterator<Neighbour>;
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator, typename NodePol::template Iterator<Basic>, typename ParameterList::NodeData>;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator->;

        using ListElement = std::pair<BasicIterator, std::optional<std::pair<NeighbourIterator, NeighbourIterator>>>;

        std::list<ListElement> frontier;
        typename ItParamList::SetType &visited;
        const Bool is_ext;

        inline BasicSearchIterator(BasicIterator node) : SuperIterator{node.g, IsCompleteTraversal<typename ItParamList::TraversalTrait> ? node.g->NodePol::template begin<Basic>() : node.g->NodePol::template end<Basic>()}, visited{*(new ItParamList::SetType(node.g->number_of_nodes()))}, is_ext{false} {
            // must be initialized to already have visited root node, for dereference
            visited.insert(node);
            frontier.push_front(ListElement(node, std::nullopt));
        }

        BasicSearchIterator(BasicIterator node, typename ItParamList::SetType &S) : SuperIterator{node.g, IsCompleteTraversal<typename ItParamList::TraversalTrait> ? node.g->NodePol::template begin<Basic>() : node.g->NodePol::template end<Basic>()}, visited{S}, is_ext{true} {
            // skip to next unvisited node in graph
            if (visited.insert(node).second) {
                frontier.push_front(ListElement(node, std::nullopt));
                return;
            }
            while (it != g->template end<Basic>()) {
                BasicIterator next = it++;
                if (visited.insert(next).second) {
                    frontier.push_front(ListElement(next, std::nullopt));
                    return;
                }
            }
        }

        inline BasicSearchIterator() : SuperIterator{nullptr, BasicIterator(nullptr, 0)}, visited{*(new ItParamList::SetType())}, is_ext{false} {}

        BasicSearchIterator(typename ItParamList::SetType &S) : SuperIterator{nullptr, BasicIterator(nullptr, 0)}, visited{S}, is_ext{true} {}

        BasicSearchIterator(const BasicSearchIterator<Iterator, ItParamList> &other) : SuperIterator{other.g, other.it}, visited{other.is_ext? other.visited : *(new ItParamList::SetType(other.visited))}, is_ext{other.is_ext} {}

        void clear_frontier() {
            frontier.clear();
        }

        virtual void pop() = 0;

        virtual Bool is_postorder() = 0;

        Iterator &operator++() {
            if (is_postorder()) pop();
            while (true) {
                // skip to next component if component is fully explored
                if (frontier.empty()) {
                    while (it != g->NodePol::template end<Basic>()) {
                        BasicIterator next = std::same_as<typename ItParamList::PruningTrait, MultiplePathPruning> ? it++ : it;
                        if (visited.insert(next).second || std::same_as<typename ItParamList::PruningTrait, NoPathPruning>) {
                            frontier.push_front(ListElement(next, std::nullopt));
                            if (!is_postorder()) return *static_cast<Iterator*>(this);
                            else break;
                        }
                    }
                    if (it == g->NodePol::template end<Basic>()) return *static_cast<Iterator*>(this);
                }

                const BasicIterator &current = frontier.back().first;
                auto &current_posn = frontier.back().second;


                if (!current_posn) {
                    current_posn.emplace(g->get_neighbours(current));
                } else if (current_posn->first != current_posn->second) {
                    current_posn->first++;
                } 
                if (current_posn->first == current_posn->second) {
                    if (is_postorder()) return *static_cast<Iterator*>(this);
                    pop();
                    continue;
                }

                if (visited.insert((BasicIterator)(current_posn->first)).second || std::same_as<typename ItParamList::PruningTrait, NoPathPruning>) {
                    frontier.push_front(ListElement(current_posn->first, std::nullopt));
                    if (!is_postorder()) return *static_cast<Iterator*>(this);
                }
            }
        }

        Bool operator==(const Iterator &x) const {
            return frontier == x.frontier;
        }

        const ParameterList::NodeData & operator*() const { return *(frontier.front().first); }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(frontier.front().first);
        }

        ~BasicSearchIterator() {
            if(!is_ext) delete &visited;
        }
    };

    template <typename Iterator, IsIteratorParameters ItParamList>
    struct OrderedSearchIterator: public IteratorPolicy::template SuperIterator<Iterator, std::pair<typename NodePol::template Iterator<Basic>, double>, typename ParameterList::NodeData> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using NeighbourIterator = Rep::template Iterator<Neighbour>;
        using QueueElement = std::pair<BasicIterator, double>;
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator, QueueElement, typename ParameterList::NodeData>;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator->;

        std::function<Real(const BasicIterator &, const BasicIterator &)> edge_weights;
        std::priority_queue<QueueElement,
                            std::vector<QueueElement>,
                            std::function<Bool(const QueueElement &, const QueueElement &)>>
                            frontier;
        typename ItParamList::SetType &visited;
        const Bool is_ext;

        OrderedSearchIterator(const BasicIterator start, std::function<Real(const BasicIterator &, Real)> &&heuristic, std::function<Real(const BasicIterator &, const BasicIterator &)> &&edge_weights):
            SuperIterator{start.g, std::make_pair(start, 0)},
            edge_weights{std::move(edge_weights)},
            frontier{[heuristic](const QueueElement &a, const QueueElement &b) { return heuristic(a.first, a.second) > heuristic(b.first, b.second); }},
            visited{*(new ItParamList::SetType(start.g->number_of_nodes()))},
            is_ext{false} {
            visited.insert(it.first);
            expand();
        }

        OrderedSearchIterator(const BasicIterator start, typename ItParamList::SetType &S, std::function<Real(const BasicIterator &, Real)> &&heuristic, std::function<Real(const BasicIterator &, const BasicIterator &)> &&edge_weights):
            SuperIterator{start.g, std::make_pair(start, 0)},
            edge_weights{std::move(edge_weights)},
            frontier{[heuristic](const QueueElement &a, const QueueElement &b) { return heuristic(a.first, a.second) > heuristic(b.first, b.second); }},
            visited{*(new ItParamList::SetType(start.g->number_of_nodes()))},
            is_ext{false} {
            if (std::same_as<typename ItParamList::PruningTrait, NoPathPruning> || visited.insert(it.first).second) expand();
        }

        inline OrderedSearchIterator(const BasicIterator end) : SuperIterator{end.g, std::make_pair(end, 0)}, visited{*(new ItParamList::SetType())}, is_ext{false} {}

        OrderedSearchIterator(const BasicIterator end, typename ItParamList::SetType &S) : SuperIterator{end.g, std::make_pair(end, 0)}, visited{S}, is_ext{true} {}

         OrderedSearchIterator (const OrderedSearchIterator &other) : SuperIterator{other.g, other.it}, edge_weights{other.edge_weights},
                            visited{other.is_ext? other.visited : *(new ItParamList::SetType(other.visited))}, is_ext{other.is_ext}, frontier{other.frontier} {}

        void expand() {
            auto neighbours = g->get_neighbours(it.first);
            for (; neighbours.first != neighbours.second; (neighbours.first)++) {
                frontier.push(std::make_pair(neighbours.first, it.second + edge_weights(it.first, neighbours.first)));
            }
        }

        ~OrderedSearchIterator() {
            if(!is_ext) delete &visited;
        }

        Bool operator==(const Iterator &x) const {
            return it.first == x.it.first;
        }

        const ParameterList::NodeData & operator*() const { return *(it.first); }

        Iterator& operator++() {
            do {
                if (frontier.empty()) {
                    it.first = g->template end<Basic>();
                    return *static_cast<Iterator*>(this);
                }
                it = frontier.top();
                frontier.pop();
            } while (std::same_as<typename ItParamList::PruningTrait, MultiplePathPruning> && !visited.insert(it.first).second);

            expand();
            return *static_cast<Iterator*>(this);
        }

        operator BasicIterator() const {
            return it.first;
        }
    };

    template<IsIteratorTrait T, IsIteratorParameter... P>
    struct Iterator {};

    template <IsIteratorParameter... P>
    struct Iterator<PreOrder, P...> : public BasicSearchIterator<Iterator<PreOrder, P...>, ITER_PARAM_LIST> {
        using BasicSearchIterator<Iterator<PreOrder, P...>, ITER_PARAM_LIST>::BasicSearchIterator;

        void pop() {
            this->frontier.pop_front();
        }

        Bool is_postorder() {
            return false;
        }
    };

    template <IsIteratorParameter... P>
    struct Iterator<PostOrder, P...> : public BasicSearchIterator<Iterator<PostOrder, P...>, ITER_PARAM_LIST> {
        using BasicSearchIterator = BasicSearchIterator<Iterator<PostOrder, P...>, ITER_PARAM_LIST>;
        using BasicIterator = NodePol::template Iterator<Basic>;

        inline Iterator(BasicIterator node) : BasicSearchIterator{node} {
            // must point to proper node for dereference
            // if given end, does nothing
            this->frontier.push_front(this->frontier.front());
            ++*this;
        }

        inline Iterator(BasicIterator node, ITER_PARAM_LIST::SetType &S) : BasicSearchIterator{node, S} {
            this->frontier.push_front(this->frontier.front());
            ++*this;
        }

        inline Iterator() : BasicSearchIterator{} {}

        inline Iterator(ITER_PARAM_LIST::SetType &S) : BasicSearchIterator{S} {}

        void pop() {
            this->frontier.pop_front();
        }

        Bool is_postorder() {
            return true;
        }

    };

    template <IsIteratorParameter... P>
    struct Iterator<InOrder, P...> : public BasicSearchIterator<Iterator<InOrder, P...>, ITER_PARAM_LIST> {
        using BasicSearchIterator<Iterator<InOrder, P...>, ITER_PARAM_LIST>::BasicSearchIterator;

        void pop() {
            this->frontier.pop_back();
        }

        Bool is_postorder() {
            return false;
        }
    };

    template <IsIteratorParameter... P>
    struct Iterator<BestFirst, P...>: public OrderedSearchIterator<Iterator<BestFirst, P...>, ITER_PARAM_LIST> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using OrderedSearchIterator = OrderedSearchIterator<Iterator<BestFirst, P...>, ITER_PARAM_LIST>;

        Iterator<BestFirst, P...>(const BasicIterator start, std::function<Real(const BasicIterator &)> heuristic):
            OrderedSearchIterator{start, [heuristic](const BasicIterator &it, Real cost){ return heuristic(it); }, [](const BasicIterator &a, const BasicIterator &b){ return 0; }} {}

        Iterator<BestFirst, P...>(const BasicIterator end): OrderedSearchIterator{end} {}
    };

    template <IsIteratorParameter... P>
    struct Iterator<AStar, P...>: public OrderedSearchIterator<Iterator<AStar, P...>, ITER_PARAM_LIST> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using OrderedSearchIterator = OrderedSearchIterator<Iterator<AStar, P...>, ITER_PARAM_LIST>;

        Iterator<AStar, P...>(const BasicIterator start, std::function<Real(const BasicIterator &)> heuristic, std::function<Real(const BasicIterator &, const BasicIterator &)> edge_weights):
            OrderedSearchIterator{start, [heuristic](const BasicIterator &it, Real cost){ return heuristic(it) + cost; }, [edge_weights](const BasicIterator &a, const BasicIterator &b) { return edge_weights(a, b); }} {}

        Iterator<AStar, P...>(const BasicIterator end): OrderedSearchIterator{end} {}
    };

    template <IsIteratorParameter... P>
    struct Iterator<Dijkstra, P...>: public OrderedSearchIterator<Iterator<Dijkstra, P...>, ITER_PARAM_LIST> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using OrderedSearchIterator = OrderedSearchIterator<Iterator<Dijkstra, P...>, ITER_PARAM_LIST>;

        Iterator<Dijkstra, P...>(const BasicIterator start, std::function<Real(const BasicIterator &, const BasicIterator &)> edge_weights):
            OrderedSearchIterator{start, [](const BasicIterator &it, Real cost){ return cost; }, [edge_weights](const BasicIterator &a, const BasicIterator &b) { return edge_weights(a, b); }} {}

        Iterator<Dijkstra, P...>(const BasicIterator end): OrderedSearchIterator{end} {}
    };

    template <IsSearchTrait Trait, IsIteratorParameter... P>
    inline Iterator<Trait, P...> begin(typename NodePol::template Iterator<Basic> it) {
        return Iterator<Trait, P...>(it);
    }

    template <IsSearchTrait Trait, IsIteratorParameter... P>
    inline Iterator<Trait, P...> begin() {
        return begin<Trait, P...>(this->begin<Basic>());
    }

    template <IsSearchTrait Trait, IsIteratorParameter... P>
    inline Iterator<Trait, P...> end() {
        return Iterator<Trait, P...>();
    }

    template <IsSearchTrait Trait, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<Trait, SetType, P...> begin(typename NodePol::template Iterator<Basic> it, SetType &S) {
        return Iterator<Trait, SetType, P...>(it, S);
    }

    template <IsSearchTrait Trait, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<Trait, SetType, P...> begin(SetType &S) {
        return begin<Trait, SetType, P...>(this->begin<Basic>(), S);
    }

    template <IsSearchTrait Trait, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<Trait, SetType, P...> end(SetType &S) {
        return Iterator<Trait, SetType, P...>(S);
    }

    template <IsBestFirst B, IsIteratorParameter... P>
    inline Iterator<B, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic) {
        return Iterator<B, P...>(it, heuristic);
    }

    template <IsBestFirst B, IsIteratorParameter... P>
    inline Iterator<B, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic) {
        return begin<B, P...>(this->begin<Basic>(), heuristic);
    }

    template <IsBestFirst B, IsIteratorParameter... P>
    inline Iterator<B, P...> end() {
        return Iterator<B, P...>(this->end<Basic>());
    }

    template <IsBestFirst B, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<B, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, SetType &S) {
        return Iterator<B, P...>(it, heuristic, S);
    }

    template <IsBestFirst B, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<B, SetType, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, SetType &S) {
        return begin<B, SetType, P...>(this->begin<Basic>(), heuristic, S);
    }

    template <IsBestFirst B, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<B, SetType, P...> end(SetType &S) {
        return Iterator<B, SetType, P...>(this->end<Basic>(), S);
    }

    template <IsAStar A, IsIteratorParameter... P>
    inline Iterator<A, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights) {
        return Iterator<A, P...>(it, heuristic, edge_weights);
    }

    template <IsAStar A, IsIteratorParameter... P>
    inline Iterator<A, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights) {
        return begin<A, P...>(this->begin<Basic>(), heuristic, edge_weights);
    }

    template <IsAStar A, IsIteratorParameter... P>
    inline Iterator<A, P...> end() {
        return Iterator<A, P...>(this->end<Basic>());
    }

    template <IsAStar A, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<A, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights, SetType &S) {
        return Iterator<A, P...>(it, heuristic, edge_weights, S);
    }

    template <IsAStar A, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<A, SetType, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights, SetType &S) {
        return begin<A, SetType, P...>(this->begin<Basic>(), heuristic, edge_weights, S);
    }

    template <IsAStar A, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<A, SetType, P...> end(SetType &S) {
        return Iterator<A, SetType, P...>(this->end<Basic>(), S);
    }

    template <IsDijkstra D, IsIteratorParameter... P>
    inline Iterator<D, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights) {
        return Iterator<D, P...>(it, edge_weights);
    }

    template <IsDijkstra D, IsIteratorParameter... P>
    inline Iterator<D, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights) {
        return begin<D, P...>(this->begin<Basic>(), edge_weights);
    }

    template <IsDijkstra D, IsIteratorParameter... P>
    inline Iterator<D, P...> end() {
        return Iterator<D, P...>(this->end<Basic>());
    }

    template <IsDijkstra D, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<D, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights, SetType &S) {
        return Iterator<D, P...>(it, edge_weights, S);
    }

    template <IsDijkstra D, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<D, SetType, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights, SetType &S) {
        return begin<D, SetType, P...>(this->begin<Basic>(), edge_weights, S);
    }

    template <IsDijkstra D, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<D, SetType, P...> end(SetType &S) {
        return Iterator<D, SetType, P...>(this->end<Basic>(), S);
    }

};

} // namespace Arachne

#endif // ARACHNE_GRAPH_HPP
</file>

<file path="GraphColor.hpp">
#ifndef ARACHNE_GRAPHCOLOR_HPP
#define ARACHNE_GRAPHCOLOR_HPP

#include <set>
#include <functional>
#include "Traits.hpp"
#include "BasicBitMap.hpp"
#include "ArachneData.hpp"

namespace Arachne {

struct Backtracking {
    static std::string print() {
        return "Backtracking";
    }
};
struct DSatur {
    static std::string print() {
        return "DSatur";
    }
};
struct Greedy {
    static std::string print() {
        return "Greedy";
    }
};
struct GreedySorted {
    static std::string print() {
        return "GreedySorted";
    }
};
struct WelshPowell {
    static std::string print() {
        return "WelshPowell";
    }
};
struct GreedyISet {
    static std::string print() {
        return "GreedyISet";
    }
};
struct RLF {
    static std::string print() {
        return "RLF";
    }
};

struct DSaturCompare {
    std::vector<Size> &saturation;
    std::vector<Size> &uncolored_degree;

    bool operator()(const NodeIdx &a, const NodeIdx &b) const {
        return saturation[a] < saturation[b] || (saturation[a] == saturation[b] && (uncolored_degree[a] < uncolored_degree[b] || (uncolored_degree[a] == uncolored_degree[b] && a < b)));
    }
};

struct WelshPowellCompare {
    std::vector<Size> &degree;

    bool operator()(const NodeIdx &a, const NodeIdx &b) const {
        return degree[a] < degree[b] || (degree[a] == degree[b] && a < b);
    }
};

struct RLFCompare {
    std::vector<Size> &degree_x;
    std::vector<Size> &degree_y;

    bool operator()(const NodeIdx &a, const NodeIdx &b) const {
        return degree_y[a] < degree_y[b] || (degree_y[a] == degree_y[b] && (degree_x[a] > degree_x[b] || (degree_x[a] == degree_x[b] && a < b)));
    }
};

template <typename Graph>
BasicBitMap get_occupied_colors(const typename Graph::IteratorPolicy::template Iterator<Basic> &node, std::vector<int> &color_map, int num_colors) {
    BasicBitMap colors(num_colors);
    auto adjacents = node.g->get_adjacents(node);
    for (auto it = adjacents.first; it != adjacents.second; ++it) {
        int color = color_map[(typename Graph::IteratorPolicy::template Iterator<Basic>) it];
        if (color >= 0) {
            colors.insert(color);
        }
    }
    return colors;
}

template <typename Graph>
BasicBitMap get_occupied_colors(const typename Graph::IteratorPolicy::template Iterator<Basic> &node, int num_colors) {
    BasicBitMap colors(num_colors);
    auto adjacents = node.g->get_adjacents(node);
    for (auto it = adjacents.first; it != adjacents.second; ++it) {
        int color = node->color;
        if (color >= 0) {
            colors.insert(color);
        }
    }
    return colors;
}

// This function has exponential runtime (with state space pruning, so in practice it should be much faster).
// It also has O(n) memory.
template <typename Graph>
void color_backtracking_rec(Graph &g, typename Graph::IteratorPolicy::template Iterator<Basic> node, std::vector<int> &color_map, int &min_colors, std::vector<int> &best_colors, int num_colors) { 
    if (node == g.number_of_nodes()) {
        best_colors = color_map;
        min_colors = num_colors;
        return;
    }

    BasicBitMap occupied_colors = get_occupied_colors<Graph>(node, color_map, num_colors);
    for (int color = 0; color < num_colors; color++) {
        if (num_colors >= min_colors) break;

        if (occupied_colors.contains(color)) {
            continue;
        }

        color_map[node] = color;
        color_backtracking_rec(g, node + 1ul, color_map, min_colors, best_colors, num_colors);
        color_map[node] = -1;
    }

    if (num_colors + 1 < min_colors) {
        color_map[node] = num_colors;
        color_backtracking_rec(g, node + 1ul, color_map, min_colors, best_colors, num_colors + 1);
        color_map[node] = -1;
    }
}

template <typename Graph, typename Compare>
requires HasColor<typename Graph::NodeType>
int color_pq(Graph &g,
             Compare cmp,
             std::function<bool(std::set<NodeIdx, Compare> &, typename Graph::IteratorPolicy::template Iterator<Basic>, typename Graph::IteratorPolicy::template Iterator<Basic>, const BasicBitMap &)> update_adj) {
    std::set<NodeIdx, Compare> pq(cmp);
    std::vector<BasicBitMap> adjacent_colors(g.number_of_nodes(), BasicBitMap(g.number_of_nodes()));

    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        node->color = -1;
        assert(pq.insert(node).second);
    }

    int num_colors = 0;
    while (!pq.empty()) {
        // get node with highest val from pq
        auto node_ptr = pq.begin();
        auto node = typename Graph::IteratorPolicy::template Iterator<Basic>(&g, *node_ptr);
        pq.erase(node_ptr);

        // get lowest available color and assign it to node
        BasicBitMap &occupied_colors = adjacent_colors[node];
        int avail_color = 0;
        for (int color_lim = num_colors; avail_color <= color_lim; avail_color++) {
            if (avail_color == color_lim) {
                num_colors++;
            }
            if (!occupied_colors.contains(avail_color)) {
                break;
            }
        }
        node->color = avail_color;

        // reassign values to adjacent nodes in priority queue
        auto adjacents = g.get_adjacents(node);
        BasicBitMap visited(g.number_of_nodes());
        for (auto it = adjacents.first; it != adjacents.second; ++it) {
            auto adj = (typename Graph::IteratorPolicy::template Iterator<Basic>) it;
            if (adj->color != -1 || visited.contains(adj)) continue;
            visited.insert(adj);

            // reassign values to adjacent node
            adjacent_colors[adj].insert(avail_color);
            update_adj(pq, node, adj, adjacent_colors[adj]);
        }
    }

    return num_colors;
}

template <typename T, typename Graph>
requires std::same_as<Backtracking, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    std::vector<int> storage(g.number_of_nodes(), -1);
    std::vector<int> best_colors(storage);
    int min_colors = g.number_of_nodes() + 1;

    color_backtracking_rec(g, g.template begin<Basic>(), storage, min_colors, best_colors, 0);

    for (auto it = g.template begin<Basic>(); it != g.template end<Basic>(); ++it) {
        it->color = best_colors[(NodeIdx) it];
    }

    return min_colors;
}

template <typename T, typename Graph>
requires std::same_as<DSatur, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    std::vector<Size> saturation(g.number_of_nodes(), 0);
    std::vector<Size> uncolored_degree(g.number_of_nodes(), 0);

    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        uncolored_degree[node] = g.degree(node);
    }

    return color_pq<Graph, DSaturCompare>(
        g, 
        DSaturCompare{saturation, uncolored_degree}, 
        [&saturation, &uncolored_degree](std::set<NodeIdx, DSaturCompare> &pq, auto node, auto adj, const BasicBitMap &adj_colored) {
            pq.erase(adj);
            saturation[adj] = adj_colored.size();
            uncolored_degree[adj] -= node.g->number_of_edges(node, adj);
            return pq.emplace(adj).second;
        }
    );
}

template <typename T, typename Graph>
requires std::same_as<Greedy, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    std::vector<BasicBitMap> adjacent_colors(g.number_of_nodes(), BasicBitMap(g.number_of_nodes()));
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        node->color = -1;
    }

    int num_colors = 0;
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        // get lowest available color and assign it to node
        BasicBitMap &occupied_colors = adjacent_colors[node];
        int avail_color = 0;
        for (int color_lim = num_colors; avail_color <= color_lim; avail_color++) {
            if (avail_color == color_lim) {
                num_colors++;
            }
            if (!occupied_colors.contains(avail_color)) {
                break;
            }
        }
        node->color = avail_color;

        // reassign values to adjacent nodes
        auto adjacents = g.get_adjacents(node);
        for (auto it = adjacents.first; it != adjacents.second; ++it) {
            auto adj = (typename Graph::IteratorPolicy::template Iterator<Basic>) it;
            if (adj->color != -1) continue;

            // reassign values to adjacent node
            adjacent_colors[adj].insert(avail_color);
        }
    }

    return num_colors;
}

template <typename T, typename Compare, typename Graph>
requires std::same_as<GreedySorted, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    return color_pq<Graph, Compare>(
        g,
        Compare(),
        [](auto pq, auto node, auto adj, auto adj_colored) {
            return true;
        }
    );
}

template <typename T, typename Graph>
requires std::same_as<WelshPowell, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    std::vector<Size> degree(g.number_of_nodes());
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        degree[node] = g.degree(node);
    }
    return color_pq<Graph, WelshPowellCompare>(
        g, 
        WelshPowellCompare{degree}, 
        [](auto pq, auto node, auto adj, auto adj_colored) {
            return true;
        }
    );
}

template <typename T, typename Graph>
requires std::same_as<GreedyISet, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    int avail_color = 0;
    auto x = std::make_unique<BasicBitMap>(g.number_of_nodes(), true);
    auto y = std::make_unique<BasicBitMap>(g.number_of_nodes());

    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        node->color = -1;
    }

    while (!x->empty()) {
        for (NodeIdx u: *x) {
            auto node = typename Graph::IteratorPolicy::template Iterator<Basic>(&g, u);
            x->erase(u);
            node->color = avail_color;

            auto adjacents = g.get_adjacents(node);
            for (auto it = adjacents.first; it != adjacents.second; ++it) {
                auto adj = (typename Graph::IteratorPolicy::template Iterator<Basic>) it;
                if (adj->color != -1 || y->contains(adj)) continue;
                x->erase(adj);
                y->insert(adj);
            }
        }
        
        std::swap(x, y);

        avail_color++;
    }

    return avail_color;
}

template <typename T, typename Graph>
requires std::same_as<RLF, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    int avail_color = 0;
    std::vector<Size> degree_x(g.number_of_nodes());
    std::vector<Size> degree_y(g.number_of_nodes());
    auto x = std::make_unique<std::set<NodeIdx, RLFCompare>>(RLFCompare{degree_x, degree_y});
    auto y = std::make_unique<std::set<NodeIdx, RLFCompare>>(RLFCompare{degree_x, degree_y});

    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        node->color = -1;
        degree_x[node] = g.degree(node);
        degree_y[node] = 0;
        x->insert(node);
    }

    while (!x->empty()) {
        while (!x->empty()) {
            // get node with highest val from pq
            auto u_ptr = x->begin();
            auto u = typename Graph::IteratorPolicy::template Iterator<Basic>(&g, *u_ptr);
            x->erase(u_ptr);
            u->color = avail_color;

            auto adjacents = g.get_adjacents(u);
            for (auto i = adjacents.first; i != adjacents.second; ++i) {
                auto v = (typename Graph::IteratorPolicy::template Iterator<Basic>) i;
                if (v->color != -1 || y->contains(v)) continue;
                
                x->erase(v);

                degree_x[v] -= g.number_of_edges(u, v);
                degree_y[v] = 0;

                auto adjacents = g.get_adjacents(v);
                BasicBitMap visited(g.number_of_nodes());
                for (auto j = adjacents.first; j != adjacents.second; ++j) {
                    auto w = (typename Graph::IteratorPolicy::template Iterator<Basic>) j;
                    if (visited.contains(w)) continue;
                    visited.insert(w);

                    if (y->contains(w)) {
                        Size num_edges = g.number_of_edges(v, w);
                        y->erase(w);
                        degree_x[v] -= num_edges;
                        degree_x[w] -= num_edges;
                        degree_y[v] += num_edges;
                        degree_y[w] += num_edges;
                        y->insert(w);
                    }
                }
                y->insert(v);
            }
        }

        std::swap(x, y);

        avail_color++;
    }

    return avail_color;
}

} // namespace Arachne

#endif // ARACHNE_GRAPHCOLOR_HPP
</file>

<file path="GraphPartition.hpp">
#ifndef GRAPH_PARTITION_HPP
#define GRAPH_PARTITION_HPP

#include <kaHIP_interface.h>

#include "Graph.hpp"

namespace Arachne {

Bool check_partition (std::vector<int> &part, unsigned num_boxes, unsigned capacity) {
    std::vector<unsigned> checker;
    checker.resize(num_boxes);
    for (auto &i : part) {
        checker[i]++;
        if (checker[i] > capacity) {
            std::cerr << "Failed on " << i << std::endl;
            return false;
        }
    }
    return true;
}

template <typename Graph>
std::pair<std::vector<int>, int> partition (Graph graph, unsigned num_boxes, unsigned capacity) {
    int number_of_nodes = num_boxes*capacity;
    if (number_of_nodes < graph.number_of_nodes()) {
        std::cerr << "fatal: too many qubits in circuit to partition" << std::endl;
        throw 0;
    }
	int parts = num_boxes;
    int ncon = 1;

    std::vector<int> xadj;
    std::vector<int> adjncy;
    auto it = graph.template begin<Basic>();
    auto it_end = graph.template end<Basic>();
    for (; it != it_end; it++) {
        xadj.push_back(adjncy.size());
        for (auto it2 = graph.get_neighbours(it); it2.first != it2.second; (it2.first)++){
            adjncy.push_back(graph.nodeId(it2.first));
        }
    }
    for (auto i = graph.number_of_nodes(); i <= number_of_nodes; ++i) xadj.push_back(adjncy.size());

    std::vector<int> adjwgt;

    for (auto edge_it = graph.get_edges(); edge_it.first != edge_it.second; (edge_it.first)++) {
        adjwgt.push_back((edge_it.first)->weight);
    }

    std::vector<int> part(number_of_nodes);
    
    int objval; 
    double imbalance = 0.0;

    kaffpa(&number_of_nodes, NULL, xadj.data(), adjwgt.data(), adjncy.data(), &parts, &imbalance, false, 0, ECO, &objval, part.data());

    part.resize(graph.number_of_nodes());

    if (check_partition(part, num_boxes, capacity)) return std::make_pair(part, objval);

    for (auto i = 0; i < number_of_nodes; i++) {
        part[i] = i / capacity;
    }

    return std::make_pair(part, objval);
}


} // namespace Arachne


#endif // GRAPH_PARTITION_HPP
</file>

<file path="Heterogenous.hpp">
#ifndef HETEROGENOUS_HPP
#define HETEROGENOUS_HPP

#include <cstddef>
#include <type_traits>
#include <iterator>
#include <variant>
#include <iostream>
#include <type_traits>
#include <string>

namespace Heterogenous {

/*
 *  Helper used to check whether Type is present in the parameter pack arg,
 *  used in containers to catch errors in added types.
 */
template <typename Type, typename... arg>
struct is_present {
    static constexpr bool value = (std::is_same_v<Type,arg> || ...);
};

/*
 *  Helpers used to remove duplicate types from parameter packs. Code taken
 *  from "Angew is no longer proud of SO" at, 
 *
 *  https://stackoverflow.com/questions/55941964/how-to-filter-duplicate-types-from-tuple-c
 */
template <typename Pack, typename Type>
struct contains;

template <class Car, class...Cdr, class Type>
struct contains<std::variant<Car,Cdr...>,Type> : contains<std::variant<Cdr...>, Type>
{};

template <class... Cdr, class Type>
struct contains<std::variant<Type,Cdr...>,Type> : std::true_type
{};

template <class Type>
struct contains<std::variant<>, Type> : std::false_type
{};

template <class Out, class In>
struct filter;

template <class... Out, class InCar, class...InCdr>
struct filter<std::variant<Out...>,std::variant<InCar,InCdr...> >
{
    using type = typename std::conditional<
        contains<std::variant<Out...>, InCar>::value,
        typename filter<std::variant<Out...>, std::variant<InCdr...> >::type,
        typename filter<std::variant<Out...,InCar>, std::variant<InCdr...>>::type
    >::type;
};

template <class Out>
struct filter<Out,std::variant<> >
{
    using type = Out;
};

template <class T>
using without_duplicates = typename filter<std::variant<>, T>::type;

/*
 *  Key value pair for maps and dictionaries. In order for a KeyValue to be
 *  valid, std::less<key_t> must be defined.
 */
template <typename key_t, typename value_t>
struct KeyValue {
    key_t key;
    value_t value;
};

template <typename value_t>
struct KeyValue<std::string,value_t> {
    std::string key;
    value_t value;
};

template <typename key_t, typename value_t>
inline std::ostream& operator<<(std::ostream& os, const KeyValue<key_t,value_t>& kv) {
    os << kv.key << " " << kv.value;
    return os;
}

template <typename value_t>
KeyValue(std::string,value_t) -> KeyValue<std::string,value_t>;

template <typename order_iterator, typename map_t, typename val_t>
class Iterator {
    public:
        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using val_ref = val_t&;
        using val_ptr = val_t*;
        using key_ptr = key_t*;
        using map_ptr = map_t*;

        Iterator(order_iterator o_iter, map_ptr m_ptr) : o_iter_(o_iter), m_ptr_(m_ptr) {}
        
        val_ref operator*() const { 
            return m_ptr_->at(*o_iter_); 
        }   
        val_ptr operator->() { return &(m_ptr_->at(*o_iter_)); }

        Iterator& operator++() { 
            ++o_iter_; 
            return (*this); 
        }

        friend bool operator==(const Iterator& a, const Iterator& b) { return ((a.o_iter_==b.o_iter_) and (a.m_ptr_==b.m_ptr_));}
        friend bool operator!=(const Iterator& a, const Iterator& b) { return ((a.o_iter_!=b.o_iter_) or (a.m_ptr_!=b.m_ptr_));}

    private:
        order_iterator o_iter_;
        map_ptr m_ptr_;
};

/*
 *  A map of heterogenous types that is type safe.
 */
template <typename key_t, typename... Ts>
class UnorderedMap {
    public:
        using value_var = std::variant<Ts...>;
        using order_t = std::vector<key_t>;
        using map_t = std::unordered_map<key_t,value_var>;
        using iterator_t = Iterator<typename order_t::iterator, map_t, value_var>;
        template<typename... key_ts>
        explicit UnorderedMap(const key_ts&... keys) {
            (order_.push_back(keys),...);
            (map_.emplace(keys,std::variant<Ts...>(Ts())),...);
        }
        template<typename... arg_ts>
        explicit UnorderedMap(const KeyValue<key_t,arg_ts>&... args) {
            static_assert((is_present<arg_ts...,Ts>::value || ...), 
                    "In UnorderedMap constructor: Type passed to constructor not found in template parameter pack.\n");        
            (order_.push_back(args.key),...);
            (map_.emplace(args.key,std::variant<Ts...>(args.value)),...);  
        }
        template<typename Arg>
        void emplace(const key_t& key, const Arg& value) {
            static_assert(is_present<Arg,Ts...>::value, 
                    "In UnorderedMap::emplace(): Type passed to emplace not found in template parameter pack.\n");
            order_.push_back(key);
            map_.emplace(key,value);
        }
        std::size_t size() const { return map_.size(); } 
        const map_t& map() const { return map_; }
        const order_t& order() const { return order_; }
        value_var& at(const key_t& key) { return map_.at(key); }
        const value_var& at(const key_t& key) const { return map_.at(key); }
        value_var& operator[](const key_t& key) { 
            if(map_.find(key)==map_.end())
                order_.push_back(key);
            return map_[key]; 
        }
        const value_var& operator[](const key_t& key) const { return map_[key]; }

        iterator_t begin() { return iterator_t(order_.begin(),&map_); }
        iterator_t end() { return iterator_t(order_.end(),&map_); }

    private:
        order_t order_;
        map_t map_;
}; // class UnorderedMap


/*
 *  Same as UnorderedMap but the key_t is a string
 */
template <typename... Ts>
class Dictionary {
    public:
        using value_var = without_duplicates<std::variant<Ts...> >;
        using key_t = std::string;
        using order_t = std::vector<key_t>;
        using map_t = std::unordered_map<key_t,value_var>;
        using iterator_t = Iterator<typename order_t::iterator, map_t, value_var>;
        template<typename... key_ts>
        explicit Dictionary(const key_ts&... keys) {
            (order_.push_back(keys),...);
            (map_.emplace(keys,value_var(Ts())),...);
        }
        template<typename... arg_ts>
        explicit Dictionary(const KeyValue<key_t,arg_ts>&... args) {
            static_assert((is_present<arg_ts...,Ts>::value || ...), 
                    "In Dictionary constructor: Type passed to constructor not found in template parameter pack.\n");        
            (order_.push_back(args.key),...);
            (map_.emplace(args.key,value_var(args.value)),...);  
        }
        template<typename Arg>
        void emplace(const key_t& key, const Arg& value) {
            static_assert(is_present<Arg,Ts...>::value, 
                    "In Dictionary::emplace(): Type passed to emplace not found in template parameter pack.\n");
            order_.push_back(key);
            map_.emplace(key,value);
        }
        std::size_t size() const { return map_.size(); } 
        const order_t& order() const { return order_; }
        const map_t& map() const { return map_; }
        value_var& at(const key_t& key) { return map_.at(key); }
        const value_var& at(const key_t& key) const { return map_.at(key); }
        value_var& operator[](const key_t& key) { 
            if(map_.find(key) == map_.end()) 
                order_.push_back(key);
            return map_[key]; 
        }
        const value_var& operator[](const key_t& key) const { 
            return map_[key]; 
        }
        
        iterator_t begin() { return iterator_t(order_.begin(),&map_); }
        iterator_t end() { return iterator_t(order_.end(),&map_); }
    private:
        order_t order_;
        map_t map_;
}; // class Dictionary

} // namespace Heterogenous

namespace std {

template <typename value_t, typename... value_ts>
inline ostream& operator<<(ostream& os, const variant<value_t, value_ts...>& var) {
    visit([&os](auto &&arg) {os << arg;}, var);
    return os;
} // namespace std

} // namespace Heterogenous

#endif // HETEROGENOUS_HPP
</file>

<file path="IteratorPolicy.hpp">
#ifndef ARACHNE_ITERATOR_POLICY_HPP
#define ARACHNE_ITERATOR_POLICY_HPP

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "Traits.hpp"
#include "Parameters.hpp"

namespace Arachne {

template <typename Graph, IsNodeData Node, IsEdgeData Edge>
struct IteratorPolicy {
    template <typename Iterator, typename InnerIterator, typename DereferenceType>
    struct SuperIterator {
        using iterator_category = std::bidirectional_iterator_tag;
        using value_type = Node;
        using pointer = value_type *;
        using reference = value_type &;

        Graph *g;
        InnerIterator it;

        SuperIterator(Graph *g, InnerIterator it) : g{g}, it{it} {}

        virtual const DereferenceType &operator *() const = 0;
        DereferenceType *operator->() const { return const_cast<DereferenceType*>(&**this); }

        virtual Iterator &operator++() = 0;
        Iterator operator++(int) { Iterator tmp = *static_cast<Iterator*>(this); ++(*this); return tmp; }

        Iterator operator+(NodeIdx n) {
            Iterator copy = *static_cast<Iterator*>(this);
            while (n-- > 0) ++copy;
            return copy;
        }

        bool operator==(const Iterator &other) const {
            return g == other.g && it == other.it;
        }
        bool operator!=(const Iterator &other) const {
            return !(*this == other);
        }

        virtual ~SuperIterator () = default;
    };

    template<IsIteratorTrait T, IsIteratorParameters ParamList = IteratorParameters<>>
    struct Iterator {};

    template <>
    struct Iterator<Basic> : public SuperIterator<Iterator<Basic>, NodeIdx, Node> {
        using SuperIterator = SuperIterator<Iterator<Basic>, NodeIdx, Node>;
        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;
        using SuperIterator::operator!=;
        using SuperIterator::operator->;
        using SuperIterator::operator+;
        using SuperIterator::SuperIterator;

        const Node &operator*() const override {
            return g->node(it);
        }

        Iterator<Basic> &operator++() override {
            ++it;
            return *this;
        }

        Iterator<Basic> operator--(int) { Iterator tmp = *this; --(*this); return tmp; }
        Iterator<Basic> &operator--() {
            --it;
            return *this;
        }

        Iterator<Basic> operator-(NodeIdx n) {
            Iterator<Basic> copy = *this;
            while (n-- > 0) --copy;
            return copy;
        }

        inline operator NodeIdx () const {
            return this->it;
        }
    };
};

}

#endif // ARACHNE_ITERATOR_POLICY_HPP
</file>

<file path="NodeData.hpp">
#ifndef ARACHNE_NODE_PARAMETERS_HPP
#define ARACHNE_NODE_PARAMETERS_HPP

#include <sstream>
#include <tuple>

#include "ArachneData.hpp"
#include "Types.hpp"
#include "display.hpp"

namespace Arachne {

template <typename... Data>
struct NodeData;

template <IsNotArachneData NotArachneData, typename... OtherData>
struct NodeData<NotArachneData, OtherData...> {
    static_assert(
        false, "NodeData cannot hold more than one non-arachne data type.\n");
};

// this partially orders the input types so that the user data is first. It
// makes things easier.
template <IsArachneData ArachneData, typename... OtherData>
struct NodeData<ArachneData, OtherData...> {
    static_assert(false, "In NodeData template arguments, user specified data "
                         "(if any) must come first.\n");
};

// Thanks to the above template specialization, all the ArachneData has been
// captured in the parameter pack.
template <IsNotArachneData UserData, IsArachneData... ArachneData>
struct NodeData<UserData, ArachneData...> : public ArachneData... {
    static constexpr bool is_node_data = true;
    UserData data{};

    explicit NodeData() {}

    explicit NodeData(UserData user_data, ArachneData::Data... arachne_data) {
        data = user_data;
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << "User Data: " << data << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <IsArachneData First, IsArachneData... ArachneData>
struct NodeData<First, ArachneData...> : public First, public ArachneData... {
    static constexpr bool is_node_data = true;
    explicit NodeData() {}
    explicit NodeData(First::Data first, ArachneData::Data... arachne_data) {
        First::set_value(first, this);
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << First::to_string(this) << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <IsArachneData... ArachneData>
struct NodeData<None, ArachneData...> : public ArachneData... {
    using UserData = None;
    explicit NodeData() {}

    explicit NodeData(ArachneData::Data... arachne_data) {
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << "User Data: None" << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <>
struct NodeData<None> {
    static constexpr bool is_node_data = true;
    using Data = None;
    Data data;

    String to_string(...) const { return display(data); }
};

template <>
struct NodeData<> {
    static constexpr bool is_node_data = true;
    using Data = None;
    Data data;

    String to_string(...) const { return display(data); }
};

template <typename T>
concept IsNodeData = T::is_node_data;

template <typename T>
concept IsNotNodeData = not IsNodeData<T>;

} // namespace Arachne

#endif // ARACHNE_NODE_PARAMETERS_HPP
</file>

<file path="NodeStoragePolicy.hpp">
#ifndef NODE_POLICY_HPP
#define NODE_POLICY_HPP

#include <array>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <vector>
#include <functional>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "display.hpp"

namespace Arachne {

template <typename Graph, IsNodeData Node, IsEdgeData Edge, typename Storage, Size N>
struct NodeStoragePolicy {};

template <typename Graph, IsNodeData Node, IsEdgeData Edge, Size N>
struct NodeStoragePolicy<Graph, Node, Edge, Dynamic, N> {
    using NodeType = Node;
    using NodeContainer = std::vector<Node>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;

    void initialize_node_container(Size n = N) {
        static_cast<Graph*>(this)->node_container_.resize(n);
    }
    // N.B. The method add_node_to_representation_ assumes that the node
    // container has been modified first!
    template <typename... NodeConstructorArgs>
    void add_node(NodeConstructorArgs&&... args) {
        static_cast<Graph*>(this)->node_container_.emplace_back(args...);
        static_cast<Graph*>(this)->add_node_to_representation_();
    }
    // N.B. The method add_node_to_representation_ assumes that the node
    // container has been modified first!
    void add_node(const Node node, int number = 1) {
        for (int i = 0; i < number; i++) static_cast<Graph*>(this)->node_container_.push_back(node);
        static_cast<Graph*>(this)->add_node_to_representation_(number);
    }
    // N.B. The method remove_node_from_representation_ assumes that the node
    // container has not been modified yet!
    void remove_node(const IteratorPolicy::template Iterator<Basic> it) {
        const NodeIdx a = it.it;
        static_cast<Graph*>(this)->remove_node_from_representation_(a);
        static_cast<Graph*>(this)->node_container_.erase(
            static_cast<Graph*>(this)->node_container().begin() + a);
    }

    // Removes nodes that do not satisfy pred. 
    // Returns the number of removed nodes. 
    Size filter(std::function<Bool(const typename IteratorPolicy::template Iterator<Basic>&)> pred) {
        if (static_cast<Graph*>(this)->number_of_nodes() == 0) return 0;
        std::vector<typename IteratorPolicy::template Iterator<Basic>> to_delete;
        for (auto it = static_cast<Graph*>(this)->template begin<Basic>(); it != static_cast<Graph*>(this)->template end<Basic>(); it++) {
            if (!pred(it)) {
                to_delete.push_back(it);
            }
        }
        for (auto it = to_delete.rbegin(); it != to_delete.rend(); it++) {
            remove_node(*it);
        }
        return to_delete.size();
    }
};

template <typename Graph, IsNodeData Node, IsEdgeData Edge, Size N>
struct NodeStoragePolicy<Graph, Node, Edge, Static, N> {
    using NodeType = Node;
    using NodeContainer = std::array<Node, N>;

    void initialize_node_container() {}
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, typename Storage>
class NodePolicy : public NodeStoragePolicy<Graph, Node, Edge, Storage, N>,
                   public IteratorPolicy<Graph, Node, Edge> {
    using StoragePolicy = NodeStoragePolicy<Graph, Node, Edge, Storage, N>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;
    friend StoragePolicy;

  public:
    using NodeType = Node;
    using NodeContainer = typename StoragePolicy::NodeContainer;
    using StoragePolicy::initialize_node_container;

    void initialize_node_container(NodeContainer node_container) {
        static_cast<Graph*>(this)->node_container_ = node_container;
    }

    Size number_of_nodes() const { return node_container_.size(); }
    const Node& node(const IteratorPolicy::template Iterator<Basic> &it) const { return node(it); }
    Node& node(const IteratorPolicy::template Iterator<Basic> &it) { return node(it); }
    const NodeContainer& node_container() const { return node_container_; }
    NodeContainer& node_container() { return node_container_; }

    String nodes_to_string(const String iter_delim = "\n") {
        std::stringstream ss;
        Size counter = 0;
        Size counter_size =
            std::to_string(static_cast<Graph*>(this)->node_container_.size())
                .size() +
            2;
        for (auto iter : static_cast<Graph*>(this)->node_container_) {
            String counter_str = "[" + std::to_string(counter) + "] ";
            ss << std::setw(counter_size) << std::left << counter_str
               << iter.to_string() << iter_delim;
            counter++;
        }
        return ss.str().substr(0, ss.str().size() - iter_delim.size());
    }

    template <IsBasicTrait Trait>
    inline IteratorPolicy::template Iterator<Basic> begin() { 
        return typename IteratorPolicy::template Iterator<Basic>(static_cast<Graph*>(this), 0); 
    }

    template <IsBasicTrait Trait>
    inline IteratorPolicy::template Iterator<Basic> end() { 
        return typename IteratorPolicy::template Iterator<Basic>(static_cast<Graph*>(this), static_cast<Graph*>(this)->number_of_nodes());
    }

    NodeContainer node_container_;

    const Node& node(NodeIdx idx) const { return node_container_.at(idx); }
    Node& node(NodeIdx idx) { return node_container_.at(idx); }
    NodeIdx nodeId(const IteratorPolicy::template Iterator<Basic> &it) { return reinterpret_cast<NodeIdx>(it.it); }
};

} // namespace Arachne

#endif // NODE_POLICY_HPP
</file>

<file path="observer_ptr.hpp">
// Copyright 2018-2019 by Martin Moene
//
// nonstd::observer_ptr<> is a C++98 onward implementation for std::observer_ptr as of C++17.
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#pragma once

#ifndef NONSTD_OBSERVER_PTR_H_INCLUDED
#define NONSTD_OBSERVER_PTR_H_INCLUDED

#define observer_ptr_MAJOR  0
#define observer_ptr_MINOR  4
#define observer_ptr_PATCH  0

#define observer_ptr_VERSION  nsop_STRINGIFY(observer_ptr_MAJOR) "." nsop_STRINGIFY(observer_ptr_MINOR) "." nsop_STRINGIFY(observer_ptr_PATCH)

#define nsop_STRINGIFY(  x )  nsop_STRINGIFY_( x )
#define nsop_STRINGIFY_( x )  #x

// observer_ptr configuration:

#ifndef  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SMART_PTR
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SMART_PTR  0
#else
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SMART_PTR
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SMART_PTR
#endif

#ifndef  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR  0
#endif

#ifndef  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR  0
#endif

#ifndef  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_TO_UNDERLYING_TYPE
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_TO_UNDERLYING_TYPE  0
#endif

#ifndef  nsop_CONFIG_CONFIRMS_COMPILATION_ERRORS
# define nsop_CONFIG_CONFIRMS_COMPILATION_ERRORS  0
#endif

#define nsop_OBSERVER_PTR_DEFAULT  0
#define nsop_OBSERVER_PTR_NONSTD   1
#define nsop_OBSERVER_PTR_STD      2

#if !defined( nsop_CONFIG_SELECT_OBSERVER_PTR )
# define nsop_CONFIG_SELECT_OBSERVER_PTR  ( nsop_HAVE_STD_OBSERVER_PTR ? nsop_OBSERVER_PTR_STD : nsop_OBSERVER_PTR_NONSTD )
#endif

// C++ language version detection (C++23 is speculative):
// Note: VC14.0/1900 (VS2015) lacks too much from C++14.

#ifndef   nsop_CPLUSPLUS
# if defined(_MSVC_LANG ) && !defined(__clang__)
#  define nsop_CPLUSPLUS  (_MSC_VER == 1900 ? 201103L : _MSVC_LANG )
# else
#  define nsop_CPLUSPLUS  __cplusplus
# endif
#endif

#define nsop_CPP98_OR_GREATER  ( nsop_CPLUSPLUS >= 199711L )
#define nsop_CPP11_OR_GREATER  ( nsop_CPLUSPLUS >= 201103L )
#define nsop_CPP11_OR_GREATER_ ( nsop_CPLUSPLUS >= 201103L )
#define nsop_CPP14_OR_GREATER  ( nsop_CPLUSPLUS >= 201402L )
#define nsop_CPP17_OR_GREATER  ( nsop_CPLUSPLUS >= 201703L )
#define nsop_CPP20_OR_GREATER  ( nsop_CPLUSPLUS >= 202002L )
#define nsop_CPP23_OR_GREATER  ( nsop_CPLUSPLUS >= 202300L )

// Use C++17 std::any if available and requested:

#if nsop_CPP17_OR_GREATER && defined(__has_include )
# if __has_include( <experimental/memory> )
#  define nsop_HAVE_STD_OBSERVER_PTR  1
# else
#  define nsop_HAVE_STD_OBSERVER_PTR  0
# endif
#else
# define  nsop_HAVE_STD_OBSERVER_PTR  0
#endif

#define  nsop_USES_STD_OBSERVER_PTR  ( (nsop_CONFIG_SELECT_OBSERVER_PTR == nsop_OBSERVER_PTR_STD) || ((nsop_CONFIG_SELECT_OBSERVER_PTR == nsop_OBSERVER_PTR_DEFAULT) && nsop_HAVE_STD_OBSERVER_PTR) )

//
// Using std::experimental::observer_ptr:
//

#if nsop_USES_STD_OBSERVER_PTR

#include <experimental/memory>

namespace nonstd {

    using std::experimental::observer_ptr;
    using std::experimental::make_observer;
    using std::experimental::swap;

    using std::experimental::operator==;
    using std::experimental::operator!=;
    using std::experimental::operator<;
    using std::experimental::operator<=;
    using std::experimental::operator>;
    using std::experimental::operator>=;
}

#else // nsop_USES_STD_OBSERVER_PTR

#include <cassert>
#include <algorithm>
#include <functional>

// Compiler versions:
//
// MSVC++  6.0  _MSC_VER == 1200  nsop_COMPILER_MSVC_VERSION ==  60  (Visual Studio 6.0)
// MSVC++  7.0  _MSC_VER == 1300  nsop_COMPILER_MSVC_VERSION ==  70  (Visual Studio .NET 2002)
// MSVC++  7.1  _MSC_VER == 1310  nsop_COMPILER_MSVC_VERSION ==  71  (Visual Studio .NET 2003)
// MSVC++  8.0  _MSC_VER == 1400  nsop_COMPILER_MSVC_VERSION ==  80  (Visual Studio 2005)
// MSVC++  9.0  _MSC_VER == 1500  nsop_COMPILER_MSVC_VERSION ==  90  (Visual Studio 2008)
// MSVC++ 10.0  _MSC_VER == 1600  nsop_COMPILER_MSVC_VERSION == 100  (Visual Studio 2010)
// MSVC++ 11.0  _MSC_VER == 1700  nsop_COMPILER_MSVC_VERSION == 110  (Visual Studio 2012)
// MSVC++ 12.0  _MSC_VER == 1800  nsop_COMPILER_MSVC_VERSION == 120  (Visual Studio 2013)
// MSVC++ 14.0  _MSC_VER == 1900  nsop_COMPILER_MSVC_VERSION == 140  (Visual Studio 2015)
// MSVC++ 14.1  _MSC_VER >= 1910  nsop_COMPILER_MSVC_VERSION == 141  (Visual Studio 2017)
// MSVC++ 14.2  _MSC_VER >= 1920  nsop_COMPILER_MSVC_VERSION == 142  (Visual Studio 2019)

#if defined(_MSC_VER ) && !defined(__clang__)
# define nsop_COMPILER_MSVC_VER      (_MSC_VER )
# define nsop_COMPILER_MSVC_VERSION  (_MSC_VER / 10 - 10 * ( 5 + (_MSC_VER < 1900 ) ) )
#else
# define nsop_COMPILER_MSVC_VER      0
# define nsop_COMPILER_MSVC_VERSION  0
#endif

#define nsop_COMPILER_VERSION( major, minor, patch )  ( 10 * ( 10 * (major) + (minor) ) + (patch) )

#if defined(__clang__)
# define nsop_COMPILER_CLANG_VERSION  nsop_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)
#else
# define nsop_COMPILER_CLANG_VERSION  0
#endif

#if defined(__GNUC__) && !defined(__clang__)
# define nsop_COMPILER_GNUC_VERSION  nsop_COMPILER_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#else
# define nsop_COMPILER_GNUC_VERSION  0
#endif

// half-open range [lo..hi):
#define nsop_BETWEEN( v, lo, hi ) ( (lo) <= (v) && (v) < (hi) )

// Presence of language and library features:

#ifdef _HAS_CPP0X
# define nsop_HAS_CPP0X  _HAS_CPP0X
#else
# define nsop_HAS_CPP0X  0
#endif

// Unless defined otherwise below, consider VC12 as C++11 for observer_ptr:

#if nsop_COMPILER_MSVC_VER >= 1800
# undef  nsop_CPP11_OR_GREATER
# define nsop_CPP11_OR_GREATER  1
#endif

#define nsop_CPP11_100  (nsop_CPP11_OR_GREATER_ || nsop_COMPILER_MSVC_VER >= 1600)
#define nsop_CPP11_110  (nsop_CPP11_OR_GREATER_ || nsop_COMPILER_MSVC_VER >= 1700)
#define nsop_CPP11_120  (nsop_CPP11_OR_GREATER_ || nsop_COMPILER_MSVC_VER >= 1800)
#define nsop_CPP11_140  (nsop_CPP11_OR_GREATER_ || nsop_COMPILER_MSVC_VER >= 1900)

#define nsop_CPP11_000  (nsop_CPP11_OR_GREATER_)
#define nsop_CPP14_000  (nsop_CPP14_OR_GREATER )
#define nsop_CPP17_000  (nsop_CPP17_OR_GREATER )

// Presence of C++ language features:

#define nsop_HAVE_CONSTEXPR_11          nsop_CPP11_000
#define nsop_HAVE_CONSTEXPR_14          nsop_CPP14_000
#define nsop_HAVE_DEFAULT_FUNCTION_TEMPLATE_ARG  nsop_CPP11_120
#define nsop_HAVE_EXPLICIT_CONVERSION   nsop_CPP11_140
#define nsop_HAVE_NOEXCEPT              nsop_CPP11_140
#define nsop_HAVE_NULLPTR               nsop_CPP11_100

#define nsop_HAVE_TYPEOF  (nsop_CPP11_000 && nsop_COMPILER_GNUC_VERSION)

// Presence of C++ library features:

#define nsop_HAVE_STD_DECAY             nsop_CPP11_110
#define nsop_HAVE_STD_DECLVAL           nsop_CPP11_110
#define nsop_HAVE_STD_SMART_PTRS        nsop_CPP11_140

// Presence and usage of smart pointers:

#define nsop_HAVE_IMPLICIT_CONVERSION_FROM_SMART_PTR  ( \
    nsop_HAVE_STD_SMART_PTRS && ( \
        nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR || \
        nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR  ) \
    )

// C++ feature usage:

#if nsop_HAVE_CONSTEXPR_11
# define nsop_constexpr constexpr
#else
# define nsop_constexpr /*nothing*/
#endif

#if nsop_HAVE_CONSTEXPR_14
# define nsop_constexpr14 constexpr
#else
# define nsop_constexpr14 /*nothing*/
#endif

#if nsop_HAVE_EXPLICIT_CONVERSION
# define nsop_explicit explicit
#else
# define nsop_explicit /*nothing*/
#endif

#if nsop_HAVE_NOEXCEPT
# define nsop_noexcept noexcept
#else
# define nsop_noexcept /*nothing*/
#endif

#if nsop_HAVE_NULLPTR
# define nsop_NULLPTR nullptr
#else
# define nsop_NULLPTR NULL
#endif

// additional includes:

#if nsop_HAVE_IMPLICIT_CONVERSION_FROM_SMART_PTR
# include <memory>
#endif

// common_type:

#if nsop_HAVE_STD_DECAY && nsop_HAVE_STD_DECLVAL
# include <type_traits>  // std::decay
# include <utility>      // std::declval
#endif

#define nsop_HAVE_OWN_COMMON_TYPE_STD    (nsop_HAVE_STD_DECAY && nsop_HAVE_STD_DECLVAL || nsop_HAVE_TYPEOF)
#define nsop_HAVE_OWN_COMMON_TYPE_TYPEOF  nsop_HAVE_TYPEOF

// Method enabling

#define nsop_REQUIRES_T(VA) \
    , typename std::enable_if< (VA), int >::type = 0

//
// oberver_ptr:
//

namespace nonstd { namespace observer_ptr_lite {

// observer_ptr:

template< class W >
class observer_ptr
{
public:
    typedef W   element_type;
    typedef W * pointer;
    typedef W & reference;

    nsop_constexpr14 observer_ptr() nsop_noexcept
    : ptr( nsop_NULLPTR ) {}

#if nsop_HAVE_NULLPTR
    nsop_constexpr14 observer_ptr( std::nullptr_t ) nsop_noexcept
    : ptr( nullptr ) {}
#endif

    nsop_constexpr14 explicit observer_ptr( pointer p ) nsop_noexcept
    : ptr(p) {}

    template< class W2
#if nsop_HAVE_DEFAULT_FUNCTION_TEMPLATE_ARG
        nsop_REQUIRES_T(( std::is_convertible<W2*, W*>::value ))
#endif
    >
    nsop_constexpr14 observer_ptr( observer_ptr<W2> other ) nsop_noexcept
    : ptr( other.get() ) {}

#if nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR && nsop_HAVE_STD_SMART_PTRS
    template< class W2
        nsop_REQUIRES_T(( std::is_convertible<W2*, W*>::value ))
    >
    nsop_constexpr14 observer_ptr( std::unique_ptr<W2> const & other ) nsop_noexcept
    : ptr( other.get() ) {}
#endif

#if nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR && nsop_HAVE_STD_SMART_PTRS
    template< class W2
        nsop_REQUIRES_T(( std::is_convertible<W2*, W*>::value ))
    >
     nsop_constexpr14 observer_ptr( std::shared_ptr<W2> const & other ) nsop_noexcept
    : ptr( other.get() ) {}
#endif

    nsop_constexpr14 pointer get() const nsop_noexcept
    {
        return ptr;
    }

    nsop_constexpr14 reference operator*() const
    {
        return assert( ptr != nsop_NULLPTR ), *ptr;
    }

    nsop_constexpr14 pointer operator->() const nsop_noexcept
    {
        return ptr;
    }

#if nsop_HAVE_EXPLICIT_CONVERSION

    nsop_constexpr14 explicit operator bool() const nsop_noexcept
    {
        return ptr != nsop_NULLPTR;
    }

    nsop_constexpr14 explicit operator pointer() const nsop_noexcept
    {
        return ptr;
    }
#elif nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_TO_UNDERLYING_TYPE

    nsop_constexpr14 operator pointer() const nsop_noexcept
    {
        return ptr;
    }
#else
private:
    typedef void (observer_ptr::*safe_bool)() const;
    void this_type_does_not_support_comparisons() const {}
public:

    nsop_constexpr14 operator safe_bool() const nsop_noexcept
    {
        return ptr != nsop_NULLPTR ? &observer_ptr::this_type_does_not_support_comparisons : 0;
    }
#endif

    nsop_constexpr14 pointer release() nsop_noexcept
    {
        pointer p( ptr );
        reset();
        return p;
    }

    nsop_constexpr14 void reset( pointer p = nsop_NULLPTR ) nsop_noexcept
    {
        ptr = p;
    }

    nsop_constexpr14 void swap( observer_ptr & other ) nsop_noexcept
    {
        using std::swap;
        swap(ptr, other.ptr);
    }

private:
    pointer ptr;
};

// specialized algorithms:

template< class W >
void swap( observer_ptr<W> & p1, observer_ptr<W> & p2 ) nsop_noexcept
{
    p1.swap( p2 );
}

template< class W >
observer_ptr<W> make_observer( W * p ) nsop_noexcept
{
    return observer_ptr<W>( p );
}

template< class W1, class W2 >
bool operator==( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return p1.get() == p2.get();
}

template< class W1, class W2 >
bool operator!=( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return !( p1 == p2 );
}

#if nsop_HAVE_NULLPTR

template< class W >
bool operator==( observer_ptr<W> p, std::nullptr_t ) nsop_noexcept
{
    return !p;
}

template< class W >
bool operator==( std::nullptr_t, observer_ptr<W> p ) nsop_noexcept
{
    return !p;
}

template< class W >
bool operator!=( observer_ptr<W> p, std::nullptr_t ) nsop_noexcept
{
    return static_cast<bool>( p );
}

template< class W >
bool operator!=( std::nullptr_t, observer_ptr<W> p ) nsop_noexcept
{
    return static_cast<bool>( p );
}
#endif

namespace detail
{
    template< class T, class U >
#if nsop_HAVE_OWN_COMMON_TYPE_STD
    struct common_type { typedef typename std::decay< decltype(true ? std::declval<T>() : std::declval<U>()) >::type type; };
#elif nsop_HAVE_OWN_COMMON_TYPE_TYPEOF
    struct common_type { typedef __typeof__( true ? T() : U() ) type; };
#else // fall back
    struct common_type { typedef T type; };
#endif
} // namespace detail

template< class W1, class W2 >
bool operator<( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    // return std::less<W3>()( p1.get(), p2.get() );
    // where W3 is the composite pointer type (C++14 5) of W1* and W2*.
    return std::less< typename detail::common_type<W1*,W2*>::type >()( p1.get(), p2.get() );
}

template< class W1, class W2 >
bool operator>( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return p2 < p1;
}

template< class W1, class W2 >
bool operator<=( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return !( p2 < p1 );
}

template< class W1, class W2 >
bool operator>=( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return !( p1 < p2 );
}

} // namespace observer_ptr_lite

// provide in namespace nonstd:

using observer_ptr_lite::observer_ptr;
using observer_ptr_lite::make_observer;
using observer_ptr_lite::swap;

using observer_ptr_lite::operator==;
using observer_ptr_lite::operator!=;
using observer_ptr_lite::operator<;
using observer_ptr_lite::operator<=;
using observer_ptr_lite::operator>;
using observer_ptr_lite::operator>=;

} // namespace nonstd

#if nsop_CPP11_OR_GREATER

namespace std
{

template< class T >
struct hash< ::nonstd::observer_ptr<T> >
{
    size_t operator()(::nonstd::observer_ptr<T> p ) const nsop_noexcept
    {
        return hash<T*>()( p.get() );
    }
};

}
#endif

// #undef ...

#endif // nsop_USES_STD_OBSERVER_PTR

#endif // NONSTD_OBSERVER_PTR_H_INCLUDED

// end of file
</file>

<file path="Parameters.hpp">
#ifndef ARACHNE_GRAPH_PARAMETERS_HPP
#define ARACHNE_GRAPH_PARAMETERS_HPP

#include "EdgeData.hpp"
#include "NodeData.hpp"
#include "Traits.hpp"
#include "BasicBitMap.hpp"

namespace Arachne {

/* DEFAULT PARAMETERS */
using DefaultDirectionality = Undirected;
using DefaultConnectivity = Simple;
using DefaultStorage = Dynamic;
using DefaultEdgeData = EdgeData<>;
using DefaultNodeData = NodeData<>;

template <typename T>
concept IsArachneParameter = IsGraphTrait<T> || IsNodeData<T> || IsEdgeData<T>;

/* DIRECTIONALITY PARSER */
template <IsArachneParameter... Params>
struct ParseForDirectionality;

template <IsNotDirectionalityTrait NotDirectionality,
          IsArachneParameter... Rest>
struct ParseForDirectionality<NotDirectionality, Rest...>
    : ParseForDirectionality<Rest...> {};

template <IsDirectionalityTrait Directionality, IsArachneParameter... Rest>
struct ParseForDirectionality<Directionality, Rest...> {
    using DirectionalityTrait = Directionality;
};

template <>
struct ParseForDirectionality<> {
    using DirectionalityTrait = DefaultDirectionality;
};

/* CONNECTIVITY PARSER */
template <IsArachneParameter... Params>
struct ParseForConnectivity;

template <IsNotConnectivityTrait NotConnectivity, IsArachneParameter... Rest>
struct ParseForConnectivity<NotConnectivity, Rest...>
    : ParseForConnectivity<Rest...> {};

template <IsConnectivityTrait Connectivity, IsArachneParameter... Rest>
struct ParseForConnectivity<Connectivity, Rest...> {
    using ConnectivityTrait = Connectivity;
};

template <>
struct ParseForConnectivity<> {
    using ConnectivityTrait = DefaultConnectivity;
};

/* STORAGE PARSER */
template <IsArachneParameter... Params>
struct ParseForStorage;

template <IsNotStorageTrait NotStorage, IsArachneParameter... Rest>
struct ParseForStorage<NotStorage, Rest...> : ParseForStorage<Rest...> {};

template <IsStorageTrait Storage, IsArachneParameter... Rest>
struct ParseForStorage<Storage, Rest...> {
    using StorageTrait = Storage;
};

template <>
struct ParseForStorage<> {
    using StorageTrait = DefaultStorage;
};

/* NODE DATA PARSER */
template <IsArachneParameter... Params>
struct ParseForNodeData;

template <IsNotNodeData NotNodeData, IsArachneParameter... Rest>
struct ParseForNodeData<NotNodeData, Rest...> : ParseForNodeData<Rest...> {};

template <IsNodeData NodeData, IsArachneParameter... Rest>
struct ParseForNodeData<NodeData, Rest...> {
    using NodeDataParam = NodeData;
};

template <>
struct ParseForNodeData<> {
    using NodeDataParam = DefaultNodeData;
};

/* EDGE DATA PARSER */
template <IsArachneParameter... Params>
struct ParseForEdgeData;

template <IsNotEdgeData NotEdgeData, IsArachneParameter... Rest>
struct ParseForEdgeData<NotEdgeData, Rest...> : ParseForEdgeData<Rest...> {};

template <IsEdgeData EdgeData, IsArachneParameter... Rest>
struct ParseForEdgeData<EdgeData, Rest...> {
    using EdgeDataParam = EdgeData;
};

template <>
struct ParseForEdgeData<> {
    using EdgeDataParam = DefaultEdgeData;
};

/* PARAMETER LIST */
template <IsArachneParameter... Params>
struct Parameters {
    static bool constexpr IsParameters = true;
    using Directionality =
        typename ParseForDirectionality<Params...>::DirectionalityTrait;
    using Connectivity =
        typename ParseForConnectivity<Params...>::ConnectivityTrait;
    using Storage = typename ParseForStorage<Params...>::StorageTrait;
    using EdgeData = typename ParseForEdgeData<Params...>::EdgeDataParam;
    using NodeData = typename ParseForNodeData<Params...>::NodeDataParam;
};

template <typename T>
concept IsParameters = T::IsParameters;

/* ======== ITERATOR ======== */

/* DEFAULT PARAMETERS */
using DefaultPruningTrait = MultiplePathPruning;
using DefaultTraversalTrait = Full;
using DefaultSetType = BasicBitMap;

template <typename T>
concept IsIteratorParameter = IsPathPruningTrait<T> || IsTraversalTrait<T> || IsSetType<T>;

/* MULTIPLE PATH PRUNING PARSER */
template <IsIteratorParameter... Params>
struct ParseForMPP;

template <IsNotPathPruningTrait NotMPP, IsIteratorParameter... Rest>
struct ParseForMPP<NotMPP, Rest...> : ParseForMPP<Rest...> {};

template <IsPathPruningTrait MPP, IsArachneParameter... Rest>
struct ParseForMPP<MPP, Rest...> {
    using PruningTrait = MPP;
};

template <>
struct ParseForMPP<> {
    using PruningTrait = DefaultPruningTrait;
};

/* TRAVERSAL TRAIT PARSER */
template <IsIteratorParameter... Params>
struct ParseForTraversalTrait;

template <IsNotTraversalTrait NotTT, IsIteratorParameter... Rest>
struct ParseForTraversalTrait<NotTT, Rest...> : ParseForTraversalTrait<Rest...> {};

template <IsTraversalTrait TT, IsIteratorParameter... Rest>
struct ParseForTraversalTrait<TT, Rest...> {
    using TraversalTrait = TT;
};

template <>
struct ParseForTraversalTrait<> {
    using TraversalTrait = DefaultTraversalTrait;
};

/* SET TYPE PARSER */
template <IsIteratorParameter... Params>
struct ParseForSetType;

template <IsNotSetType NotST, IsIteratorParameter... Rest>
struct ParseForSetType<NotST, Rest...> : ParseForSetType<Rest...> {};

template <IsSetType ST, IsIteratorParameter... Rest>
struct ParseForSetType<ST, Rest...> {
    using SetType = ST;
};

template <>
struct ParseForSetType<> {
    using SetType = DefaultSetType;
};

template <IsIteratorParameter... Params>
struct IteratorParameters {
    static bool constexpr IsIteratorParameters = true;
    using PruningTrait =
        typename ParseForMPP<Params...>::PruningTrait;
    using SetType =
        typename ParseForSetType<Params...>::SetType;
    using TraversalTrait =
        typename ParseForTraversalTrait<Params...>::TraversalTrait;
};

template <typename T>
concept IsIteratorParameters = T::IsIteratorParameters;

} // namespace Arachne

#endif // ARACHNE_GRAPH_PARAMETERS_HPP
</file>

<file path="real.hpp">
#ifndef REAL_HPP
#define REAL_HPP

#include <cmath>

#include "Types.hpp"

namespace Arachne {

constexpr Real eq_cutoff = 1e-15;

inline bool real_eq(const Real a, const Real b) {
    return (std::abs(a - b) < eq_cutoff);
}

} // namespace Arachne

#endif // REAL_HPP
</file>

<file path="Traits.hpp">
#ifndef TRAITS_HPP
#define TRAITS_HPP

#include <list>
#include <tuple>
#include <concepts>

#include "Types.hpp"

namespace Arachne {

template <typename T>
concept IsBoolType = 
    std::same_as<T, std::true_type> || std::same_as<T, std::false_type>;

/*
 * Directionality Traits
 */

struct Undirected {};
struct Directed {};

template <typename T>
concept IsDirectionalityTrait =
    std::same_as<T, Undirected> || std::same_as<T, Directed>;

template <typename T>
concept IsNotDirectionalityTrait = not IsDirectionalityTrait<T>;

/*
 * Connectivity Traits
 */
struct Simple {
    template <typename T>
    using InnerContainer = T;

    template <typename T>
    static T empty_value = T(0);
};

struct Multi {
    template <typename T>
    using InnerContainer = std::list<T>;

    template <typename T>
    static std::list<T> empty_value;
};

template <typename T>
concept IsConnectivityTrait = std::same_as<T, Simple> || std::same_as<T, Multi>;

template <typename T>
concept IsNotConnectivityTrait = not IsConnectivityTrait<T>;

/*
 * Storage Traits
 */
struct Dynamic {};
struct Static {};

template <typename T>
concept IsStorageTrait = std::same_as<T, Dynamic> || std::same_as<T, Static>;

template <typename T>
concept IsNotStorageTrait = not IsStorageTrait<T>;

template <typename T>
concept IsGraphTrait =
    IsDirectionalityTrait<T> || IsConnectivityTrait<T> || IsStorageTrait<T>;

template <typename T>
concept IsNotGraphTrait = not IsGraphTrait<T>;

/*
 * Graph Traversal Traits
 */
struct Basic {};
struct Neighbour {};
struct Adjacent {};
struct EdgeIterator {};

/*
 * DFS Traits
 */
struct InOrder {};
struct PreOrder {};
struct PostOrder {};

struct BestFirst {};
struct AStar {};
struct Dijkstra {};


/*
 * Iterator Path Pruning Traits
 */
struct MultiplePathPruning{};
struct NoPathPruning{};

/*
 * Iterator Traversal Trait
 */
struct Component{};
struct Full{};

template <typename T>
concept IsIteratorTrait = std::same_as<T, Basic> 
                        || std::same_as<T, Neighbour>
                        || std::same_as<T, Adjacent>
                        || std::same_as<T, EdgeIterator>
                        || std::same_as<T, InOrder>
                        || std::same_as<T, PreOrder>
                        || std::same_as<T, PostOrder>
                        || std::same_as<T, BestFirst>
                        || std::same_as<T, AStar>
                        || std::same_as<T, Dijkstra>;


template <typename T>
concept IsBasicTrait = std::same_as<T, Basic>;

template <typename T>
concept IsSearchTrait = std::same_as<T, InOrder>
                        || std::same_as<T, PreOrder>
                        || std::same_as<T, PostOrder>;

template <typename T>
concept IsOrderedSearchTrait = std::same_as<T, BestFirst>
                        || std::same_as<T, AStar>
                        || std::same_as<T, Dijkstra>;

template <typename T>
concept IsBestFirst = std::same_as<T, BestFirst>;

template <typename T>
concept IsAStar = std::same_as<T, AStar>;

template <typename T>
concept IsDijkstra = std::same_as<T, Dijkstra>;

template <typename T>
concept IsPathPruningTrait = std::same_as<T, MultiplePathPruning> || std::same_as<T, NoPathPruning>;
template <typename T>
concept IsNotPathPruningTrait = not IsPathPruningTrait<T>;

template <typename T>
concept IsTraversalTrait = std::same_as<T, Component> || std::same_as<T, Full>;
template <typename T>
concept IsNotTraversalTrait = not IsTraversalTrait<T>;

template <typename T>
concept IsCompleteTraversal = std::same_as<T, Full>;

template <typename T>
concept IsSetType = requires (T x, T::value_type y) {
    {x.contains(y)} -> std::same_as<bool>;
    {x.insert(y).second} -> std::same_as<bool&&>;
};
template <typename T>
concept IsNotSetType = not IsSetType<T>;

} // namespace Arachne

#endif // TRAITS_HPP
</file>

<file path="Types.hpp">
#ifndef TYPES_HPP
#define TYPES_HPP

#include <memory>
#include <set>
#include <unordered_set>
#include <string>
#include <type_traits>
#include <utility>
#include <variant>
#include <vector>

// #include "observer_ptr.hpp"

namespace Arachne {

using None = std::monostate;
using Int32 = int;
using Uint32 = unsigned int;
using Real = double;
using String = std::string;
using Bool = bool;
using Size = std::size_t;
using NodeIdx = std::size_t;
using EdgeIdx = std::pair<NodeIdx, NodeIdx>;

using SizeVec = std::vector<Size>;
using RealVec = std::vector<Real>;
using NodeIdxSet = std::set<NodeIdx>;
using SizeSet = std::set<Size>;

template <Size N>
using SizeConstant = std::integral_constant<Size, N>;
// template <typename T>
// using ObsPtr = nonstd::observer_ptr_lite::observer_ptr<T>;
template <typename T>
using SharedPtr = std::shared_ptr<T>;
template <typename T>
using UniquePtr = std::unique_ptr<T>;

}; // namespace Arachne

#endif // TYPES_HPP
</file>

</files>
</file>

<file path="ArachneData.hpp">
#ifndef ARACHNE_DATA_HPP
#define ARACHNE_DATA_HPP

#include "Types.hpp"

namespace Arachne {

template <typename T>
concept HasIndex = requires(T x) {
    {x.index};
};

template <typename T>
concept HasWeight = requires(T x) {
    {x.weight};
};

template <typename T>
concept HasColor = requires(T x) {
    {x.color};
};

template <typename T>
concept HasName = requires(T x) {
    {x.name};
};

struct Index {
    using Data = Size;
    Data index{};

    template <HasIndex T>
    void set_value(Data value, T* x) {
        x->index = value;
    }

    template <HasIndex T>
    String to_string(const T* x) const {
        return "Index: " + std::to_string(x->index);
    }
};

struct Weight {
    using Data = Real;
    Data weight{};

    template <HasWeight T>
    void set_value(Data value, T* x) {
        x->weight = value;
    }

    template <HasWeight T>
    String to_string(const T* x) const {
        return "Weight: " + std::to_string(x->weight);
    }
};

struct Color {
    using Data = Int32;
    Data color{};

    template <HasColor T>
    void set_value(Data value, T* x) {
        x->color = value;
    }

    template <HasColor T>
    String to_string(const T* x) const {
        return "Color: " + std::to_string(x->color);
    }
};

struct Name {
    using Data = String;
    Data name{};

    template <HasName T>
    void set_value(Data value, T* x) {
        x->name = value;
    }

    template <HasName T>
    String to_string(const T* x) const {
        return "Name: " + x->name;
    }
};

template <typename T>
concept IsArachneData = std::same_as<T, Weight> || std::same_as<T, Color> ||
                        std::same_as<T, Name> || std::same_as<T, Index>;

template <typename T>
concept IsNotArachneData = not IsArachneData<T>;

} // namespace Arachne

#endif // ARACHNE_DATA_HPP
</file>

<file path="BasicBitMap.hpp">
#ifndef ARACHNE_BASICBITMAP_HPP
#define ARACHNE_BASICBITMAP_HPP

#include "Types.hpp"

namespace Arachne {

struct BasicBitMap {
    using value_type = NodeIdx;

    std::vector<Bool> bitmap;
    Size n;

    BasicBitMap(Size n, Bool b = false) : bitmap(n, b), n{b ? n : 0} {}

    BasicBitMap() : bitmap(), n{0} {}

    std::pair<value_type, Bool> insert(const value_type& it) {
        Bool b = !bitmap.at(it);
        n += b;
        bitmap[it] = true;
        return std::make_pair(it, b);
    }

    Bool erase(const value_type &it) {
        Bool b = bitmap.at(it);
        n -= b;
        bitmap[it] = false;
        return b;
    }

    Bool contains(const value_type& it) const { return bitmap.at(it); }

    Size size() const { return n; }

    Bool empty() const { return n == 0; }

    class iterator {
        std::vector<Bool> &bitmap;
        value_type posn;

    public:
        iterator(std::vector<Bool> &bitmap, value_type posn): bitmap{bitmap}, posn{posn} {}

        iterator operator++() {
            if (posn == bitmap.size()) return *this;
            while (!bitmap[++posn] && posn != bitmap.size());
            return *this;
        }
        iterator operator++(int) {
            iterator tmp = *this;
            ++(*this);
            return tmp;
        }
        iterator operator--() {
            while (!bitmap[--posn]);
            return *this;
        }
        iterator operator--(int) {
            iterator tmp = *this;
            --(*this);
            return tmp;
        }
        bool operator==(const iterator &other) const {
            return &bitmap == &(other.bitmap) && posn == other.posn;
        }
        bool operator!=(const iterator &other) const {
            return !(*this == other);
        }
        value_type operator*() {
            return posn;
        }
    };

    iterator begin() {
        Size start = 0;
        while (start != bitmap.size() && !bitmap[start]) ++start;
        return iterator(bitmap, start);
    }

    iterator end() {
        return iterator(bitmap, bitmap.size());
    }
};

} // namespace Arachne

#endif // ARACHNE_BASICBITMAP_HPP
</file>

<file path="Clique.hpp">
#ifndef ARACHNE_CLIQUE_HPP
#define ARACHNE_CLIQUE_HPP

#include <functional>
#include "BasicBitMap.hpp"
#include "Traits.hpp"

namespace Arachne {

struct Backtracking {};

template <typename Graph>
BasicBitMap get_free_neighbours(const typename Graph::IteratorPolicy::template Iterator<Basic>& node, const std::function<Bool(const typename Graph::IteratorPolicy::template Iterator<Basic>&)>& pred) {
    BasicBitMap c(node.g->number_of_nodes());
    auto neighbours = node.g->get_neighbours(node);
    for (auto it = neighbours.first; it != neighbours.second; ++it) {
        if (pred(it)) {
            c.insert((typename Graph::IteratorPolicy::template Iterator<Basic>)it);
        }
    }
    return c;
}

template <typename Graph>
void clique_backtracking(
    Graph& g, BasicBitMap candidates,
    BasicBitMap& current_clique, std::vector<NodeIdx>& max_clique, std::vector<Size>& degree_map) {
    if (candidates.empty() || candidates.size() + current_clique.size() <= max_clique.size()) {
        if (current_clique.size() > max_clique.size()) {
            max_clique.clear();
            for (auto i : current_clique) max_clique.push_back(i);
        }
        return;
    }

    for (auto node : candidates) {
        current_clique.insert(node);
        clique_backtracking(
            g,
            get_free_neighbours<Graph>(g.template begin<Basic>() + node, [&] (const auto & n) { return candidates.contains(n) && !current_clique.contains(n) && g.count(n, node) && degree_map[node] >= max_clique.size();}),
            current_clique, max_clique, degree_map);
        current_clique.erase(node);
    }
}

template <typename B, typename Graph>
requires std::same_as<Backtracking, B>
std::vector<typename Graph::IteratorPolicy::template Iterator<Basic>> maximum_clique(Graph& g) {
    BasicBitMap map(g.number_of_nodes());
    for (auto i = 0; i < g.number_of_nodes(); i++) {
        map.insert(i);
    }
    std::vector<Size> deg(g.number_of_nodes());
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); node++) deg[node] = g.degree(node);
    std::vector<NodeIdx> max_clique;
    BasicBitMap current_clique(g.number_of_nodes());
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>();
         node++) {
        if (node == 0) {
            max_clique.push_back(node);
        }
        current_clique.insert(node);
        clique_backtracking(g, get_free_neighbours<Graph>(node, [&] (const auto & n) { return !current_clique.contains(n) && g.count(n, node);}), current_clique, max_clique, deg);
        current_clique.erase(node);
    }

    std::vector<typename Graph::IteratorPolicy::template Iterator<Basic>> retval;
    for (auto i : max_clique) {
        retval.push_back(g.template begin<Basic>() + i);
    }
    return retval;
}

template <typename Graph>
void BronKerbosch (Graph& g, std::vector<std::vector<NodeIdx>>& cliques, BasicBitMap& R, BasicBitMap P, BasicBitMap X) {
    if (P.empty() && X.empty()) {
        cliques.emplace_back();
        for (auto i : R) cliques.back().push_back(i);
        return;
    }
    auto pivot = P.empty() ? g.template begin<Basic>() + *X.begin() : g.template begin<Basic>() + *P.begin();
    auto N_pivot = get_free_neighbours<Graph>(pivot, [] (const auto & n) { return true; });
    for (auto v: P) {
        if (N_pivot.contains(v)) continue;
        R.insert(v);
        BronKerbosch(g, cliques, R, get_free_neighbours<Graph>(g.template begin<Basic>() + v, [&](const auto & n) { return P.contains(n); }), get_free_neighbours<Graph>(g.template begin<Basic>() + v, [&](auto & n) { return X.contains(n); }));
        R.erase(v);
        P.erase(v);
        X.insert(v);
    }
}

template <typename Graph>
std::vector<std::vector<NodeIdx>> maximal_cliques (Graph& g) {
    std::vector<std::vector<NodeIdx>> retval;
    BasicBitMap R(g.number_of_nodes());
    BasicBitMap P(g.number_of_nodes(), true);
    for (auto i = 0; i < g.number_of_nodes(); i++) {
        P.insert(i);
    }
    BasicBitMap X(g.number_of_nodes());
    BronKerbosch(g, retval, R, P, BasicBitMap(g.number_of_nodes()));
    return retval;
}

} // namespace Arachne

#endif // ARACHNE_CLIQUE_HPP
</file>

<file path="CompressedFormatPolicy.hpp">
#ifndef COMPRESSED_FORMAT_POLICY_HPP
#define COMPRESSED_FORMAT_POLICY_HPP

#include <numeric>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "graph_utilities.hpp"

namespace Arachne {

template <typename Graph, typename Edge, IsStorageTrait Storage, Size N>
struct CompressedFormatStoragePolicy {};

template <typename Graph, typename Edge, Size N>
struct CompressedFormatStoragePolicy<Graph, Edge, Dynamic, N> {
    using NodeContainer = std::vector<unsigned>;

    void initialize_node_list(Size n = N) {
        static_cast<Graph*>(this)->node_list_ = NodeContainer(n+1, 0);
    }

    void add_node_to_representation_() {
        static_cast<Graph*>(this)->node_list_.push_back(static_cast<Graph*>(this)->edge_list_.size());
    }
    void remove_node_from_representation_(const NodeIdx a) {
        Size removed_edges = static_cast<Graph*>(this)->degree(a);
        int diff = static_cast<Graph*>(this)->node_list_.at(a + 1) - static_cast<Graph*>(this)->node_list_.at(a);
        static_cast<Graph*>(this)->edge_list_.erase(static_cast<Graph*>(this)->edge_list_.begin() + static_cast<Graph*>(this)->node_list_.at(a), static_cast<Graph*>(this)->edge_list_.begin() + static_cast<Graph*>(this)->node_list_.at(a + 1));
        static_cast<Graph*>(this)->node_list_.erase(static_cast<Graph*>(this)->node_list_.begin() + a);
        for (Size i = a; i < static_cast<Graph*>(this)->node_list_.size(); i++) static_cast<Graph*>(this)->node_list_.at(i) -= diff;

        NodeIdx j = 0;
        for (int i = 0; i < static_cast<Graph*>(this)->edge_list_.size(); i++) {
            while (static_cast<Graph*>(this)->node_list_[j] == i) j++;
            if (a == static_cast<Graph*>(this)->edge_list_.at(i).first) {
                static_cast<Graph*>(this)->edge_list_.erase(static_cast<Graph*>(this)->edge_list_.begin() + i);
                for(NodeIdx k = j; k < static_cast<Graph*>(this)->node_list_.size(); k++) static_cast<Graph*>(this)->node_list_[k] -= 1;
                i--;
            }
            else if (static_cast<Graph*>(this)->edge_list_.at(i).first > a) {
                static_cast<Graph*>(this)->edge_list_.at(i).first -= 1;
            }
        }

        static_cast<Graph*>(this)->number_of_edges_ -= removed_edges;
    }
};

template <typename Graph, typename Edge, Size N>
struct CompressedFormatStoragePolicy<Graph, Edge, Static, N> {
    using NodeContainer = std::array<unsigned, N+1>;

    void initialize_node_list() {
        static_cast<Graph*>(this)->node_list_.fill(0);
    }
};

template <typename Graph, typename Edge, IsDirectionalityTrait Directionality>
struct CompressedFormatDirectionalityPolicy {};

template <typename Graph, typename Edge>
struct CompressedFormatDirectionalityPolicy<Graph, Edge, Undirected> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        EdgeIdx reversed = reverse_edge_idx(std::make_pair(source, dest));
        Bool success = static_cast<Graph*>(this)->add_edge_to_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph*>(this)->add_edge_to_inner_container_(reversed, edge);
        static_cast<Graph*>(this)->number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        EdgeIdx reversed = reverse_edge_idx(std::make_pair(source, dest));
        Bool success = static_cast<Graph*>(this)->remove_edge_from_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph*>(this)->remove_edge_from_inner_container_(reversed, edge);
        static_cast<Graph*>(this)->number_of_edges_ -= success;
    }

    Size degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

protected:
    static Bool contains_neighbour_(NodeIdx node, EdgeIdx edge) {
        return node == edge.first || node == edge.second;
    }

    EdgeIdx order_edge_ (const EdgeIdx& idx) {
        return order_edge_idx(idx);
    }

    EdgeIdx reverse_edge_ (const EdgeIdx& idx) {
        return reverse_edge_idx(idx);
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return it > it2 ? 0 : static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge>
struct CompressedFormatDirectionalityPolicy<Graph, Edge, Directed> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->add_edge_to_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph&>(*this).number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->remove_edge_from_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph&>(*this).number_of_edges_ -= success;
    }

    Size out_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

    Size in_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(i, n);
        }
        return deg;
    }

    Size degree(NodeIdx n) {
        return in_degree(n)+ out_degree(n)-static_cast<Graph*>(this)->count(n, n);
    }

protected:
    static Bool contains_neighbour_(NodeIdx node, EdgeIdx edge) {
        return node == edge.first;
    }

    EdgeIdx order_edge_ (const EdgeIdx& idx) {
        return idx;
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge, IsConnectivityTrait Connectivity>
struct CompressedFormatConnectivityPolicy {};

template <typename Graph, typename Edge>
struct CompressedFormatConnectivityPolicy<Graph, Edge, Simple> {

  protected:
    Bool add_edge_to_inner_container_(const EdgeIdx& idx, Edge& edge) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(idx.first);index != static_cast<Graph*>(this)->node_list_.at(idx.first+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == idx.second) {
                static_cast<Graph*>(this)->edge_list_.at(index) = std::make_pair(idx.second, edge);
                return false;
            }
        }
        static_cast<Graph*>(this)->edge_list_.insert(static_cast<Graph*>(this)->edge_list_.begin() + static_cast<Graph*>(this)->node_list_.at(idx.first), std::make_pair(idx.second, edge));
        for (NodeIdx i = idx.first + 1;i <= static_cast<Graph*>(this)->number_of_nodes(); i++) {
            static_cast<Graph*>(this)->node_list_.at(i)++;
        }
        return true;
    }

    Bool remove_edge_from_inner_container_(const EdgeIdx& idx, ...) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(idx.first);index != static_cast<Graph*>(this)->node_list_.at(idx.first+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == idx.second) {
                static_cast<Graph*>(this)->edge_list_.erase(static_cast<Graph*>(this)->edge_list_.begin() + index);
                for (NodeIdx i = idx.first + 1;i <= static_cast<Graph*>(this)->number_of_nodes(); i++) {
                    static_cast<Graph*>(this)->node_list_.at(i)--;
                }
                return true;
            }
        }
        return false;
    }
  public:
    Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(source);index != static_cast<Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<Graph*>(this)->edge_list_.at(index).second;
        }
        exit(EXIT_FAILURE);
    }
    const Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) const {
        for (unsigned index = static_cast<const Graph*>(this)->node_list_.at(source);index != static_cast<const Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<const Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<const Graph*>(this)->edge_list_.at(index).second;
        }
        exit(EXIT_FAILURE);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        for (unsigned index = static_cast<const Graph*>(this)->node_list_.at(source);index != static_cast<const Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<const Graph*>(this)->edge_list_.at(index).first == dest) return 1;
        }
        return 0;
    }
};

template <typename Graph, typename Edge>
struct CompressedFormatConnectivityPolicy<Graph, Edge, Multi> {
  protected:
    Bool add_edge_to_inner_container_(const EdgeIdx& idx, Edge edge = Edge()) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(idx.first);index != static_cast<Graph*>(this)->node_list_.at(idx.first+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == idx.second) {
                static_cast<Graph*>(this)->edge_list_.at(index).second.push_back(edge);
                return true;
            }
        }
        static_cast<Graph*>(this)->edge_list_.insert(static_cast<Graph*>(this)->edge_list_.begin() + static_cast<Graph*>(this)->node_list_.at(idx.first), std::make_pair(idx.second, Multi::InnerContainer<Edge>{edge}));
        for (NodeIdx i = idx.first + 1;i <= static_cast<Graph*>(this)->number_of_nodes(); i++) {
            static_cast<Graph*>(this)->node_list_.at(i)++;
        }
        return true;
    }

    Bool remove_edge_from_inner_container_(const EdgeIdx& idx, Edge edge = Edge()) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(idx.first);index != static_cast<Graph*>(this)->node_list_.at(idx.first+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == idx.second) {
                for (auto & iter : static_cast<Graph*>(this)->edge_list_.at(index).second) {
                    if (iter == edge) {
                        static_cast<Graph*>(this)->edge_list_.at(index).second.at(idx).erase(iter);
                        if (static_cast<Graph*>(this)->edge_list_.at(index).second.size() == 0) {
                            static_cast<Graph*>(this)->edge_list_.erase(static_cast<Graph*>(this)->edge_list_.begin() + index);
                            for (NodeIdx i = idx.first + 1; i <= static_cast<Graph*>(this)->number_of_nodes(); i++) {
                                static_cast<Graph*>(this)->node_list_.at(i)--;
                            }
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    }
  public:
    Edge& get_edges(const NodeIdx& source, const NodeIdx& dest) {
        for (unsigned index = static_cast<Graph*>(this)->node_list_.at(source);index != static_cast<Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<Graph*>(this)->edge_list_.at(index).second;
        }
    }
    const Edge& get_edges(const NodeIdx& source, const NodeIdx& dest) const {
        for (unsigned index = static_cast<const Graph*>(this)->node_list_.at(source);index != static_cast<const Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<const Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<const Graph*>(this)->edge_list_.at(index).second;
        }
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        for (unsigned index = static_cast<const Graph*>(this)->node_list_.at(source);index != static_cast<const Graph*>(this)->node_list_.at(source+1); index++) {
            if (static_cast<const Graph*>(this)->edge_list_.at(index).first == dest) return static_cast<const Graph*>(this)->edge_list_.at(index).second.size();
        }
        return 0;
    }
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, IsStorageTrait Storage,
          IsDirectionalityTrait Directionality,
          IsConnectivityTrait Connectivity>
class CompressedFormat
    : public CompressedFormatStoragePolicy<Graph, Edge, Storage, N>,
      public CompressedFormatDirectionalityPolicy<Graph, Edge, Directionality>,
      public CompressedFormatConnectivityPolicy<Graph, Edge, Connectivity>,
      public IteratorPolicy<Graph, Node, Edge> {
    using StoragePolicy = CompressedFormatStoragePolicy<Graph, Edge, Storage, N>;
    using DirectionalityPolicy =
        CompressedFormatDirectionalityPolicy<Graph, Edge, Directionality>;
    using ConnectivityPolicy =
        CompressedFormatConnectivityPolicy<Graph, Edge, Connectivity>;
    friend StoragePolicy;
    friend DirectionalityPolicy;
    friend ConnectivityPolicy;

  public:
    using StoragePolicy::initialize_node_list;
    using CompressedFormatNodeContainer = typename StoragePolicy::NodeContainer;
    using CompressedFormatEdgeContainer =
        std::vector<std::pair<NodeIdx, typename Connectivity::template InnerContainer<Edge>>>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;

    explicit CompressedFormat() : number_of_edges_(0) {
        initialize_node_list();
    }
    explicit CompressedFormat(Size n) : number_of_edges_(0) {
        initialize_node_list(n);
    }

    const Size& number_of_edges() const { return number_of_edges_; }
    template<typename... Args>
    Size number_of_edges (NodeIdx first, Args... nodes) {
        return static_cast<Graph*>(this)->num_of_edges_({first, nodes...});
    }
    CompressedFormatEdgeContainer& edge_list() { return edge_list_; }
    const CompressedFormatEdgeContainer& edge_list() const { return edge_list_; }
    CompressedFormatNodeContainer& node_list() { return node_list_; }
    const CompressedFormatNodeContainer& node_list() const { return node_list_; }

    String representation_to_string(const String col_delim = " | ",
                                    const String iter_delim = "\n") {
        std::stringstream ss;

        Size col_width = 0;
        for (unsigned i = 0; i < node_list_.size(); i++) {
            col_width = std::max(col_width, display(i).size());
        }
        for (unsigned i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            ss << std::setw(col_width) << std::left << display(i);
            for (unsigned j = node_list_.at(i); j < node_list_.at(i+1); j++) {
                ss << col_delim;
                ss << std::setw(col_width) << std::left << display(edge_list_.at(j).first);
                ss << " ";
                ss << display(edge_list_.at(j).second);
            }
            ss << iter_delim;
        }
        return ss.str().substr(0, ss.str().size() - iter_delim.size());
    }

    template<IsIteratorTrait T>
    struct Iterator {};

    template<>
    struct Iterator<Neighbour> : public IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename CompressedFormatEdgeContainer::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename CompressedFormatEdgeContainer::iterator, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx node;

        Iterator<Neighbour>(Graph *g, NodeIdx node, CompressedFormatEdgeContainer::iterator it) : SuperIterator{g, it}, node{node} {}

        const Node &operator *() const {
            return g->node(it->first);
        }

        Iterator<Neighbour> &operator++() {
            ++it;
            return *this;
        }

        Bool operator==(const Iterator<Neighbour> &other) {
            return g == other.g && it == other.it && node == other.node;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first);
        }
    };

    template<>
    struct Iterator<Adjacent> : public IteratorPolicy::template SuperIterator<Iterator<Adjacent>, NodeIdx, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Adjacent>, NodeIdx, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx node;
        NodeIdx source;

        const Node &operator *() const {
            return g->node(node == source ? g->edge_list()[it].first : source);
        }

        Iterator<Adjacent> &operator++() {
            while (it < g->edge_list().size()) {
                if (source+1 < g->node_list_.size() && it < g->node_list()[source + 1]) {
                    ++it;
                    if (it == g->edge_list().size()) return *this;
                    while (g->node_list_[source+1] == it) source++;
                    if (node == source || node == g->edge_list_[it].first) return *this;
                }
            }
            return *this;
        }

        Bool operator==(const Iterator<Adjacent> &other) {
            return g == other.g && it == other.it && node == other.node;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, node == source ? g->edge_list()[it].first : source);
        }

        Iterator<Adjacent>(Graph *g, NodeIdx node) : 
            SuperIterator{g, 0}, 
            node{node}, 
            source{0} {
                if (it == g->edge_list_.size()) return;
                while (g->node_list_[source+1] == it) source++;
                if (node != source && node != g->edge_list()[it].first) {
                    ++(*this);
                }
            }
        Iterator<Adjacent>(Graph *g, NodeIdx node, NodeIdx it) : SuperIterator{g, it}, node{node}  {}
    };

    std::pair<Iterator<Neighbour>, Iterator<Neighbour>> get_neighbours(NodeIdx node) {
        return std::make_pair(
            Iterator<Neighbour>(static_cast<Graph*>(this), node, edge_list_.begin()+node_list_.at(node)),
            Iterator<Neighbour>(static_cast<Graph*>(this), node, edge_list_.begin()+node_list_.at(node+1))
        );
    }

    std::pair<Iterator<Adjacent>, Iterator<Adjacent>> get_adjacents(NodeIdx node) {
        return std::make_pair(
            Iterator<Adjacent>(static_cast<Graph*>(this), node),
            Iterator<Adjacent>(static_cast<Graph*>(this), node, edge_list().size())
        );
    }

    template<>
    struct Iterator<EdgeIterator> : public IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename CompressedFormatEdgeContainer::iterator, typename Connectivity::template InnerContainer<Edge>> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename CompressedFormatEdgeContainer::iterator, typename Connectivity::template InnerContainer<Edge>>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        CompressedFormatNodeContainer::iterator node_it;

        Iterator<EdgeIterator>(Graph *g, typename CompressedFormatEdgeContainer::iterator it, typename CompressedFormatNodeContainer::iterator node_it) : SuperIterator{g, it}, node_it{node_it} {
            while (this->node_it != this->g->node_list_.end() && this->node_it != (this->g->node_list_.end()-1) && this->it == g->edge_list_.begin() + *(this->node_it+1)) this->node_it++;
        }

        const typename Connectivity::template InnerContainer<Edge> &operator *() const {
            return it->second;
        }

        Iterator<EdgeIterator> &operator++() {
            ++it;
            while (node_it != (g->node_list_.end()-1) && it == g->edge_list_.begin() + *(node_it+1)) node_it++;
            return *this;
        }

        Bool operator==(const Iterator<Neighbour> &other) {
            return g == other.g && it == other.it;
        }

        typename IteratorPolicy::template Iterator<Basic> first () {
            return typename IteratorPolicy::template Iterator<Basic>(g, std::distance(g->node_list_.begin(), node_it) );
        }

        typename IteratorPolicy::template Iterator<Basic> second () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first);
        }

        const Edge &edge () const {
            return it->second;
        }
    };

    std::pair<Iterator<EdgeIterator>, Iterator<EdgeIterator>> get_edges() {
        return std::make_pair(
            Iterator<EdgeIterator>(static_cast<Graph*>(this), edge_list_.begin(), node_list_.begin()),
            Iterator<EdgeIterator>(static_cast<Graph*>(this), edge_list_.end(), node_list_.end())
        );
    }

  protected:
    Size number_of_edges_;
    CompressedFormatNodeContainer node_list_;
    CompressedFormatEdgeContainer edge_list_;
};

} // namespace Arachne

#endif // COMPRESSED_FORMAT_POLICY_HPP
</file>

<file path="constants.hpp">
#ifndef CONSTANTS_HPP
#define CONSTANTS_HPP

#include "Types.hpp"

namespace Arachne {

constexpr inline Bool DIRECTED = true;
constexpr inline Bool UNDIRECTED = false;
constexpr inline Uint32 NODE_COLW = 10;
constexpr inline Size DEFAULT_CONTAINER_SIZE = 1;
constexpr inline Size DEFAULT_MATRIX_SIZE = 1;

} // namespace Arachne

#endif // CONSTANTS_HPP
</file>

<file path="display.hpp">
#ifndef DISPLAY_HPP
#define DISPLAY_HPP

#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <sstream>
#include <string>
#include <type_traits>

#include "Types.hpp"

namespace Arachne {

/* CONCEPTS */
template <typename T>
concept IsDereferenceable = requires(T a) {
    {*a};
};

template <typename T>
concept IsDisplayable = requires(T a) {
    {display(a)};
};

template <typename T>
concept IsNone = std::same_as<T, None>;

template <typename T>
concept HasForwardIterator = std::forward_iterator<typename T::iterator>;

template <typename T>
concept HasBidirectionalIterator =
    std::bidirectional_iterator<typename T::iterator>;

template <typename T>
concept HasToStringMethod = requires(T x) {
    { x.to_string() } -> std::convertible_to<String>;
};

template <typename T>
concept HasRandomAccessIterator =
    std::random_access_iterator<typename T::iterator>;

template <typename T>
concept IsAtleastForwardIterable =
    HasForwardIterator<T> || HasBidirectionalIterator<T> ||
    HasRandomAccessIterator<T>;

template <typename T>
concept IsNotAtleastForwardIterable = !IsAtleastForwardIterable<T>;

template <typename T>
concept IsPair = requires(T x) {
    typename T::first_type;
    typename T::second_type;
    x.first;
    x.second;
    { x.first } -> std::same_as<typename T::first_type&>;
    { x.second } -> std::same_as<typename T::second_type&>;
};

template <typename T>
concept IsEdgeIdx = std::same_as<typename T::first_type, NodeIdx> &&
                    std::same_as<typename T::second_type, NodeIdx>;

template <typename T>
concept IsContainerOfPairs =
    IsAtleastForwardIterable<T> && IsPair<typename T::value_type>;

template <typename T>
concept IsNotContainerOfPairs = not IsContainerOfPairs<T>;

template <typename T>
concept IsFundamental = std::is_fundamental_v<T>;

/* DISPLAY OVERLOADS */
template <typename T>
requires IsNone<T> inline String display(const T...) {
    return "None";
}

template <typename T>
requires IsFundamental<T> inline String display(const T x,
                                                const String left_delim = "",
                                                const String right_delim = "") {
    return left_delim + std::to_string(x) + right_delim;
}

template <typename T>
requires IsDereferenceable<T> inline String
display(const T x, const String left_delim = "",
        const String right_delim = "") {
    return left_delim + std::to_string(*x) + right_delim;
}

template <typename T>
requires HasToStringMethod<T> inline String
display(const T x, const String left_delim = "",
        const String right_delim = "") {
    return left_delim + x.to_string() + right_delim;
}

template <typename T>
requires IsEdgeIdx<T> inline String display(const T x,
                                            const String left_delim = "(",
                                            const String right_delim = ")") {
    return left_delim + std::to_string(x.first) + "," +
           std::to_string(x.second) + right_delim;
}

template <typename T>
requires IsAtleastForwardIterable<T> inline String
display(T& forward_iterable_container, const String iter_delim = "\n") {
    std::stringstream ss;
    for (auto iter : forward_iterable_container) {
        ss << display(iter) << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

template <typename T>
requires IsAtleastForwardIterable<T> inline String
display(const std::list<std::pair<NodeIdx, T>>& container,
        const String col_delim = " : ", const String iter_delim = ", ",
        const String left_delim = "[", const String right_delim = "]") {

    std::stringstream ss;
    for (auto iter : container) {
        ss << display(iter.first, left_delim, right_delim);
        ss << col_delim;
        ss << display(iter.second, iter_delim);
        ss << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

template <typename T>
requires IsAtleastForwardIterable<T> inline String
display(const std::map<NodeIdx, T>& container, const String col_delim = " : ",
        const String iter_delim = ", ", const String left_delim = "[",
        const String right_delim = "]") {

    std::stringstream ss;
    for (auto iter : container) {
        ss << display(iter.first, left_delim, right_delim);
        ss << col_delim;
        ss << display(iter.second, iter_delim);
        ss << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

template <typename T>
requires IsNotAtleastForwardIterable<T> inline String
display(const std::list<std::pair<NodeIdx, T>>& container,
        const String col_delim = " : ", const String iter_delim = ", ",
        const String left_delim = "[", const String right_delim = "]") {

    std::stringstream ss;
    for (auto iter : container) {
        ss << display(iter.first, left_delim, right_delim);
        ss << col_delim;
        ss << display(iter.second);
        ss << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

template <typename T>
requires IsNotAtleastForwardIterable<T> inline String
display(const std::map<NodeIdx, T>& container, const String col_delim = " : ",
        const String iter_delim = ", ", const String left_delim = "[",
        const String right_delim = "]") {

    std::stringstream ss;
    for (auto iter : container) {
        ss << display(iter.first, left_delim, right_delim);
        ss << col_delim;
        ss << display(iter.second);
        ss << iter_delim;
    }
    return ss.str().substr(0, ss.str().size() - iter_delim.size());
}

} // namespace Arachne

#endif // DISPLAY_HPP
</file>

<file path="EdgeData.hpp">
#ifndef ARACHNE_EDGE_DATA_HPP
#define ARACHNE_EDGE_DATA_HPP

#include <sstream>

#include "ArachneData.hpp"
#include "Types.hpp"
#include "display.hpp"

namespace Arachne {

template <typename... Data>
struct EdgeData;

template <IsNotArachneData NotArachneData, typename... OtherData>
struct EdgeData<NotArachneData, OtherData...> {
    static_assert(
        false, "EdgeData cannot hold more than one non-arachne data type.\n");
};

// this partially orders the input types so that the user data is first. It
// makes things easier.
template <IsArachneData ArachneData, typename... OtherData>
struct EdgeData<ArachneData, OtherData...> {
    static_assert(false, "In EdgeData template arguments, user specified data "
                         "(if any) must come first.\n");
};

// Thanks to the above template specialization, all the ArachneData has been
// captured in the parameter pack.
template <IsNotArachneData UserData, IsArachneData... ArachneData>
struct EdgeData<UserData, ArachneData...> : public ArachneData... {
    static constexpr bool is_edge_data = true;
    UserData data;

    explicit EdgeData() {}

    explicit EdgeData(UserData user_data, ArachneData::Data... arachne_data): data{user_data} {
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << "User Data: " << data << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <IsArachneData First, IsArachneData... ArachneData>
struct EdgeData<First, ArachneData...> : public First, public ArachneData... {
    static constexpr bool is_edge_data = true;
    explicit EdgeData() {}
    explicit EdgeData(First::Data first, ArachneData::Data... arachne_data) {
        First::set_value(first, this);
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << First::to_string(this) << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <IsArachneData... ArachneData>
struct EdgeData<None, ArachneData...> : public ArachneData... {
    using UserData = None;
    explicit EdgeData() {}

    explicit EdgeData(ArachneData::Data... arachne_data) {
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << "User Data: None" << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <>
struct EdgeData<None> {
    static constexpr bool is_edge_data = true;
    using UserData = None;
    UserData data;

    String to_string(...) const { return display(data); }
};

template <>
struct EdgeData<> {
    static constexpr bool is_edge_data = true;
    using UserData = None;
    UserData data;

    String to_string(...) const { return display(data); }
};

template <typename T>
concept IsEdgeData = T::is_edge_data;

template <typename T>
concept IsNotEdgeData = not IsEdgeData<T>;
} // namespace Arachne

#endif // ARACHNE_EDGE_DATA_HPP
</file>

<file path="EdgeListPolicy.hpp">
#ifndef EDGE_LIST_POLICY_HPP
#define EDGE_LIST_POLICY_HPP

#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <sstream>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "graph_utilities.hpp"

namespace Arachne {

template <typename Graph, typename Edge, IsStorageTrait Storage>
struct EdgeListStoragePolicy {};

template <typename Graph, typename Edge>
struct EdgeListStoragePolicy<Graph, Edge, Dynamic> {
    void add_node_to_representation_() {}
    void remove_node_from_representation_(const NodeIdx a) {
        Size removed_edges = static_cast<Graph*>(this)->degree(a);
        std::erase_if(static_cast<Graph*>(this)->edge_list_, [&] (const auto & c) {
            return a == c.first.first || a == c.first.second;});

        for (auto & edge: static_cast<Graph*>(this)->edge_list_) {
            if (edge.first.first > a || edge.first.second > a) {
                auto edge_to_move =
                    static_cast<Graph*>(this)->edge_list_.extract(edge.first);
                if (edge_to_move.key().first > a) edge_to_move.key().first -= 1;
                if (edge_to_move.key().second > a) edge_to_move.key().second -= 1;
                static_cast<Graph*>(this)->edge_list_.insert(std::move(edge_to_move));
            }
        }
        static_cast<Graph*>(this)->number_of_edges_ -= removed_edges;
    }
};

template <typename Graph, typename Edge, IsDirectionalityTrait Directionality>
struct EdgeListDirectionalityPolicy {};

template <typename Graph, typename Edge>
struct EdgeListDirectionalityPolicy<Graph, Edge, Undirected> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        EdgeIdx ordered = order_edge_idx(std::make_pair(source, dest));
        Bool success = static_cast<Graph*>(this)->add_edge_to_inner_container_(ordered, edge);
        static_cast<Graph*>(this)->number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        EdgeIdx ordered = order_edge_idx(std::make_pair(source, dest));
        Bool success = static_cast<Graph*>(this)->remove_edge_from_inner_container(ordered, edge);
        static_cast<Graph*>(this)->number_of_edges_ -= success;
    }

    Size degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

protected:
    static Bool contains_neighbour_(NodeIdx node, EdgeIdx edge) {
        return node == edge.first || node == edge.second;
    }

    EdgeIdx order_edge_ (const EdgeIdx& idx) {
        return order_edge_idx(idx);
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return it > it2 ? 0 : static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge>
struct EdgeListDirectionalityPolicy<Graph, Edge, Directed> {
    void add_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->add_edge_to_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph&>(*this).number_of_edges_ += success;
    }
    void remove_edge(const NodeIdx& source, const NodeIdx& dest, Edge edge = Edge()) {
        Bool success = static_cast<Graph*>(this)->remove_edge_from_inner_container_(std::make_pair(source, dest), edge);
        static_cast<Graph&>(*this).number_of_edges_ -= success;
    }

    Size out_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(n, i);
        }
        return deg;
    }

    Size in_degree(NodeIdx n) {
        Size deg = 0;
        for (auto i = 0; i < static_cast<Graph*>(this)->number_of_nodes(); i++) {
            deg += static_cast<Graph*>(this)->count(i, n);
        }
        return deg;
    }

    Size degree(NodeIdx n) {
        return in_degree(n)+ out_degree(n)-static_cast<Graph*>(this)->count(n, n);
    }

protected:
    static Bool contains_neighbour_(NodeIdx node, EdgeIdx edge) {
        return node == edge.first;
    }

    EdgeIdx order_edge_ (const EdgeIdx& idx) {
        return idx;
    }

    Size num_of_edges_ (std::vector<NodeIdx> n) {
        return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
            [&](auto& it) { return std::transform_reduce(n.begin(), n.end(), 0, std::plus<>(),
                [&](auto& it2) { return static_cast<Graph*>(this)->count(it, it2); }); });
    }
};

template <typename Graph, typename Edge, IsConnectivityTrait Connectivity>
struct EdgeListConnectivityPolicy {};

template <typename Graph, typename Edge>
struct EdgeListConnectivityPolicy<Graph, Edge, Simple> {

  protected:
    Bool add_edge_to_inner_container_(const EdgeIdx& idx, Edge& edge) {
        Bool ret = !static_cast<Graph*>(this)->edge_list_.contains(idx);
        static_cast<Graph*>(this)->edge_list_[idx] = edge;
        return ret;
    }
    Bool remove_edge_from_inner_container_(const EdgeIdx& idx, ...) {
        Bool ret = static_cast<Graph*>(this)->edge_list_.contains(idx);
        static_cast<Graph*>(this)->edge_list_.erase(idx);
        return ret;
    }

  public:
    Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<Graph*>(this)->edge_list_.at(ordered);
    }
    const Edge& get_edge(const NodeIdx& source, const NodeIdx& dest) const {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<const Graph*>(this)->edge_list_.at(ordered);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<const Graph*>(this)->edge_list_.contains(ordered);
    }
};

template <typename Graph, typename Edge>
struct EdgeListConnectivityPolicy<Graph, Edge, Multi> {
  protected:
    Bool add_edge_to_inner_container_(const EdgeIdx& idx, Edge edge = Edge()) {
        static_cast<Graph*>(this)->edge_list_[idx].push_back(edge);
        return true;
    }
    Bool remove_edge_from_inner_container_(const EdgeIdx& idx,
                                           Edge edge = Edge()) {
        for (auto const& iter : static_cast<Graph*>(this)->edge_list_.at(idx)) {
            if ((*iter) == edge) {
                static_cast<Graph*>(this)->edge_list_.at(idx).erase(iter);
                return true;
            }
        }
        return false;
    }
  public:
    Edge& get_edges(const NodeIdx& source, const NodeIdx& dest) {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<Graph*>(this)->edge_list_.at(ordered);
    }
    const Edge& get_edges(const NodeIdx& source, const NodeIdx& dest) const {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<const Graph*>(this)->edge_list_.at(ordered);
    }

    Size count(const NodeIdx& source, const NodeIdx& dest) {
        EdgeIdx ordered = static_cast<Graph*>(this)->order_edge_(std::make_pair(source, dest));
        return static_cast<Graph*>(this)->edge_list_.contains(ordered) ? static_cast<Graph*>(this)->edge_list_.at(ordered).size() : 0;
    }
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, IsStorageTrait Storage,
          IsDirectionalityTrait Directionality,
          IsConnectivityTrait Connectivity>
class EdgeList
    : public EdgeListStoragePolicy<Graph, Edge, Storage>,
      public EdgeListDirectionalityPolicy<Graph, Edge, Directionality>,
      public EdgeListConnectivityPolicy<Graph, Edge, Connectivity>,
      public IteratorPolicy<Graph, Node, Edge> {
    using StoragePolicy = EdgeListStoragePolicy<Graph, Edge, Storage>;
    using DirectionalityPolicy =
        EdgeListDirectionalityPolicy<Graph, Edge, Directionality>;
    using ConnectivityPolicy =
        EdgeListConnectivityPolicy<Graph, Edge, Connectivity>;
    friend StoragePolicy;
    friend DirectionalityPolicy;
    friend ConnectivityPolicy;

  public:
    using EdgeListContainer =
        std::map<EdgeIdx, typename Connectivity::template InnerContainer<Edge>>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;

    explicit EdgeList(Size _ = 0) : number_of_edges_(0) {}

    const Size& number_of_edges() const { return number_of_edges_; }
    template<typename... Args>
    Size number_of_edges (NodeIdx first, Args... nodes) {
        return static_cast<Graph*>(this)->num_of_edges_({first, nodes...});
    }
    EdgeListContainer& edge_list() { return edge_list_; }
    const EdgeListContainer& edge_list() const { return edge_list_; }

    String representation_to_string(const String col_delim = " | ",
                                    const String iter_delim = "\n") {
        std::stringstream ss;

        Size col_width = 0;
        for (auto iter : edge_list_) {
            col_width = std::max(col_width, display(iter.first).size());
        }
        for (auto iter : edge_list_) {
            ss << std::setw(col_width) << std::left << display(iter.first);
            ss << col_delim;
            ss << display(iter.second);
            ss << iter_delim;
        }
        return ss.str().substr(0, ss.str().size() - iter_delim.size());
    }

    template<IsIteratorTrait T>
    struct Iterator {};

    template<>
    struct Iterator<Neighbour> : public IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename EdgeListContainer::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Neighbour>, typename EdgeListContainer::iterator, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx node;
        
        Iterator<Neighbour>(Graph *g, NodeIdx node, EdgeListContainer::iterator it) : SuperIterator{g, it}, node{node} {
            while (this->it != g->edge_list().end() && !EdgeList::contains_neighbour_(node, this->it->first)) { this->it++; }
        }
        
        const Node &operator *() const {
            return g->node(it->first.first == node ? it->first.second : it->first.first);
        }
        
        Iterator<Neighbour> &operator++() {
            while (++it != g->edge_list().end() && !EdgeList::contains_neighbour_(node, it->first));
            return *this;
        }

        Bool operator==(const Iterator<Neighbour> &other) {
            return g == other.g && it == other.it && node == other.node;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first.first == node ? it->first.second : it->first.first);
        }
    };

    template<>
    struct Iterator<Adjacent> : public IteratorPolicy::template SuperIterator<Iterator<Adjacent>, typename EdgeListContainer::iterator, Node> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<Adjacent>, typename EdgeListContainer::iterator, Node>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        NodeIdx node;
        
        Iterator<Adjacent>(Graph *g, NodeIdx node, EdgeListContainer::iterator it) : SuperIterator{g, it}, node{node} {
            while (this->it != g->edge_list().end() && node != this->it->first.first && node != this->it->first.second) { this->it++; }
        }
        
        const Node &operator *() const {
            return g->node(it->first.first == node ? it->first.second : it->first.first);
        }
        
        Iterator<Adjacent> &operator++() {
            while (++it != g->edge_list().end() && node != it->first.first && node != it->first.second);
            return *this;
        }

        Bool operator==(const Iterator<Adjacent> &other) {
            return g == other.g && it == other.it && node == other.node;
        }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first.first == node ? it->first.second : it->first.first);
        }
    };


    std::pair<Iterator<Neighbour>, Iterator<Neighbour>> get_neighbours(NodeIdx node) {
        return std::make_pair(
            Iterator<Neighbour>(static_cast<Graph*>(this), node, edge_list_.begin()), 
            Iterator<Neighbour>(static_cast<Graph*>(this), node, edge_list_.end())
        );
    }

    std::pair<Iterator<Adjacent>, Iterator<Adjacent>> get_adjacents(NodeIdx node) {
        return std::make_pair(
            Iterator<Adjacent>(static_cast<Graph*>(this), node, edge_list_.begin()), 
            Iterator<Adjacent>(static_cast<Graph*>(this), node, edge_list_.end())
        );
    }

    template<>
    struct Iterator<EdgeIterator> : public IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename EdgeListContainer::iterator, typename Connectivity::template InnerContainer<Edge>> {
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator<EdgeIterator>, typename EdgeListContainer::iterator, typename Connectivity::template InnerContainer<Edge>>;
        using iterator_category = std::forward_iterator_tag;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;

        Iterator<EdgeIterator>(Graph *g, typename EdgeListContainer::iterator it) : SuperIterator{g, it} {}
        
        const typename Connectivity::template InnerContainer<Edge> &operator *() const {
            return it->second;
        }
        
        Iterator<EdgeIterator> &operator++() {
            ++it;
            return *this;
        }

        typename IteratorPolicy::template Iterator<Basic> first () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first.first);
        }

        typename IteratorPolicy::template Iterator<Basic> second () {
            return typename IteratorPolicy::template Iterator<Basic>(g, it->first.second);
        }

        const Edge &edge () const {
            return it->second;
        }
    };

    std::pair<Iterator<EdgeIterator>, Iterator<EdgeIterator>> get_edges() {
        return std::make_pair(
            Iterator<EdgeIterator>(static_cast<Graph*>(this), edge_list_.begin()), 
            Iterator<EdgeIterator>(static_cast<Graph*>(this), edge_list_.end())
        );
    }

  protected:
    Size number_of_edges_;
    EdgeListContainer edge_list_;
};

} // namespace Arachne

#endif // EDGE_LIST_POLICY_HPP
</file>

<file path="EdgeStoragePolicy.hpp">
#ifndef EDGE_STORAGE_POLICY_HPP
#define EDGE_STORAGE_POLICY_HPP

namespace Arachne {} // namespace Arachne

#endif // EDGE_STORAGE_POLICY_HPP
</file>

<file path="graph_factories.hpp">
#ifndef ARACHNE_GRAPH_FACTORIES_HPP
#define ARACHNE_GRAPH_FACTORIES_HPP

#include "Graph.hpp"
#include "Traits.hpp"
#include "Types.hpp"

namespace Arachne {} // namespace Arachne

#endif // ARACHNE_GRAPH_FACTORIES_HPP
</file>

<file path="graph_utilities.hpp">
#ifndef GRAPH_UTILITIES_HPP
#define GRAPH_UTILITIES_HPP

#include "Types.hpp"
#include "real.hpp"

namespace Arachne {

// Reverses order of edge index (a,b) -> (b,a)
inline EdgeIdx reverse_edge_idx(const EdgeIdx& idx) {
    return std::make_pair(idx.second, idx.first);
}

// Returns the given edge index in order of smallest to largest,
// (a,b) -> (min(a,b),max(a,b))
inline EdgeIdx order_edge_idx(const EdgeIdx& idx) {
    if (idx.first > idx.second) {
        return reverse_edge_idx(idx);
    }
    return idx;
}

template <typename Container, typename T>
inline typename Container::const_iterator find(const Container& container,
                                               const T& value) {
    for (auto it = container.begin(); it != container.end(); it++) {
        if ((*it) == value) {
            return it;
        }
    }
    return container.cend();
}

template <typename Container>
inline typename Container::const_iterator find(const Container& container,
                                               const Real value) {
    for (auto it = container.begin(); it != container.end(); it++) {
        if (real_eq((*it), value)) {
            return it;
        }
    }
    return container.cend();
}

}; // namespace Arachne

#endif // GRAPH_UTILITIES_HPP
</file>

<file path="Graph.hpp">
#ifndef ARACHNE_GRAPH_HPP
#define ARACHNE_GRAPH_HPP

#include <optional>
#include <queue>

#include "EdgeListPolicy.hpp"
#include "AdjacencyListPolicy.hpp"
#include "AdjacencyMatrixPolicy.hpp"
#include "CompressedFormatPolicy.hpp"
#include "NodeStoragePolicy.hpp"
#include "Parameters.hpp"
#include "Traits.hpp"
#include "Types.hpp"

#define ITER_PARAM_LIST IteratorParameters<P...>

namespace Arachne {

template <Size N, 
          IsParameters ParameterList = Parameters<>,
          template <Size, typename...> typename RepresentationPolicy = EdgeList>
class Graph
    : public RepresentationPolicy<
          N, 
          Graph<N, ParameterList, RepresentationPolicy>,
          typename ParameterList::NodeData,
          typename ParameterList::EdgeData,
          typename ParameterList::Storage,
          typename ParameterList::Directionality,
          typename ParameterList::Connectivity>,
      public NodePolicy<N, Graph<N, ParameterList, RepresentationPolicy>,
                        typename ParameterList::NodeData,
                        typename ParameterList::EdgeData,
                        typename ParameterList::Storage> {
    using Rep = RepresentationPolicy<
            N, Graph<N, ParameterList, RepresentationPolicy>,
            typename ParameterList::NodeData,
            typename ParameterList::EdgeData,
            typename ParameterList::Storage,
            typename ParameterList::Directionality,
            typename ParameterList::Connectivity>;
    using NodePol = NodePolicy<N, Graph<N, ParameterList, RepresentationPolicy>,
                        typename ParameterList::NodeData,
                        typename ParameterList::EdgeData,
                        typename ParameterList::Storage>;
    friend Rep;
    friend NodePol;
    friend IteratorPolicy<Graph, typename ParameterList::NodeData, typename ParameterList::EdgeData>;

  public:
    using IteratorPolicy = IteratorPolicy<Graph, typename ParameterList::NodeData, typename ParameterList::EdgeData>;
    using NodePol::initialize_node_container;
    using typename NodePol::NodeContainer;
    using NodePol::begin;
    using NodePol::end;
    
    explicit Graph() { initialize_node_container(); }
    explicit Graph(Size n) : Rep{n} {
        initialize_node_container(n);
    }
    explicit Graph(NodePol::NodeContainer& node_container) {
        initialize_node_container(node_container);
    }

    std::pair<typename Rep::template Iterator<Neighbour>, typename Rep::template Iterator<Neighbour>> get_neighbours(const NodePol::template Iterator<Basic> &it) {
        return Rep::get_neighbours(NodePol::nodeId(it));
    }

    template <typename Iterator, IsIteratorParameters ItParamList>
    struct BasicSearchIterator : public IteratorPolicy::template SuperIterator<Iterator, typename NodePol::template Iterator<Basic>, typename ParameterList::NodeData> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using NeighbourIterator = Rep::template Iterator<Neighbour>;
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator, typename NodePol::template Iterator<Basic>, typename ParameterList::NodeData>;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator->;

        using ListElement = std::pair<BasicIterator, std::optional<std::pair<NeighbourIterator, NeighbourIterator>>>;

        std::list<ListElement> frontier;
        typename ItParamList::SetType &visited;
        const Bool is_ext;

        inline BasicSearchIterator(BasicIterator node) : SuperIterator{node.g, IsCompleteTraversal<typename ItParamList::TraversalTrait> ? node.g->NodePol::template begin<Basic>() : node.g->NodePol::template end<Basic>()}, visited{*(new ItParamList::SetType(node.g->number_of_nodes()))}, is_ext{false} {
            // must be initialized to already have visited root node, for dereference
            visited.insert(node);
            frontier.push_front(ListElement(node, std::nullopt));
        }

        BasicSearchIterator(BasicIterator node, typename ItParamList::SetType &S) : SuperIterator{node.g, IsCompleteTraversal<typename ItParamList::TraversalTrait> ? node.g->NodePol::template begin<Basic>() : node.g->NodePol::template end<Basic>()}, visited{S}, is_ext{true} {
            // skip to next unvisited node in graph
            if (visited.insert(node).second) {
                frontier.push_front(ListElement(node, std::nullopt));
                return;
            }
            while (it != g->template end<Basic>()) {
                BasicIterator next = it++;
                if (visited.insert(next).second) {
                    frontier.push_front(ListElement(next, std::nullopt));
                    return;
                }
            }
        }

        inline BasicSearchIterator() : SuperIterator{nullptr, BasicIterator(nullptr, 0)}, visited{*(new ItParamList::SetType())}, is_ext{false} {}

        BasicSearchIterator(typename ItParamList::SetType &S) : SuperIterator{nullptr, BasicIterator(nullptr, 0)}, visited{S}, is_ext{true} {}

        BasicSearchIterator(const BasicSearchIterator<Iterator, ItParamList> &other) : SuperIterator{other.g, other.it}, visited{other.is_ext? other.visited : *(new ItParamList::SetType(other.visited))}, is_ext{other.is_ext} {}

        void clear_frontier() {
            frontier.clear();
        }

        virtual void pop() = 0;

        virtual Bool is_postorder() = 0;

        Iterator &operator++() {
            if (is_postorder()) pop();
            while (true) {
                // skip to next component if component is fully explored
                if (frontier.empty()) {
                    while (it != g->NodePol::template end<Basic>()) {
                        BasicIterator next = std::same_as<typename ItParamList::PruningTrait, MultiplePathPruning> ? it++ : it;
                        if (visited.insert(next).second || std::same_as<typename ItParamList::PruningTrait, NoPathPruning>) {
                            frontier.push_front(ListElement(next, std::nullopt));
                            if (!is_postorder()) return *static_cast<Iterator*>(this);
                            else break;
                        }
                    }
                    if (it == g->NodePol::template end<Basic>()) return *static_cast<Iterator*>(this);
                }

                const BasicIterator &current = frontier.back().first;
                auto &current_posn = frontier.back().second;


                if (!current_posn) {
                    current_posn.emplace(g->get_neighbours(current));
                } else if (current_posn->first != current_posn->second) {
                    current_posn->first++;
                } 
                if (current_posn->first == current_posn->second) {
                    if (is_postorder()) return *static_cast<Iterator*>(this);
                    pop();
                    continue;
                }

                if (visited.insert((BasicIterator)(current_posn->first)).second || std::same_as<typename ItParamList::PruningTrait, NoPathPruning>) {
                    frontier.push_front(ListElement(current_posn->first, std::nullopt));
                    if (!is_postorder()) return *static_cast<Iterator*>(this);
                }
            }
        }

        Bool operator==(const Iterator &x) const {
            return frontier == x.frontier;
        }

        const ParameterList::NodeData & operator*() const { return *(frontier.front().first); }

        operator typename IteratorPolicy::template Iterator<Basic>() const {
            return typename IteratorPolicy::template Iterator<Basic>(frontier.front().first);
        }

        ~BasicSearchIterator() {
            if(!is_ext) delete &visited;
        }
    };

    template <typename Iterator, IsIteratorParameters ItParamList>
    struct OrderedSearchIterator: public IteratorPolicy::template SuperIterator<Iterator, std::pair<typename NodePol::template Iterator<Basic>, double>, typename ParameterList::NodeData> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using NeighbourIterator = Rep::template Iterator<Neighbour>;
        using QueueElement = std::pair<BasicIterator, double>;
        using SuperIterator = IteratorPolicy::template SuperIterator<Iterator, QueueElement, typename ParameterList::NodeData>;

        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator->;

        std::function<Real(const BasicIterator &, const BasicIterator &)> edge_weights;
        std::priority_queue<QueueElement,
                            std::vector<QueueElement>,
                            std::function<Bool(const QueueElement &, const QueueElement &)>>
                            frontier;
        typename ItParamList::SetType &visited;
        const Bool is_ext;

        OrderedSearchIterator(const BasicIterator start, std::function<Real(const BasicIterator &, Real)> &&heuristic, std::function<Real(const BasicIterator &, const BasicIterator &)> &&edge_weights):
            SuperIterator{start.g, std::make_pair(start, 0)},
            edge_weights{std::move(edge_weights)},
            frontier{[heuristic](const QueueElement &a, const QueueElement &b) { return heuristic(a.first, a.second) > heuristic(b.first, b.second); }},
            visited{*(new ItParamList::SetType(start.g->number_of_nodes()))},
            is_ext{false} {
            visited.insert(it.first);
            expand();
        }

        OrderedSearchIterator(const BasicIterator start, typename ItParamList::SetType &S, std::function<Real(const BasicIterator &, Real)> &&heuristic, std::function<Real(const BasicIterator &, const BasicIterator &)> &&edge_weights):
            SuperIterator{start.g, std::make_pair(start, 0)},
            edge_weights{std::move(edge_weights)},
            frontier{[heuristic](const QueueElement &a, const QueueElement &b) { return heuristic(a.first, a.second) > heuristic(b.first, b.second); }},
            visited{*(new ItParamList::SetType(start.g->number_of_nodes()))},
            is_ext{false} {
            if (std::same_as<typename ItParamList::PruningTrait, NoPathPruning> || visited.insert(it.first).second) expand();
        }

        inline OrderedSearchIterator(const BasicIterator end) : SuperIterator{end.g, std::make_pair(end, 0)}, visited{*(new ItParamList::SetType())}, is_ext{false} {}

        OrderedSearchIterator(const BasicIterator end, typename ItParamList::SetType &S) : SuperIterator{end.g, std::make_pair(end, 0)}, visited{S}, is_ext{true} {}

         OrderedSearchIterator (const OrderedSearchIterator &other) : SuperIterator{other.g, other.it}, edge_weights{other.edge_weights},
                            visited{other.is_ext? other.visited : *(new ItParamList::SetType(other.visited))}, is_ext{other.is_ext}, frontier{other.frontier} {}

        void expand() {
            auto neighbours = g->get_neighbours(it.first);
            for (; neighbours.first != neighbours.second; (neighbours.first)++) {
                frontier.push(std::make_pair(neighbours.first, it.second + edge_weights(it.first, neighbours.first)));
            }
        }

        ~OrderedSearchIterator() {
            if(!is_ext) delete &visited;
        }

        Bool operator==(const Iterator &x) const {
            return it.first == x.it.first;
        }

        const ParameterList::NodeData & operator*() const { return *(it.first); }

        Iterator& operator++() {
            do {
                if (frontier.empty()) {
                    it.first = g->template end<Basic>();
                    return *static_cast<Iterator*>(this);
                }
                it = frontier.top();
                frontier.pop();
            } while (std::same_as<typename ItParamList::PruningTrait, MultiplePathPruning> && !visited.insert(it.first).second);

            expand();
            return *static_cast<Iterator*>(this);
        }

        operator BasicIterator() const {
            return it.first;
        }
    };

    template<IsIteratorTrait T, IsIteratorParameter... P>
    struct Iterator {};

    template <IsIteratorParameter... P>
    struct Iterator<PreOrder, P...> : public BasicSearchIterator<Iterator<PreOrder, P...>, ITER_PARAM_LIST> {
        using BasicSearchIterator<Iterator<PreOrder, P...>, ITER_PARAM_LIST>::BasicSearchIterator;

        void pop() {
            this->frontier.pop_front();
        }

        Bool is_postorder() {
            return false;
        }
    };

    template <IsIteratorParameter... P>
    struct Iterator<PostOrder, P...> : public BasicSearchIterator<Iterator<PostOrder, P...>, ITER_PARAM_LIST> {
        using BasicSearchIterator = BasicSearchIterator<Iterator<PostOrder, P...>, ITER_PARAM_LIST>;
        using BasicIterator = NodePol::template Iterator<Basic>;

        inline Iterator(BasicIterator node) : BasicSearchIterator{node} {
            // must point to proper node for dereference
            // if given end, does nothing
            this->frontier.push_front(this->frontier.front());
            ++*this;
        }

        inline Iterator(BasicIterator node, ITER_PARAM_LIST::SetType &S) : BasicSearchIterator{node, S} {
            this->frontier.push_front(this->frontier.front());
            ++*this;
        }

        inline Iterator() : BasicSearchIterator{} {}

        inline Iterator(ITER_PARAM_LIST::SetType &S) : BasicSearchIterator{S} {}

        void pop() {
            this->frontier.pop_front();
        }

        Bool is_postorder() {
            return true;
        }

    };

    template <IsIteratorParameter... P>
    struct Iterator<InOrder, P...> : public BasicSearchIterator<Iterator<InOrder, P...>, ITER_PARAM_LIST> {
        using BasicSearchIterator<Iterator<InOrder, P...>, ITER_PARAM_LIST>::BasicSearchIterator;

        void pop() {
            this->frontier.pop_back();
        }

        Bool is_postorder() {
            return false;
        }
    };

    template <IsIteratorParameter... P>
    struct Iterator<BestFirst, P...>: public OrderedSearchIterator<Iterator<BestFirst, P...>, ITER_PARAM_LIST> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using OrderedSearchIterator = OrderedSearchIterator<Iterator<BestFirst, P...>, ITER_PARAM_LIST>;

        Iterator<BestFirst, P...>(const BasicIterator start, std::function<Real(const BasicIterator &)> heuristic):
            OrderedSearchIterator{start, [heuristic](const BasicIterator &it, Real cost){ return heuristic(it); }, [](const BasicIterator &a, const BasicIterator &b){ return 0; }} {}

        Iterator<BestFirst, P...>(const BasicIterator end): OrderedSearchIterator{end} {}
    };

    template <IsIteratorParameter... P>
    struct Iterator<AStar, P...>: public OrderedSearchIterator<Iterator<AStar, P...>, ITER_PARAM_LIST> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using OrderedSearchIterator = OrderedSearchIterator<Iterator<AStar, P...>, ITER_PARAM_LIST>;

        Iterator<AStar, P...>(const BasicIterator start, std::function<Real(const BasicIterator &)> heuristic, std::function<Real(const BasicIterator &, const BasicIterator &)> edge_weights):
            OrderedSearchIterator{start, [heuristic](const BasicIterator &it, Real cost){ return heuristic(it) + cost; }, [edge_weights](const BasicIterator &a, const BasicIterator &b) { return edge_weights(a, b); }} {}

        Iterator<AStar, P...>(const BasicIterator end): OrderedSearchIterator{end} {}
    };

    template <IsIteratorParameter... P>
    struct Iterator<Dijkstra, P...>: public OrderedSearchIterator<Iterator<Dijkstra, P...>, ITER_PARAM_LIST> {
        using BasicIterator = NodePol::template Iterator<Basic>;
        using OrderedSearchIterator = OrderedSearchIterator<Iterator<Dijkstra, P...>, ITER_PARAM_LIST>;

        Iterator<Dijkstra, P...>(const BasicIterator start, std::function<Real(const BasicIterator &, const BasicIterator &)> edge_weights):
            OrderedSearchIterator{start, [](const BasicIterator &it, Real cost){ return cost; }, [edge_weights](const BasicIterator &a, const BasicIterator &b) { return edge_weights(a, b); }} {}

        Iterator<Dijkstra, P...>(const BasicIterator end): OrderedSearchIterator{end} {}
    };

    template <IsSearchTrait Trait, IsIteratorParameter... P>
    inline Iterator<Trait, P...> begin(typename NodePol::template Iterator<Basic> it) {
        return Iterator<Trait, P...>(it);
    }

    template <IsSearchTrait Trait, IsIteratorParameter... P>
    inline Iterator<Trait, P...> begin() {
        return begin<Trait, P...>(this->begin<Basic>());
    }

    template <IsSearchTrait Trait, IsIteratorParameter... P>
    inline Iterator<Trait, P...> end() {
        return Iterator<Trait, P...>();
    }

    template <IsSearchTrait Trait, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<Trait, SetType, P...> begin(typename NodePol::template Iterator<Basic> it, SetType &S) {
        return Iterator<Trait, SetType, P...>(it, S);
    }

    template <IsSearchTrait Trait, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<Trait, SetType, P...> begin(SetType &S) {
        return begin<Trait, SetType, P...>(this->begin<Basic>(), S);
    }

    template <IsSearchTrait Trait, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<Trait, SetType, P...> end(SetType &S) {
        return Iterator<Trait, SetType, P...>(S);
    }

    template <IsBestFirst B, IsIteratorParameter... P>
    inline Iterator<B, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic) {
        return Iterator<B, P...>(it, heuristic);
    }

    template <IsBestFirst B, IsIteratorParameter... P>
    inline Iterator<B, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic) {
        return begin<B, P...>(this->begin<Basic>(), heuristic);
    }

    template <IsBestFirst B, IsIteratorParameter... P>
    inline Iterator<B, P...> end() {
        return Iterator<B, P...>(this->end<Basic>());
    }

    template <IsBestFirst B, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<B, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, SetType &S) {
        return Iterator<B, P...>(it, heuristic, S);
    }

    template <IsBestFirst B, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<B, SetType, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, SetType &S) {
        return begin<B, SetType, P...>(this->begin<Basic>(), heuristic, S);
    }

    template <IsBestFirst B, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<B, SetType, P...> end(SetType &S) {
        return Iterator<B, SetType, P...>(this->end<Basic>(), S);
    }

    template <IsAStar A, IsIteratorParameter... P>
    inline Iterator<A, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights) {
        return Iterator<A, P...>(it, heuristic, edge_weights);
    }

    template <IsAStar A, IsIteratorParameter... P>
    inline Iterator<A, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights) {
        return begin<A, P...>(this->begin<Basic>(), heuristic, edge_weights);
    }

    template <IsAStar A, IsIteratorParameter... P>
    inline Iterator<A, P...> end() {
        return Iterator<A, P...>(this->end<Basic>());
    }

    template <IsAStar A, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<A, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights, SetType &S) {
        return Iterator<A, P...>(it, heuristic, edge_weights, S);
    }

    template <IsAStar A, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<A, SetType, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &)> &heuristic, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights, SetType &S) {
        return begin<A, SetType, P...>(this->begin<Basic>(), heuristic, edge_weights, S);
    }

    template <IsAStar A, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<A, SetType, P...> end(SetType &S) {
        return Iterator<A, SetType, P...>(this->end<Basic>(), S);
    }

    template <IsDijkstra D, IsIteratorParameter... P>
    inline Iterator<D, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights) {
        return Iterator<D, P...>(it, edge_weights);
    }

    template <IsDijkstra D, IsIteratorParameter... P>
    inline Iterator<D, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights) {
        return begin<D, P...>(this->begin<Basic>(), edge_weights);
    }

    template <IsDijkstra D, IsIteratorParameter... P>
    inline Iterator<D, P...> end() {
        return Iterator<D, P...>(this->end<Basic>());
    }

    template <IsDijkstra D, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<D, P...> begin(typename NodePol::template Iterator<Basic> it, const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights, SetType &S) {
        return Iterator<D, P...>(it, edge_weights, S);
    }

    template <IsDijkstra D, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<D, SetType, P...> begin(const std::function<Real(const typename NodePol::template Iterator<Basic> &, const typename NodePol::template Iterator<Basic> &)> &edge_weights, SetType &S) {
        return begin<D, SetType, P...>(this->begin<Basic>(), edge_weights, S);
    }

    template <IsDijkstra D, IsSetType SetType, IsIteratorParameter... P>
    inline Iterator<D, SetType, P...> end(SetType &S) {
        return Iterator<D, SetType, P...>(this->end<Basic>(), S);
    }

};

} // namespace Arachne

#endif // ARACHNE_GRAPH_HPP
</file>

<file path="GraphColor.hpp">
#ifndef ARACHNE_GRAPHCOLOR_HPP
#define ARACHNE_GRAPHCOLOR_HPP

#include <set>
#include <functional>
#include "Traits.hpp"
#include "BasicBitMap.hpp"
#include "ArachneData.hpp"

namespace Arachne {

struct Backtracking {
    static std::string print() {
        return "Backtracking";
    }
};
struct DSatur {
    static std::string print() {
        return "DSatur";
    }
};
struct Greedy {
    static std::string print() {
        return "Greedy";
    }
};
struct GreedySorted {
    static std::string print() {
        return "GreedySorted";
    }
};
struct WelshPowell {
    static std::string print() {
        return "WelshPowell";
    }
};
struct GreedyISet {
    static std::string print() {
        return "GreedyISet";
    }
};
struct RLF {
    static std::string print() {
        return "RLF";
    }
};

struct DSaturCompare {
    std::vector<Size> &saturation;
    std::vector<Size> &uncolored_degree;

    bool operator()(const NodeIdx &a, const NodeIdx &b) const {
        return saturation[a] < saturation[b] || (saturation[a] == saturation[b] && (uncolored_degree[a] < uncolored_degree[b] || (uncolored_degree[a] == uncolored_degree[b] && a < b)));
    }
};

struct WelshPowellCompare {
    std::vector<Size> &degree;

    bool operator()(const NodeIdx &a, const NodeIdx &b) const {
        return degree[a] < degree[b] || (degree[a] == degree[b] && a < b);
    }
};

struct RLFCompare {
    std::vector<Size> &degree_x;
    std::vector<Size> &degree_y;

    bool operator()(const NodeIdx &a, const NodeIdx &b) const {
        return degree_y[a] < degree_y[b] || (degree_y[a] == degree_y[b] && (degree_x[a] > degree_x[b] || (degree_x[a] == degree_x[b] && a < b)));
    }
};

template <typename Graph>
BasicBitMap get_occupied_colors(const typename Graph::IteratorPolicy::template Iterator<Basic> &node, std::vector<int> &color_map, int num_colors) {
    BasicBitMap colors(num_colors);
    auto adjacents = node.g->get_adjacents(node);
    for (auto it = adjacents.first; it != adjacents.second; ++it) {
        int color = color_map[(typename Graph::IteratorPolicy::template Iterator<Basic>) it];
        if (color >= 0) {
            colors.insert(color);
        }
    }
    return colors;
}

template <typename Graph>
BasicBitMap get_occupied_colors(const typename Graph::IteratorPolicy::template Iterator<Basic> &node, int num_colors) {
    BasicBitMap colors(num_colors);
    auto adjacents = node.g->get_adjacents(node);
    for (auto it = adjacents.first; it != adjacents.second; ++it) {
        int color = node->color;
        if (color >= 0) {
            colors.insert(color);
        }
    }
    return colors;
}

// This function has exponential runtime (with state space pruning, so in practice it should be much faster).
// It also has O(n) memory.
template <typename Graph>
void color_backtracking_rec(Graph &g, typename Graph::IteratorPolicy::template Iterator<Basic> node, std::vector<int> &color_map, int &min_colors, std::vector<int> &best_colors, int num_colors) { 
    if (node == g.number_of_nodes()) {
        best_colors = color_map;
        min_colors = num_colors;
        return;
    }

    BasicBitMap occupied_colors = get_occupied_colors<Graph>(node, color_map, num_colors);
    for (int color = 0; color < num_colors; color++) {
        if (num_colors >= min_colors) break;

        if (occupied_colors.contains(color)) {
            continue;
        }

        color_map[node] = color;
        color_backtracking_rec(g, node + 1ul, color_map, min_colors, best_colors, num_colors);
        color_map[node] = -1;
    }

    if (num_colors + 1 < min_colors) {
        color_map[node] = num_colors;
        color_backtracking_rec(g, node + 1ul, color_map, min_colors, best_colors, num_colors + 1);
        color_map[node] = -1;
    }
}

template <typename Graph, typename Compare>
requires HasColor<typename Graph::NodeType>
int color_pq(Graph &g,
             Compare cmp,
             std::function<bool(std::set<NodeIdx, Compare> &, typename Graph::IteratorPolicy::template Iterator<Basic>, typename Graph::IteratorPolicy::template Iterator<Basic>, const BasicBitMap &)> update_adj) {
    std::set<NodeIdx, Compare> pq(cmp);
    std::vector<BasicBitMap> adjacent_colors(g.number_of_nodes(), BasicBitMap(g.number_of_nodes()));

    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        node->color = -1;
        assert(pq.insert(node).second);
    }

    int num_colors = 0;
    while (!pq.empty()) {
        // get node with highest val from pq
        auto node_ptr = pq.begin();
        auto node = typename Graph::IteratorPolicy::template Iterator<Basic>(&g, *node_ptr);
        pq.erase(node_ptr);

        // get lowest available color and assign it to node
        BasicBitMap &occupied_colors = adjacent_colors[node];
        int avail_color = 0;
        for (int color_lim = num_colors; avail_color <= color_lim; avail_color++) {
            if (avail_color == color_lim) {
                num_colors++;
            }
            if (!occupied_colors.contains(avail_color)) {
                break;
            }
        }
        node->color = avail_color;

        // reassign values to adjacent nodes in priority queue
        auto adjacents = g.get_adjacents(node);
        BasicBitMap visited(g.number_of_nodes());
        for (auto it = adjacents.first; it != adjacents.second; ++it) {
            auto adj = (typename Graph::IteratorPolicy::template Iterator<Basic>) it;
            if (adj->color != -1 || visited.contains(adj)) continue;
            visited.insert(adj);

            // reassign values to adjacent node
            adjacent_colors[adj].insert(avail_color);
            update_adj(pq, node, adj, adjacent_colors[adj]);
        }
    }

    return num_colors;
}

template <typename T, typename Graph>
requires std::same_as<Backtracking, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    std::vector<int> storage(g.number_of_nodes(), -1);
    std::vector<int> best_colors(storage);
    int min_colors = g.number_of_nodes() + 1;

    color_backtracking_rec(g, g.template begin<Basic>(), storage, min_colors, best_colors, 0);

    for (auto it = g.template begin<Basic>(); it != g.template end<Basic>(); ++it) {
        it->color = best_colors[(NodeIdx) it];
    }

    return min_colors;
}

template <typename T, typename Graph>
requires std::same_as<DSatur, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    std::vector<Size> saturation(g.number_of_nodes(), 0);
    std::vector<Size> uncolored_degree(g.number_of_nodes(), 0);

    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        uncolored_degree[node] = g.degree(node);
    }

    return color_pq<Graph, DSaturCompare>(
        g, 
        DSaturCompare{saturation, uncolored_degree}, 
        [&saturation, &uncolored_degree](std::set<NodeIdx, DSaturCompare> &pq, auto node, auto adj, const BasicBitMap &adj_colored) {
            pq.erase(adj);
            saturation[adj] = adj_colored.size();
            uncolored_degree[adj] -= node.g->number_of_edges(node, adj);
            return pq.emplace(adj).second;
        }
    );
}

template <typename T, typename Graph>
requires std::same_as<Greedy, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    std::vector<BasicBitMap> adjacent_colors(g.number_of_nodes(), BasicBitMap(g.number_of_nodes()));
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        node->color = -1;
    }

    int num_colors = 0;
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        // get lowest available color and assign it to node
        BasicBitMap &occupied_colors = adjacent_colors[node];
        int avail_color = 0;
        for (int color_lim = num_colors; avail_color <= color_lim; avail_color++) {
            if (avail_color == color_lim) {
                num_colors++;
            }
            if (!occupied_colors.contains(avail_color)) {
                break;
            }
        }
        node->color = avail_color;

        // reassign values to adjacent nodes
        auto adjacents = g.get_adjacents(node);
        for (auto it = adjacents.first; it != adjacents.second; ++it) {
            auto adj = (typename Graph::IteratorPolicy::template Iterator<Basic>) it;
            if (adj->color != -1) continue;

            // reassign values to adjacent node
            adjacent_colors[adj].insert(avail_color);
        }
    }

    return num_colors;
}

template <typename T, typename Compare, typename Graph>
requires std::same_as<GreedySorted, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    return color_pq<Graph, Compare>(
        g,
        Compare(),
        [](auto pq, auto node, auto adj, auto adj_colored) {
            return true;
        }
    );
}

template <typename T, typename Graph>
requires std::same_as<WelshPowell, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    std::vector<Size> degree(g.number_of_nodes());
    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        degree[node] = g.degree(node);
    }
    return color_pq<Graph, WelshPowellCompare>(
        g, 
        WelshPowellCompare{degree}, 
        [](auto pq, auto node, auto adj, auto adj_colored) {
            return true;
        }
    );
}

template <typename T, typename Graph>
requires std::same_as<GreedyISet, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    int avail_color = 0;
    auto x = std::make_unique<BasicBitMap>(g.number_of_nodes(), true);
    auto y = std::make_unique<BasicBitMap>(g.number_of_nodes());

    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        node->color = -1;
    }

    while (!x->empty()) {
        for (NodeIdx u: *x) {
            auto node = typename Graph::IteratorPolicy::template Iterator<Basic>(&g, u);
            x->erase(u);
            node->color = avail_color;

            auto adjacents = g.get_adjacents(node);
            for (auto it = adjacents.first; it != adjacents.second; ++it) {
                auto adj = (typename Graph::IteratorPolicy::template Iterator<Basic>) it;
                if (adj->color != -1 || y->contains(adj)) continue;
                x->erase(adj);
                y->insert(adj);
            }
        }
        
        std::swap(x, y);

        avail_color++;
    }

    return avail_color;
}

template <typename T, typename Graph>
requires std::same_as<RLF, T>
&& HasColor<typename Graph::NodeType>
int color(Graph &g) {
    int avail_color = 0;
    std::vector<Size> degree_x(g.number_of_nodes());
    std::vector<Size> degree_y(g.number_of_nodes());
    auto x = std::make_unique<std::set<NodeIdx, RLFCompare>>(RLFCompare{degree_x, degree_y});
    auto y = std::make_unique<std::set<NodeIdx, RLFCompare>>(RLFCompare{degree_x, degree_y});

    for (auto node = g.template begin<Basic>(); node != g.template end<Basic>(); ++node) {
        node->color = -1;
        degree_x[node] = g.degree(node);
        degree_y[node] = 0;
        x->insert(node);
    }

    while (!x->empty()) {
        while (!x->empty()) {
            // get node with highest val from pq
            auto u_ptr = x->begin();
            auto u = typename Graph::IteratorPolicy::template Iterator<Basic>(&g, *u_ptr);
            x->erase(u_ptr);
            u->color = avail_color;

            auto adjacents = g.get_adjacents(u);
            for (auto i = adjacents.first; i != adjacents.second; ++i) {
                auto v = (typename Graph::IteratorPolicy::template Iterator<Basic>) i;
                if (v->color != -1 || y->contains(v)) continue;
                
                x->erase(v);

                degree_x[v] -= g.number_of_edges(u, v);
                degree_y[v] = 0;

                auto adjacents = g.get_adjacents(v);
                BasicBitMap visited(g.number_of_nodes());
                for (auto j = adjacents.first; j != adjacents.second; ++j) {
                    auto w = (typename Graph::IteratorPolicy::template Iterator<Basic>) j;
                    if (visited.contains(w)) continue;
                    visited.insert(w);

                    if (y->contains(w)) {
                        Size num_edges = g.number_of_edges(v, w);
                        y->erase(w);
                        degree_x[v] -= num_edges;
                        degree_x[w] -= num_edges;
                        degree_y[v] += num_edges;
                        degree_y[w] += num_edges;
                        y->insert(w);
                    }
                }
                y->insert(v);
            }
        }

        std::swap(x, y);

        avail_color++;
    }

    return avail_color;
}

} // namespace Arachne

#endif // ARACHNE_GRAPHCOLOR_HPP
</file>

<file path="GraphPartition.hpp">
#ifndef GRAPH_PARTITION_HPP
#define GRAPH_PARTITION_HPP

#include <kaHIP_interface.h>

#include "Graph.hpp"

namespace Arachne {

Bool check_partition (std::vector<int> &part, unsigned num_boxes, unsigned capacity) {
    std::vector<unsigned> checker;
    checker.resize(num_boxes);
    for (auto &i : part) {
        checker[i]++;
        if (checker[i] > capacity) {
            std::cerr << "Failed on " << i << std::endl;
            return false;
        }
    }
    return true;
}

template <typename Graph>
std::pair<std::vector<int>, int> partition (Graph graph, unsigned num_boxes, unsigned capacity) {
    int number_of_nodes = num_boxes*capacity;
    if (number_of_nodes < graph.number_of_nodes()) {
        std::cerr << "fatal: too many qubits in circuit to partition" << std::endl;
        throw 0;
    }
	int parts = num_boxes;
    int ncon = 1;

    std::vector<int> xadj;
    std::vector<int> adjncy;
    auto it = graph.template begin<Basic>();
    auto it_end = graph.template end<Basic>();
    for (; it != it_end; it++) {
        xadj.push_back(adjncy.size());
        for (auto it2 = graph.get_neighbours(it); it2.first != it2.second; (it2.first)++){
            adjncy.push_back(graph.nodeId(it2.first));
        }
    }
    for (auto i = graph.number_of_nodes(); i <= number_of_nodes; ++i) xadj.push_back(adjncy.size());

    std::vector<int> adjwgt;

    for (auto edge_it = graph.get_edges(); edge_it.first != edge_it.second; (edge_it.first)++) {
        adjwgt.push_back((edge_it.first)->weight);
    }

    std::vector<int> part(number_of_nodes);
    
    int objval; 
    double imbalance = 0.0;

    kaffpa(&number_of_nodes, NULL, xadj.data(), adjwgt.data(), adjncy.data(), &parts, &imbalance, false, 0, ECO, &objval, part.data());

    part.resize(graph.number_of_nodes());

    if (check_partition(part, num_boxes, capacity)) return std::make_pair(part, objval);

    for (auto i = 0; i < number_of_nodes; i++) {
        part[i] = i / capacity;
    }

    return std::make_pair(part, objval);
}


} // namespace Arachne


#endif // GRAPH_PARTITION_HPP
</file>

<file path="Heterogenous.hpp">
#ifndef HETEROGENOUS_HPP
#define HETEROGENOUS_HPP

#include <cstddef>
#include <type_traits>
#include <iterator>
#include <variant>
#include <iostream>
#include <type_traits>
#include <string>

namespace Heterogenous {

/*
 *  Helper used to check whether Type is present in the parameter pack arg,
 *  used in containers to catch errors in added types.
 */
template <typename Type, typename... arg>
struct is_present {
    static constexpr bool value = (std::is_same_v<Type,arg> || ...);
};

/*
 *  Helpers used to remove duplicate types from parameter packs. Code taken
 *  from "Angew is no longer proud of SO" at, 
 *
 *  https://stackoverflow.com/questions/55941964/how-to-filter-duplicate-types-from-tuple-c
 */
template <typename Pack, typename Type>
struct contains;

template <class Car, class...Cdr, class Type>
struct contains<std::variant<Car,Cdr...>,Type> : contains<std::variant<Cdr...>, Type>
{};

template <class... Cdr, class Type>
struct contains<std::variant<Type,Cdr...>,Type> : std::true_type
{};

template <class Type>
struct contains<std::variant<>, Type> : std::false_type
{};

template <class Out, class In>
struct filter;

template <class... Out, class InCar, class...InCdr>
struct filter<std::variant<Out...>,std::variant<InCar,InCdr...> >
{
    using type = typename std::conditional<
        contains<std::variant<Out...>, InCar>::value,
        typename filter<std::variant<Out...>, std::variant<InCdr...> >::type,
        typename filter<std::variant<Out...,InCar>, std::variant<InCdr...>>::type
    >::type;
};

template <class Out>
struct filter<Out,std::variant<> >
{
    using type = Out;
};

template <class T>
using without_duplicates = typename filter<std::variant<>, T>::type;

/*
 *  Key value pair for maps and dictionaries. In order for a KeyValue to be
 *  valid, std::less<key_t> must be defined.
 */
template <typename key_t, typename value_t>
struct KeyValue {
    key_t key;
    value_t value;
};

template <typename value_t>
struct KeyValue<std::string,value_t> {
    std::string key;
    value_t value;
};

template <typename key_t, typename value_t>
inline std::ostream& operator<<(std::ostream& os, const KeyValue<key_t,value_t>& kv) {
    os << kv.key << " " << kv.value;
    return os;
}

template <typename value_t>
KeyValue(std::string,value_t) -> KeyValue<std::string,value_t>;

template <typename order_iterator, typename map_t, typename val_t>
class Iterator {
    public:
        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using val_ref = val_t&;
        using val_ptr = val_t*;
        using key_ptr = key_t*;
        using map_ptr = map_t*;

        Iterator(order_iterator o_iter, map_ptr m_ptr) : o_iter_(o_iter), m_ptr_(m_ptr) {}
        
        val_ref operator*() const { 
            return m_ptr_->at(*o_iter_); 
        }   
        val_ptr operator->() { return &(m_ptr_->at(*o_iter_)); }

        Iterator& operator++() { 
            ++o_iter_; 
            return (*this); 
        }

        friend bool operator==(const Iterator& a, const Iterator& b) { return ((a.o_iter_==b.o_iter_) and (a.m_ptr_==b.m_ptr_));}
        friend bool operator!=(const Iterator& a, const Iterator& b) { return ((a.o_iter_!=b.o_iter_) or (a.m_ptr_!=b.m_ptr_));}

    private:
        order_iterator o_iter_;
        map_ptr m_ptr_;
};

/*
 *  A map of heterogenous types that is type safe.
 */
template <typename key_t, typename... Ts>
class UnorderedMap {
    public:
        using value_var = std::variant<Ts...>;
        using order_t = std::vector<key_t>;
        using map_t = std::unordered_map<key_t,value_var>;
        using iterator_t = Iterator<typename order_t::iterator, map_t, value_var>;
        template<typename... key_ts>
        explicit UnorderedMap(const key_ts&... keys) {
            (order_.push_back(keys),...);
            (map_.emplace(keys,std::variant<Ts...>(Ts())),...);
        }
        template<typename... arg_ts>
        explicit UnorderedMap(const KeyValue<key_t,arg_ts>&... args) {
            static_assert((is_present<arg_ts...,Ts>::value || ...), 
                    "In UnorderedMap constructor: Type passed to constructor not found in template parameter pack.\n");        
            (order_.push_back(args.key),...);
            (map_.emplace(args.key,std::variant<Ts...>(args.value)),...);  
        }
        template<typename Arg>
        void emplace(const key_t& key, const Arg& value) {
            static_assert(is_present<Arg,Ts...>::value, 
                    "In UnorderedMap::emplace(): Type passed to emplace not found in template parameter pack.\n");
            order_.push_back(key);
            map_.emplace(key,value);
        }
        std::size_t size() const { return map_.size(); } 
        const map_t& map() const { return map_; }
        const order_t& order() const { return order_; }
        value_var& at(const key_t& key) { return map_.at(key); }
        const value_var& at(const key_t& key) const { return map_.at(key); }
        value_var& operator[](const key_t& key) { 
            if(map_.find(key)==map_.end())
                order_.push_back(key);
            return map_[key]; 
        }
        const value_var& operator[](const key_t& key) const { return map_[key]; }

        iterator_t begin() { return iterator_t(order_.begin(),&map_); }
        iterator_t end() { return iterator_t(order_.end(),&map_); }

    private:
        order_t order_;
        map_t map_;
}; // class UnorderedMap


/*
 *  Same as UnorderedMap but the key_t is a string
 */
template <typename... Ts>
class Dictionary {
    public:
        using value_var = without_duplicates<std::variant<Ts...> >;
        using key_t = std::string;
        using order_t = std::vector<key_t>;
        using map_t = std::unordered_map<key_t,value_var>;
        using iterator_t = Iterator<typename order_t::iterator, map_t, value_var>;
        template<typename... key_ts>
        explicit Dictionary(const key_ts&... keys) {
            (order_.push_back(keys),...);
            (map_.emplace(keys,value_var(Ts())),...);
        }
        template<typename... arg_ts>
        explicit Dictionary(const KeyValue<key_t,arg_ts>&... args) {
            static_assert((is_present<arg_ts...,Ts>::value || ...), 
                    "In Dictionary constructor: Type passed to constructor not found in template parameter pack.\n");        
            (order_.push_back(args.key),...);
            (map_.emplace(args.key,value_var(args.value)),...);  
        }
        template<typename Arg>
        void emplace(const key_t& key, const Arg& value) {
            static_assert(is_present<Arg,Ts...>::value, 
                    "In Dictionary::emplace(): Type passed to emplace not found in template parameter pack.\n");
            order_.push_back(key);
            map_.emplace(key,value);
        }
        std::size_t size() const { return map_.size(); } 
        const order_t& order() const { return order_; }
        const map_t& map() const { return map_; }
        value_var& at(const key_t& key) { return map_.at(key); }
        const value_var& at(const key_t& key) const { return map_.at(key); }
        value_var& operator[](const key_t& key) { 
            if(map_.find(key) == map_.end()) 
                order_.push_back(key);
            return map_[key]; 
        }
        const value_var& operator[](const key_t& key) const { 
            return map_[key]; 
        }
        
        iterator_t begin() { return iterator_t(order_.begin(),&map_); }
        iterator_t end() { return iterator_t(order_.end(),&map_); }
    private:
        order_t order_;
        map_t map_;
}; // class Dictionary

} // namespace Heterogenous

namespace std {

template <typename value_t, typename... value_ts>
inline ostream& operator<<(ostream& os, const variant<value_t, value_ts...>& var) {
    visit([&os](auto &&arg) {os << arg;}, var);
    return os;
} // namespace std

} // namespace Heterogenous

#endif // HETEROGENOUS_HPP
</file>

<file path="IteratorPolicy.hpp">
#ifndef ARACHNE_ITERATOR_POLICY_HPP
#define ARACHNE_ITERATOR_POLICY_HPP

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "Traits.hpp"
#include "Parameters.hpp"

namespace Arachne {

template <typename Graph, IsNodeData Node, IsEdgeData Edge>
struct IteratorPolicy {
    template <typename Iterator, typename InnerIterator, typename DereferenceType>
    struct SuperIterator {
        using iterator_category = std::bidirectional_iterator_tag;
        using value_type = Node;
        using pointer = value_type *;
        using reference = value_type &;

        Graph *g;
        InnerIterator it;

        SuperIterator(Graph *g, InnerIterator it) : g{g}, it{it} {}

        virtual const DereferenceType &operator *() const = 0;
        DereferenceType *operator->() const { return const_cast<DereferenceType*>(&**this); }

        virtual Iterator &operator++() = 0;
        Iterator operator++(int) { Iterator tmp = *static_cast<Iterator*>(this); ++(*this); return tmp; }

        Iterator operator+(NodeIdx n) {
            Iterator copy = *static_cast<Iterator*>(this);
            while (n-- > 0) ++copy;
            return copy;
        }

        bool operator==(const Iterator &other) const {
            return g == other.g && it == other.it;
        }
        bool operator!=(const Iterator &other) const {
            return !(*this == other);
        }

        virtual ~SuperIterator () = default;
    };

    template<IsIteratorTrait T, IsIteratorParameters ParamList = IteratorParameters<>>
    struct Iterator {};

    template <>
    struct Iterator<Basic> : public SuperIterator<Iterator<Basic>, NodeIdx, Node> {
        using SuperIterator = SuperIterator<Iterator<Basic>, NodeIdx, Node>;
        using SuperIterator::g;
        using SuperIterator::it;
        using SuperIterator::operator++;
        using SuperIterator::operator==;
        using SuperIterator::operator!=;
        using SuperIterator::operator->;
        using SuperIterator::operator+;
        using SuperIterator::SuperIterator;

        const Node &operator*() const override {
            return g->node(it);
        }

        Iterator<Basic> &operator++() override {
            ++it;
            return *this;
        }

        Iterator<Basic> operator--(int) { Iterator tmp = *this; --(*this); return tmp; }
        Iterator<Basic> &operator--() {
            --it;
            return *this;
        }

        Iterator<Basic> operator-(NodeIdx n) {
            Iterator<Basic> copy = *this;
            while (n-- > 0) --copy;
            return copy;
        }

        inline operator NodeIdx () const {
            return this->it;
        }
    };
};

}

#endif // ARACHNE_ITERATOR_POLICY_HPP
</file>

<file path="main.cpp">
/*
 * # `Arachne` Documentation

===========================

`Arachne` is a graph library written in C++20. It is intended as an
approachable, lightweight alternative to the Boost Graph Library (BGL), while
retaining the performance advantages of a C++ library relative to python
libraries such at NetworkX. `Arachne` strives to balance performance, ease of
use, and extensibility. In particular, the underlying containers and
implementation are more narrows than the wide array of parameterizations
offered by the BGL, but the library offers lots of room for this functionality
to be extended.

`Arachne` is also an experiment in policy based design via the curiously
recurring template pattern (CRTP).

## TODO List

---

- [ ] Implement output to `mermaid` for convenient visualization
- [x] `NodeStoragePolicy`
- [ ] Implement the following algorithms
  - [ ] Clique
  - [ ] Colouring
  - [ ] Isomorphism
  - [ ] Shortest Paths
  - [ ] Traversal
- [ ] Error handling
- [ ] Implement Spider (an iterator for graphs that can knit graphs to together,
and inspect graph elements)
- [ ] Various storage conventions for edges

## Conventions

---

Throughout the library the following conventions are employed

- All types are written in upper camel case while instances or objects are
written in lower case with underscores:

```cpp
    TypeName type_name;
```

- Use full words in declartion names. (e.g. prefer `AdjacencyListPolicy` to
`AdjLstPolicy` or some variant thereof).

- Internally, all nodes are stored in a single container whose type is
determined by the storage policy trait type.
- In this document $N$ always refers to the number of nodes in the graph.

## Policy Based Design

---

![`Arachne` Schematic](img/ArachneSchematic/ArachneSchematic.png)

_Schematic of the Arachne Library. The structure of inheritance for the
representation policy is specific for each of the policies discussed below. That
is, for each representation, `X`, there exists a specific storage,
directionality, and connectivity policy, specialized for the policy traits
listed below._

### Graph Traits

`Arachne` aims to be extensible, and to allow users to define, at compile
time, any kind of graph they want. To facilitate this, `Arachne` identifies
three graph traits, each of which may be assigned one of several possible types
shown in the table below

|   Policy Trait   |          Types           |
| :--------------: | :----------------------: |
|    `Storage`     |   `Dynamic`, `Static`    |
| `Directionality` | `Directed`, `Undirected` |
|  `Connectivty`   |    `Simple`, `Multi`     |

### Representation Policies

A graph is composed of one or more representation policies for the underlying
graph, along with a container of nodes. Each representation policy wraps an
underlying container, and, through CRTP, inherits methods to access and
modifying the underlying representation. The philosophy is that each program
using Arachne should compile exactly what the user needs for their application,
nothing more or less. Currently, Arachne supports the following representation
polices,

##### Edge List Policy (`inc/EdgeListPolicy.hpp`)

##### Conpressed Format Policy (`inc/CompressedFormatPolicy.hpp`)

##### Adjacency List Policy (`inc/AdjacancyListPolicy.hpp`)

##### Adjacency Matrix Policy (`inc/AdjacencyMatrixPolicy.hpp`)

The adjacency matrix stores the edge (edges) incident on nodes $j$ and $k$ as
the $(j,k)$ entry (list of entries) of an $N\times N$ matrix. For speed and
efficiency, the $N\times N$ matrix is represented by a one dimension array or
vector depending on whether the underlying graph is dynamic or static. Moreover,
if the grpah is undirected, the corresponding adjacency matrix will be
symmetric, and thus we need only store $N(N+1)/2$ elements in the underlying
container. To faciliate this, the `AdjacencyMatrixDirectionalityPolicy` contains
three `protected` members, `start_of_row_`, `end_of_row_` and
`elements_in_row_`.

### Node Storage Policy

## Performance Tests
flowchart LR;
  NSP[Node Storage Policy];
  NT[Node Type];
  ET[Edge Type];
  subgraph AT[Arachne Traits]
    direction LR
    ST[Storage Traits];
    CT[Connectivity Traits];
    DT[Directionality Traits];
  end
  subgraph R["Representation Policies"]
    direction LR;
    SP[Rep. Storage Policy];
    CP[Rep. Connectivity Policy];
    DP[Rep. Directionality Policy];
    SP & CP & DP ==o GRP[Graph Representation Policy];
  end
  ST --> SP;
  CT --> CP;
  DT --> DP;
  ET -.-> SP & CP & DP;
  ST --> NSP;
  NT -.-> NSP;
  subgraph Legend
    direction LR
      start1[ ] -.->|Free Template Parameter| end1[ ];
      start2[ ] -->|Specialized Template Parameter| end2[ ];
      start3[ ] ==o |CRTP Inheritance| end3[ ];
  end
  G[Graph];
  NSP==o G;
  GRP==o G;

 * The file below has been generated by another LLM.
 * The initial prompt was "generate a sample main.cpp file that demonstrates how
 * to use the arachne library."
 * Take it with a grain of salt.
*/

#include <iostream>
#include "ArachneData.hpp"
#include "Graph.hpp"
#include "Parameters.hpp"

// For a clean and readable graph definition, use a 'using' alias.
using MyGraph =
    Arachne::Graph<0,
                   Arachne::Parameters<Arachne::Dynamic, Arachne::Directed,
                                       Arachne::NodeData<Arachne::Name>,
                                       Arachne::EdgeData<Arachne::Weight>>,
                   Arachne::AdjacencyList>;

// Let's define the EdgeType explicitly to make the code cleaner.


using MyEdgeType = Arachne::EdgeData<Arachne::Weight>;

using BasicIterator =
    typename MyGraph::IteratorPolicy::template Iterator<Arachne::Basic>;

int main() {
    // 1. Create a graph with 6 nodes.
    MyGraph g(6);

    // 2. Add data to the nodes.
    g.node(0) = MyGraph::NodeType("A");
    g.node(1) = MyGraph::NodeType("B");
    g.node(2) = MyGraph::NodeType("C");
    g.node(3) = MyGraph::NodeType("D");
    g.node(4) = MyGraph::NodeType("E");
    g.node(5) = MyGraph::NodeType("F");

    // 3. Add weighted edges.
    g.add_edge(0, 1, MyEdgeType(2.0)); // A -> B (w: 2.0)
    g.add_edge(0, 2, MyEdgeType(4.0)); // A -> C (w: 4.0)
    g.add_edge(1, 2, MyEdgeType(1.0)); // B -> C (w: 1.0)
    g.add_edge(1, 3, MyEdgeType(7.0)); // B -> D (w: 7.0)
    g.add_edge(2, 4, MyEdgeType(3.0)); // C -> E (w: 3.0)
    g.add_edge(3, 5, MyEdgeType(1.0)); // D -> F (w: 1.0)
    g.add_edge(4, 3, MyEdgeType(2.0)); // E -> D (w: 2.0)
    g.add_edge(4, 5, MyEdgeType(5.0)); // E -> F (w: 5.0)

    std::cout << "--- Graph Overview ---" << std::endl;
    std::cout << "Number of nodes: " << g.number_of_nodes() << std::endl;
    std::cout << "Number of edges: " << g.number_of_edges() << std::endl;
    std::cout << "\n--- Adjacency List Representation ---" << std::endl;
    std::cout << g.representation_to_string() << std::endl;

    // 4. Demonstrate basic node iteration.
    std::cout << "\n--- All Nodes ---" << std::endl;
    for (auto it = g.begin<Arachne::Basic>(); it != g.end<Arachne::Basic>();
         ++it) {
        std::cout << "Node " << it << ": " << it->name << std::endl;
    }

    // 5. Demonstrate neighbor iteration for a specific node (Node 'A').
    std::cout << "\n--- Neighbors of Node A (0) ---" << std::endl;
    auto neighbors_of_A = g.get_neighbours(g.begin<Arachne::Basic>() + 0ul);
    for (auto it = neighbors_of_A.first; it != neighbors_of_A.second; ++it) {
        // FIX: Use the correct BasicIterator alias for the constructor-style
        // cast.
        std::cout << "  -> " << it->name << " (Edge Weight: "
                  << g.get_edge(0, BasicIterator(it)).weight << ")"
                  << std::endl;
    }

    // 6. Demonstrate an advanced search iterator: Dijkstra's Algorithm.
    std::cout << "\n--- Dijkstra's Shortest Path from A to F ---" << std::endl;

    // The edge weight function for Dijkstra's.
    // The 'auto' keyword will correctly deduce the types for u (BasicIterator)
    // and v (NeighbourIterator).
    auto edge_weight_func = [&](const auto& u, const auto& v) -> double {
        // FIX: We must convert the Neighbour iterator 'v' to a BasicIterator
        // before use.
        return g.get_edge(u, BasicIterator(v)).weight;
    };

    // The heuristic for A* (for Dijkstra, it's just 0)
    auto heuristic_func = [](const auto& u) -> double { return 0.0; };

    // Using the A* iterator, which becomes Dijkstra when the heuristic is
    // always 0.
    auto path_begin = g.begin<Arachne::AStar>(g.begin<Arachne::Basic>() + 0ul,
                                              heuristic_func, edge_weight_func);
    auto path_end = g.end<Arachne::AStar>();

    std::cout << "Search Order (Node, TotalCost):" << std::endl;
    for (auto it = path_begin; it != path_end; ++it) {
        std::cout << "  Visiting " << it->name << " with cost " << it.it.second
                  << std::endl;
        if (it.it.first ==
            g.begin<Arachne::Basic>() + 5ul) { // Found the destination node F
            std::cout << "Found destination F! Total path cost: "
                      << it.it.second << std::endl;
            break;
        }
    }

    return 0;
}
</file>

<file path="NodeData.hpp">
#ifndef ARACHNE_NODE_PARAMETERS_HPP
#define ARACHNE_NODE_PARAMETERS_HPP

#include <sstream>
#include <tuple>

#include "ArachneData.hpp"
#include "Types.hpp"
#include "display.hpp"

namespace Arachne {

template <typename... Data>
struct NodeData;

template <IsNotArachneData NotArachneData, typename... OtherData>
struct NodeData<NotArachneData, OtherData...> {
    static_assert(
        false, "NodeData cannot hold more than one non-arachne data type.\n");
};

// this partially orders the input types so that the user data is first. It
// makes things easier.
template <IsArachneData ArachneData, typename... OtherData>
struct NodeData<ArachneData, OtherData...> {
    static_assert(false, "In NodeData template arguments, user specified data "
                         "(if any) must come first.\n");
};

// Thanks to the above template specialization, all the ArachneData has been
// captured in the parameter pack.
template <IsNotArachneData UserData, IsArachneData... ArachneData>
struct NodeData<UserData, ArachneData...> : public ArachneData... {
    static constexpr bool is_node_data = true;
    UserData data{};

    explicit NodeData() {}

    explicit NodeData(UserData user_data, ArachneData::Data... arachne_data) {
        data = user_data;
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << "User Data: " << data << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <IsArachneData First, IsArachneData... ArachneData>
struct NodeData<First, ArachneData...> : public First, public ArachneData... {
    static constexpr bool is_node_data = true;
    explicit NodeData() {}
    explicit NodeData(First::Data first, ArachneData::Data... arachne_data) {
        First::set_value(first, this);
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << First::to_string(this) << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <IsArachneData... ArachneData>
struct NodeData<None, ArachneData...> : public ArachneData... {
    using UserData = None;
    explicit NodeData() {}

    explicit NodeData(ArachneData::Data... arachne_data) {
        (ArachneData::set_value(arachne_data, this), ...);
    }

    String to_string(const String delim = ", ") const {
        std::stringstream s;
        s << "User Data: None" << delim;
        ((s << ArachneData::to_string(this) << delim), ...);
        return s.str().substr(0, s.str().size() - delim.size());
    }
};

template <>
struct NodeData<None> {
    static constexpr bool is_node_data = true;
    using Data = None;
    Data data;

    String to_string(...) const { return display(data); }
};

template <>
struct NodeData<> {
    static constexpr bool is_node_data = true;
    using Data = None;
    Data data;

    String to_string(...) const { return display(data); }
};

template <typename T>
concept IsNodeData = T::is_node_data;

template <typename T>
concept IsNotNodeData = not IsNodeData<T>;

} // namespace Arachne

#endif // ARACHNE_NODE_PARAMETERS_HPP
</file>

<file path="NodeStoragePolicy.hpp">
#ifndef NODE_POLICY_HPP
#define NODE_POLICY_HPP

#include <array>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <vector>
#include <functional>

#include "NodeData.hpp"
#include "EdgeData.hpp"
#include "IteratorPolicy.hpp"
#include "Traits.hpp"
#include "Types.hpp"
#include "display.hpp"

namespace Arachne {

template <typename Graph, IsNodeData Node, IsEdgeData Edge, typename Storage, Size N>
struct NodeStoragePolicy {};

template <typename Graph, IsNodeData Node, IsEdgeData Edge, Size N>
struct NodeStoragePolicy<Graph, Node, Edge, Dynamic, N> {
    using NodeType = Node;
    using NodeContainer = std::vector<Node>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;

    void initialize_node_container(Size n = N) {
        static_cast<Graph*>(this)->node_container_.resize(n);
    }
    // N.B. The method add_node_to_representation_ assumes that the node
    // container has been modified first!
    template <typename... NodeConstructorArgs>
    void add_node(NodeConstructorArgs&&... args) {
        static_cast<Graph*>(this)->node_container_.emplace_back(args...);
        static_cast<Graph*>(this)->add_node_to_representation_();
    }
    // N.B. The method add_node_to_representation_ assumes that the node
    // container has been modified first!
    void add_node(const Node node, int number = 1) {
        for (int i = 0; i < number; i++) static_cast<Graph*>(this)->node_container_.push_back(node);
        static_cast<Graph*>(this)->add_node_to_representation_(number);
    }
    // N.B. The method remove_node_from_representation_ assumes that the node
    // container has not been modified yet!
    void remove_node(const IteratorPolicy::template Iterator<Basic> it) {
        const NodeIdx a = it.it;
        static_cast<Graph*>(this)->remove_node_from_representation_(a);
        static_cast<Graph*>(this)->node_container_.erase(
            static_cast<Graph*>(this)->node_container().begin() + a);
    }

    // Removes nodes that do not satisfy pred. 
    // Returns the number of removed nodes. 
    Size filter(std::function<Bool(const typename IteratorPolicy::template Iterator<Basic>&)> pred) {
        if (static_cast<Graph*>(this)->number_of_nodes() == 0) return 0;
        std::vector<typename IteratorPolicy::template Iterator<Basic>> to_delete;
        for (auto it = static_cast<Graph*>(this)->template begin<Basic>(); it != static_cast<Graph*>(this)->template end<Basic>(); it++) {
            if (!pred(it)) {
                to_delete.push_back(it);
            }
        }
        for (auto it = to_delete.rbegin(); it != to_delete.rend(); it++) {
            remove_node(*it);
        }
        return to_delete.size();
    }
};

template <typename Graph, IsNodeData Node, IsEdgeData Edge, Size N>
struct NodeStoragePolicy<Graph, Node, Edge, Static, N> {
    using NodeType = Node;
    using NodeContainer = std::array<Node, N>;

    void initialize_node_container() {}
};

template <Size N, typename Graph, IsNodeData Node, IsEdgeData Edge, typename Storage>
class NodePolicy : public NodeStoragePolicy<Graph, Node, Edge, Storage, N>,
                   public IteratorPolicy<Graph, Node, Edge> {
    using StoragePolicy = NodeStoragePolicy<Graph, Node, Edge, Storage, N>;
    using IteratorPolicy = IteratorPolicy<Graph, Node, Edge>;
    friend StoragePolicy;

  public:
    using NodeType = Node;
    using NodeContainer = typename StoragePolicy::NodeContainer;
    using StoragePolicy::initialize_node_container;

    void initialize_node_container(NodeContainer node_container) {
        static_cast<Graph*>(this)->node_container_ = node_container;
    }

    Size number_of_nodes() const { return node_container_.size(); }
    const Node& node(const IteratorPolicy::template Iterator<Basic> &it) const { return node(it); }
    Node& node(const IteratorPolicy::template Iterator<Basic> &it) { return node(it); }
    const NodeContainer& node_container() const { return node_container_; }
    NodeContainer& node_container() { return node_container_; }

    String nodes_to_string(const String iter_delim = "\n") {
        std::stringstream ss;
        Size counter = 0;
        Size counter_size =
            std::to_string(static_cast<Graph*>(this)->node_container_.size())
                .size() +
            2;
        for (auto iter : static_cast<Graph*>(this)->node_container_) {
            String counter_str = "[" + std::to_string(counter) + "] ";
            ss << std::setw(counter_size) << std::left << counter_str
               << iter.to_string() << iter_delim;
            counter++;
        }
        return ss.str().substr(0, ss.str().size() - iter_delim.size());
    }

    template <IsBasicTrait Trait>
    inline IteratorPolicy::template Iterator<Basic> begin() { 
        return typename IteratorPolicy::template Iterator<Basic>(static_cast<Graph*>(this), 0); 
    }

    template <IsBasicTrait Trait>
    inline IteratorPolicy::template Iterator<Basic> end() { 
        return typename IteratorPolicy::template Iterator<Basic>(static_cast<Graph*>(this), static_cast<Graph*>(this)->number_of_nodes());
    }

    NodeContainer node_container_;

    const Node& node(NodeIdx idx) const { return node_container_.at(idx); }
    Node& node(NodeIdx idx) { return node_container_.at(idx); }
    NodeIdx nodeId(const IteratorPolicy::template Iterator<Basic> &it) { return reinterpret_cast<NodeIdx>(it.it); }
};

} // namespace Arachne

#endif // NODE_POLICY_HPP
</file>

<file path="observer_ptr.hpp">
// Copyright 2018-2019 by Martin Moene
//
// nonstd::observer_ptr<> is a C++98 onward implementation for std::observer_ptr as of C++17.
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#pragma once

#ifndef NONSTD_OBSERVER_PTR_H_INCLUDED
#define NONSTD_OBSERVER_PTR_H_INCLUDED

#define observer_ptr_MAJOR  0
#define observer_ptr_MINOR  4
#define observer_ptr_PATCH  0

#define observer_ptr_VERSION  nsop_STRINGIFY(observer_ptr_MAJOR) "." nsop_STRINGIFY(observer_ptr_MINOR) "." nsop_STRINGIFY(observer_ptr_PATCH)

#define nsop_STRINGIFY(  x )  nsop_STRINGIFY_( x )
#define nsop_STRINGIFY_( x )  #x

// observer_ptr configuration:

#ifndef  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SMART_PTR
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SMART_PTR  0
#else
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SMART_PTR
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SMART_PTR
#endif

#ifndef  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR  0
#endif

#ifndef  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR  0
#endif

#ifndef  nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_TO_UNDERLYING_TYPE
# define nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_TO_UNDERLYING_TYPE  0
#endif

#ifndef  nsop_CONFIG_CONFIRMS_COMPILATION_ERRORS
# define nsop_CONFIG_CONFIRMS_COMPILATION_ERRORS  0
#endif

#define nsop_OBSERVER_PTR_DEFAULT  0
#define nsop_OBSERVER_PTR_NONSTD   1
#define nsop_OBSERVER_PTR_STD      2

#if !defined( nsop_CONFIG_SELECT_OBSERVER_PTR )
# define nsop_CONFIG_SELECT_OBSERVER_PTR  ( nsop_HAVE_STD_OBSERVER_PTR ? nsop_OBSERVER_PTR_STD : nsop_OBSERVER_PTR_NONSTD )
#endif

// C++ language version detection (C++23 is speculative):
// Note: VC14.0/1900 (VS2015) lacks too much from C++14.

#ifndef   nsop_CPLUSPLUS
# if defined(_MSVC_LANG ) && !defined(__clang__)
#  define nsop_CPLUSPLUS  (_MSC_VER == 1900 ? 201103L : _MSVC_LANG )
# else
#  define nsop_CPLUSPLUS  __cplusplus
# endif
#endif

#define nsop_CPP98_OR_GREATER  ( nsop_CPLUSPLUS >= 199711L )
#define nsop_CPP11_OR_GREATER  ( nsop_CPLUSPLUS >= 201103L )
#define nsop_CPP11_OR_GREATER_ ( nsop_CPLUSPLUS >= 201103L )
#define nsop_CPP14_OR_GREATER  ( nsop_CPLUSPLUS >= 201402L )
#define nsop_CPP17_OR_GREATER  ( nsop_CPLUSPLUS >= 201703L )
#define nsop_CPP20_OR_GREATER  ( nsop_CPLUSPLUS >= 202002L )
#define nsop_CPP23_OR_GREATER  ( nsop_CPLUSPLUS >= 202300L )

// Use C++17 std::any if available and requested:

#if nsop_CPP17_OR_GREATER && defined(__has_include )
# if __has_include( <experimental/memory> )
#  define nsop_HAVE_STD_OBSERVER_PTR  1
# else
#  define nsop_HAVE_STD_OBSERVER_PTR  0
# endif
#else
# define  nsop_HAVE_STD_OBSERVER_PTR  0
#endif

#define  nsop_USES_STD_OBSERVER_PTR  ( (nsop_CONFIG_SELECT_OBSERVER_PTR == nsop_OBSERVER_PTR_STD) || ((nsop_CONFIG_SELECT_OBSERVER_PTR == nsop_OBSERVER_PTR_DEFAULT) && nsop_HAVE_STD_OBSERVER_PTR) )

//
// Using std::experimental::observer_ptr:
//

#if nsop_USES_STD_OBSERVER_PTR

#include <experimental/memory>

namespace nonstd {

    using std::experimental::observer_ptr;
    using std::experimental::make_observer;
    using std::experimental::swap;

    using std::experimental::operator==;
    using std::experimental::operator!=;
    using std::experimental::operator<;
    using std::experimental::operator<=;
    using std::experimental::operator>;
    using std::experimental::operator>=;
}

#else // nsop_USES_STD_OBSERVER_PTR

#include <cassert>
#include <algorithm>
#include <functional>

// Compiler versions:
//
// MSVC++  6.0  _MSC_VER == 1200  nsop_COMPILER_MSVC_VERSION ==  60  (Visual Studio 6.0)
// MSVC++  7.0  _MSC_VER == 1300  nsop_COMPILER_MSVC_VERSION ==  70  (Visual Studio .NET 2002)
// MSVC++  7.1  _MSC_VER == 1310  nsop_COMPILER_MSVC_VERSION ==  71  (Visual Studio .NET 2003)
// MSVC++  8.0  _MSC_VER == 1400  nsop_COMPILER_MSVC_VERSION ==  80  (Visual Studio 2005)
// MSVC++  9.0  _MSC_VER == 1500  nsop_COMPILER_MSVC_VERSION ==  90  (Visual Studio 2008)
// MSVC++ 10.0  _MSC_VER == 1600  nsop_COMPILER_MSVC_VERSION == 100  (Visual Studio 2010)
// MSVC++ 11.0  _MSC_VER == 1700  nsop_COMPILER_MSVC_VERSION == 110  (Visual Studio 2012)
// MSVC++ 12.0  _MSC_VER == 1800  nsop_COMPILER_MSVC_VERSION == 120  (Visual Studio 2013)
// MSVC++ 14.0  _MSC_VER == 1900  nsop_COMPILER_MSVC_VERSION == 140  (Visual Studio 2015)
// MSVC++ 14.1  _MSC_VER >= 1910  nsop_COMPILER_MSVC_VERSION == 141  (Visual Studio 2017)
// MSVC++ 14.2  _MSC_VER >= 1920  nsop_COMPILER_MSVC_VERSION == 142  (Visual Studio 2019)

#if defined(_MSC_VER ) && !defined(__clang__)
# define nsop_COMPILER_MSVC_VER      (_MSC_VER )
# define nsop_COMPILER_MSVC_VERSION  (_MSC_VER / 10 - 10 * ( 5 + (_MSC_VER < 1900 ) ) )
#else
# define nsop_COMPILER_MSVC_VER      0
# define nsop_COMPILER_MSVC_VERSION  0
#endif

#define nsop_COMPILER_VERSION( major, minor, patch )  ( 10 * ( 10 * (major) + (minor) ) + (patch) )

#if defined(__clang__)
# define nsop_COMPILER_CLANG_VERSION  nsop_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)
#else
# define nsop_COMPILER_CLANG_VERSION  0
#endif

#if defined(__GNUC__) && !defined(__clang__)
# define nsop_COMPILER_GNUC_VERSION  nsop_COMPILER_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#else
# define nsop_COMPILER_GNUC_VERSION  0
#endif

// half-open range [lo..hi):
#define nsop_BETWEEN( v, lo, hi ) ( (lo) <= (v) && (v) < (hi) )

// Presence of language and library features:

#ifdef _HAS_CPP0X
# define nsop_HAS_CPP0X  _HAS_CPP0X
#else
# define nsop_HAS_CPP0X  0
#endif

// Unless defined otherwise below, consider VC12 as C++11 for observer_ptr:

#if nsop_COMPILER_MSVC_VER >= 1800
# undef  nsop_CPP11_OR_GREATER
# define nsop_CPP11_OR_GREATER  1
#endif

#define nsop_CPP11_100  (nsop_CPP11_OR_GREATER_ || nsop_COMPILER_MSVC_VER >= 1600)
#define nsop_CPP11_110  (nsop_CPP11_OR_GREATER_ || nsop_COMPILER_MSVC_VER >= 1700)
#define nsop_CPP11_120  (nsop_CPP11_OR_GREATER_ || nsop_COMPILER_MSVC_VER >= 1800)
#define nsop_CPP11_140  (nsop_CPP11_OR_GREATER_ || nsop_COMPILER_MSVC_VER >= 1900)

#define nsop_CPP11_000  (nsop_CPP11_OR_GREATER_)
#define nsop_CPP14_000  (nsop_CPP14_OR_GREATER )
#define nsop_CPP17_000  (nsop_CPP17_OR_GREATER )

// Presence of C++ language features:

#define nsop_HAVE_CONSTEXPR_11          nsop_CPP11_000
#define nsop_HAVE_CONSTEXPR_14          nsop_CPP14_000
#define nsop_HAVE_DEFAULT_FUNCTION_TEMPLATE_ARG  nsop_CPP11_120
#define nsop_HAVE_EXPLICIT_CONVERSION   nsop_CPP11_140
#define nsop_HAVE_NOEXCEPT              nsop_CPP11_140
#define nsop_HAVE_NULLPTR               nsop_CPP11_100

#define nsop_HAVE_TYPEOF  (nsop_CPP11_000 && nsop_COMPILER_GNUC_VERSION)

// Presence of C++ library features:

#define nsop_HAVE_STD_DECAY             nsop_CPP11_110
#define nsop_HAVE_STD_DECLVAL           nsop_CPP11_110
#define nsop_HAVE_STD_SMART_PTRS        nsop_CPP11_140

// Presence and usage of smart pointers:

#define nsop_HAVE_IMPLICIT_CONVERSION_FROM_SMART_PTR  ( \
    nsop_HAVE_STD_SMART_PTRS && ( \
        nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR || \
        nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR  ) \
    )

// C++ feature usage:

#if nsop_HAVE_CONSTEXPR_11
# define nsop_constexpr constexpr
#else
# define nsop_constexpr /*nothing*/
#endif

#if nsop_HAVE_CONSTEXPR_14
# define nsop_constexpr14 constexpr
#else
# define nsop_constexpr14 /*nothing*/
#endif

#if nsop_HAVE_EXPLICIT_CONVERSION
# define nsop_explicit explicit
#else
# define nsop_explicit /*nothing*/
#endif

#if nsop_HAVE_NOEXCEPT
# define nsop_noexcept noexcept
#else
# define nsop_noexcept /*nothing*/
#endif

#if nsop_HAVE_NULLPTR
# define nsop_NULLPTR nullptr
#else
# define nsop_NULLPTR NULL
#endif

// additional includes:

#if nsop_HAVE_IMPLICIT_CONVERSION_FROM_SMART_PTR
# include <memory>
#endif

// common_type:

#if nsop_HAVE_STD_DECAY && nsop_HAVE_STD_DECLVAL
# include <type_traits>  // std::decay
# include <utility>      // std::declval
#endif

#define nsop_HAVE_OWN_COMMON_TYPE_STD    (nsop_HAVE_STD_DECAY && nsop_HAVE_STD_DECLVAL || nsop_HAVE_TYPEOF)
#define nsop_HAVE_OWN_COMMON_TYPE_TYPEOF  nsop_HAVE_TYPEOF

// Method enabling

#define nsop_REQUIRES_T(VA) \
    , typename std::enable_if< (VA), int >::type = 0

//
// oberver_ptr:
//

namespace nonstd { namespace observer_ptr_lite {

// observer_ptr:

template< class W >
class observer_ptr
{
public:
    typedef W   element_type;
    typedef W * pointer;
    typedef W & reference;

    nsop_constexpr14 observer_ptr() nsop_noexcept
    : ptr( nsop_NULLPTR ) {}

#if nsop_HAVE_NULLPTR
    nsop_constexpr14 observer_ptr( std::nullptr_t ) nsop_noexcept
    : ptr( nullptr ) {}
#endif

    nsop_constexpr14 explicit observer_ptr( pointer p ) nsop_noexcept
    : ptr(p) {}

    template< class W2
#if nsop_HAVE_DEFAULT_FUNCTION_TEMPLATE_ARG
        nsop_REQUIRES_T(( std::is_convertible<W2*, W*>::value ))
#endif
    >
    nsop_constexpr14 observer_ptr( observer_ptr<W2> other ) nsop_noexcept
    : ptr( other.get() ) {}

#if nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_UNIQUE_PTR && nsop_HAVE_STD_SMART_PTRS
    template< class W2
        nsop_REQUIRES_T(( std::is_convertible<W2*, W*>::value ))
    >
    nsop_constexpr14 observer_ptr( std::unique_ptr<W2> const & other ) nsop_noexcept
    : ptr( other.get() ) {}
#endif

#if nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_FROM_SHARED_PTR && nsop_HAVE_STD_SMART_PTRS
    template< class W2
        nsop_REQUIRES_T(( std::is_convertible<W2*, W*>::value ))
    >
     nsop_constexpr14 observer_ptr( std::shared_ptr<W2> const & other ) nsop_noexcept
    : ptr( other.get() ) {}
#endif

    nsop_constexpr14 pointer get() const nsop_noexcept
    {
        return ptr;
    }

    nsop_constexpr14 reference operator*() const
    {
        return assert( ptr != nsop_NULLPTR ), *ptr;
    }

    nsop_constexpr14 pointer operator->() const nsop_noexcept
    {
        return ptr;
    }

#if nsop_HAVE_EXPLICIT_CONVERSION

    nsop_constexpr14 explicit operator bool() const nsop_noexcept
    {
        return ptr != nsop_NULLPTR;
    }

    nsop_constexpr14 explicit operator pointer() const nsop_noexcept
    {
        return ptr;
    }
#elif nsop_CONFIG_ALLOW_IMPLICIT_CONVERSION_TO_UNDERLYING_TYPE

    nsop_constexpr14 operator pointer() const nsop_noexcept
    {
        return ptr;
    }
#else
private:
    typedef void (observer_ptr::*safe_bool)() const;
    void this_type_does_not_support_comparisons() const {}
public:

    nsop_constexpr14 operator safe_bool() const nsop_noexcept
    {
        return ptr != nsop_NULLPTR ? &observer_ptr::this_type_does_not_support_comparisons : 0;
    }
#endif

    nsop_constexpr14 pointer release() nsop_noexcept
    {
        pointer p( ptr );
        reset();
        return p;
    }

    nsop_constexpr14 void reset( pointer p = nsop_NULLPTR ) nsop_noexcept
    {
        ptr = p;
    }

    nsop_constexpr14 void swap( observer_ptr & other ) nsop_noexcept
    {
        using std::swap;
        swap(ptr, other.ptr);
    }

private:
    pointer ptr;
};

// specialized algorithms:

template< class W >
void swap( observer_ptr<W> & p1, observer_ptr<W> & p2 ) nsop_noexcept
{
    p1.swap( p2 );
}

template< class W >
observer_ptr<W> make_observer( W * p ) nsop_noexcept
{
    return observer_ptr<W>( p );
}

template< class W1, class W2 >
bool operator==( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return p1.get() == p2.get();
}

template< class W1, class W2 >
bool operator!=( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return !( p1 == p2 );
}

#if nsop_HAVE_NULLPTR

template< class W >
bool operator==( observer_ptr<W> p, std::nullptr_t ) nsop_noexcept
{
    return !p;
}

template< class W >
bool operator==( std::nullptr_t, observer_ptr<W> p ) nsop_noexcept
{
    return !p;
}

template< class W >
bool operator!=( observer_ptr<W> p, std::nullptr_t ) nsop_noexcept
{
    return static_cast<bool>( p );
}

template< class W >
bool operator!=( std::nullptr_t, observer_ptr<W> p ) nsop_noexcept
{
    return static_cast<bool>( p );
}
#endif

namespace detail
{
    template< class T, class U >
#if nsop_HAVE_OWN_COMMON_TYPE_STD
    struct common_type { typedef typename std::decay< decltype(true ? std::declval<T>() : std::declval<U>()) >::type type; };
#elif nsop_HAVE_OWN_COMMON_TYPE_TYPEOF
    struct common_type { typedef __typeof__( true ? T() : U() ) type; };
#else // fall back
    struct common_type { typedef T type; };
#endif
} // namespace detail

template< class W1, class W2 >
bool operator<( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    // return std::less<W3>()( p1.get(), p2.get() );
    // where W3 is the composite pointer type (C++14 5) of W1* and W2*.
    return std::less< typename detail::common_type<W1*,W2*>::type >()( p1.get(), p2.get() );
}

template< class W1, class W2 >
bool operator>( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return p2 < p1;
}

template< class W1, class W2 >
bool operator<=( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return !( p2 < p1 );
}

template< class W1, class W2 >
bool operator>=( observer_ptr<W1> p1, observer_ptr<W2> p2 )
{
    return !( p1 < p2 );
}

} // namespace observer_ptr_lite

// provide in namespace nonstd:

using observer_ptr_lite::observer_ptr;
using observer_ptr_lite::make_observer;
using observer_ptr_lite::swap;

using observer_ptr_lite::operator==;
using observer_ptr_lite::operator!=;
using observer_ptr_lite::operator<;
using observer_ptr_lite::operator<=;
using observer_ptr_lite::operator>;
using observer_ptr_lite::operator>=;

} // namespace nonstd

#if nsop_CPP11_OR_GREATER

namespace std
{

template< class T >
struct hash< ::nonstd::observer_ptr<T> >
{
    size_t operator()(::nonstd::observer_ptr<T> p ) const nsop_noexcept
    {
        return hash<T*>()( p.get() );
    }
};

}
#endif

// #undef ...

#endif // nsop_USES_STD_OBSERVER_PTR

#endif // NONSTD_OBSERVER_PTR_H_INCLUDED

// end of file
</file>

<file path="Parameters.hpp">
#ifndef ARACHNE_GRAPH_PARAMETERS_HPP
#define ARACHNE_GRAPH_PARAMETERS_HPP

#include "EdgeData.hpp"
#include "NodeData.hpp"
#include "Traits.hpp"
#include "BasicBitMap.hpp"

namespace Arachne {

/* DEFAULT PARAMETERS */
using DefaultDirectionality = Undirected;
using DefaultConnectivity = Simple;
using DefaultStorage = Dynamic;
using DefaultEdgeData = EdgeData<>;
using DefaultNodeData = NodeData<>;

template <typename T>
concept IsArachneParameter = IsGraphTrait<T> || IsNodeData<T> || IsEdgeData<T>;

/* DIRECTIONALITY PARSER */
template <IsArachneParameter... Params>
struct ParseForDirectionality;

template <IsNotDirectionalityTrait NotDirectionality,
          IsArachneParameter... Rest>
struct ParseForDirectionality<NotDirectionality, Rest...>
    : ParseForDirectionality<Rest...> {};

template <IsDirectionalityTrait Directionality, IsArachneParameter... Rest>
struct ParseForDirectionality<Directionality, Rest...> {
    using DirectionalityTrait = Directionality;
};

template <>
struct ParseForDirectionality<> {
    using DirectionalityTrait = DefaultDirectionality;
};

/* CONNECTIVITY PARSER */
template <IsArachneParameter... Params>
struct ParseForConnectivity;

template <IsNotConnectivityTrait NotConnectivity, IsArachneParameter... Rest>
struct ParseForConnectivity<NotConnectivity, Rest...>
    : ParseForConnectivity<Rest...> {};

template <IsConnectivityTrait Connectivity, IsArachneParameter... Rest>
struct ParseForConnectivity<Connectivity, Rest...> {
    using ConnectivityTrait = Connectivity;
};

template <>
struct ParseForConnectivity<> {
    using ConnectivityTrait = DefaultConnectivity;
};

/* STORAGE PARSER */
template <IsArachneParameter... Params>
struct ParseForStorage;

template <IsNotStorageTrait NotStorage, IsArachneParameter... Rest>
struct ParseForStorage<NotStorage, Rest...> : ParseForStorage<Rest...> {};

template <IsStorageTrait Storage, IsArachneParameter... Rest>
struct ParseForStorage<Storage, Rest...> {
    using StorageTrait = Storage;
};

template <>
struct ParseForStorage<> {
    using StorageTrait = DefaultStorage;
};

/* NODE DATA PARSER */
template <IsArachneParameter... Params>
struct ParseForNodeData;

template <IsNotNodeData NotNodeData, IsArachneParameter... Rest>
struct ParseForNodeData<NotNodeData, Rest...> : ParseForNodeData<Rest...> {};

template <IsNodeData NodeData, IsArachneParameter... Rest>
struct ParseForNodeData<NodeData, Rest...> {
    using NodeDataParam = NodeData;
};

template <>
struct ParseForNodeData<> {
    using NodeDataParam = DefaultNodeData;
};

/* EDGE DATA PARSER */
template <IsArachneParameter... Params>
struct ParseForEdgeData;

template <IsNotEdgeData NotEdgeData, IsArachneParameter... Rest>
struct ParseForEdgeData<NotEdgeData, Rest...> : ParseForEdgeData<Rest...> {};

template <IsEdgeData EdgeData, IsArachneParameter... Rest>
struct ParseForEdgeData<EdgeData, Rest...> {
    using EdgeDataParam = EdgeData;
};

template <>
struct ParseForEdgeData<> {
    using EdgeDataParam = DefaultEdgeData;
};

/* PARAMETER LIST */
template <IsArachneParameter... Params>
struct Parameters {
    static bool constexpr IsParameters = true;
    using Directionality =
        typename ParseForDirectionality<Params...>::DirectionalityTrait;
    using Connectivity =
        typename ParseForConnectivity<Params...>::ConnectivityTrait;
    using Storage = typename ParseForStorage<Params...>::StorageTrait;
    using EdgeData = typename ParseForEdgeData<Params...>::EdgeDataParam;
    using NodeData = typename ParseForNodeData<Params...>::NodeDataParam;
};

template <typename T>
concept IsParameters = T::IsParameters;

/* ======== ITERATOR ======== */

/* DEFAULT PARAMETERS */
using DefaultPruningTrait = MultiplePathPruning;
using DefaultTraversalTrait = Full;
using DefaultSetType = BasicBitMap;

template <typename T>
concept IsIteratorParameter = IsPathPruningTrait<T> || IsTraversalTrait<T> || IsSetType<T>;

/* MULTIPLE PATH PRUNING PARSER */
template <IsIteratorParameter... Params>
struct ParseForMPP;

template <IsNotPathPruningTrait NotMPP, IsIteratorParameter... Rest>
struct ParseForMPP<NotMPP, Rest...> : ParseForMPP<Rest...> {};

template <IsPathPruningTrait MPP, IsArachneParameter... Rest>
struct ParseForMPP<MPP, Rest...> {
    using PruningTrait = MPP;
};

template <>
struct ParseForMPP<> {
    using PruningTrait = DefaultPruningTrait;
};

/* TRAVERSAL TRAIT PARSER */
template <IsIteratorParameter... Params>
struct ParseForTraversalTrait;

template <IsNotTraversalTrait NotTT, IsIteratorParameter... Rest>
struct ParseForTraversalTrait<NotTT, Rest...> : ParseForTraversalTrait<Rest...> {};

template <IsTraversalTrait TT, IsIteratorParameter... Rest>
struct ParseForTraversalTrait<TT, Rest...> {
    using TraversalTrait = TT;
};

template <>
struct ParseForTraversalTrait<> {
    using TraversalTrait = DefaultTraversalTrait;
};

/* SET TYPE PARSER */
template <IsIteratorParameter... Params>
struct ParseForSetType;

template <IsNotSetType NotST, IsIteratorParameter... Rest>
struct ParseForSetType<NotST, Rest...> : ParseForSetType<Rest...> {};

template <IsSetType ST, IsIteratorParameter... Rest>
struct ParseForSetType<ST, Rest...> {
    using SetType = ST;
};

template <>
struct ParseForSetType<> {
    using SetType = DefaultSetType;
};

template <IsIteratorParameter... Params>
struct IteratorParameters {
    static bool constexpr IsIteratorParameters = true;
    using PruningTrait =
        typename ParseForMPP<Params...>::PruningTrait;
    using SetType =
        typename ParseForSetType<Params...>::SetType;
    using TraversalTrait =
        typename ParseForTraversalTrait<Params...>::TraversalTrait;
};

template <typename T>
concept IsIteratorParameters = T::IsIteratorParameters;

} // namespace Arachne

#endif // ARACHNE_GRAPH_PARAMETERS_HPP
</file>

<file path="real.hpp">
#ifndef REAL_HPP
#define REAL_HPP

#include <cmath>

#include "Types.hpp"

namespace Arachne {

constexpr Real eq_cutoff = 1e-15;

inline bool real_eq(const Real a, const Real b) {
    return (std::abs(a - b) < eq_cutoff);
}

} // namespace Arachne

#endif // REAL_HPP
</file>

<file path="Traits.hpp">
#ifndef TRAITS_HPP
#define TRAITS_HPP

#include <list>
#include <tuple>
#include <concepts>

#include "Types.hpp"

namespace Arachne {

template <typename T>
concept IsBoolType = 
    std::same_as<T, std::true_type> || std::same_as<T, std::false_type>;

/*
 * Directionality Traits
 */

struct Undirected {};
struct Directed {};

template <typename T>
concept IsDirectionalityTrait =
    std::same_as<T, Undirected> || std::same_as<T, Directed>;

template <typename T>
concept IsNotDirectionalityTrait = not IsDirectionalityTrait<T>;

/*
 * Connectivity Traits
 */
struct Simple {
    template <typename T>
    using InnerContainer = T;

    template <typename T>
    static T empty_value = T(0);
};

struct Multi {
    template <typename T>
    using InnerContainer = std::list<T>;

    template <typename T>
    static std::list<T> empty_value;
};

template <typename T>
concept IsConnectivityTrait = std::same_as<T, Simple> || std::same_as<T, Multi>;

template <typename T>
concept IsNotConnectivityTrait = not IsConnectivityTrait<T>;

/*
 * Storage Traits
 */
struct Dynamic {};
struct Static {};

template <typename T>
concept IsStorageTrait = std::same_as<T, Dynamic> || std::same_as<T, Static>;

template <typename T>
concept IsNotStorageTrait = not IsStorageTrait<T>;

template <typename T>
concept IsGraphTrait =
    IsDirectionalityTrait<T> || IsConnectivityTrait<T> || IsStorageTrait<T>;

template <typename T>
concept IsNotGraphTrait = not IsGraphTrait<T>;

/*
 * Graph Traversal Traits
 */
struct Basic {};
struct Neighbour {};
struct Adjacent {};
struct EdgeIterator {};

/*
 * DFS Traits
 */
struct InOrder {};
struct PreOrder {};
struct PostOrder {};

struct BestFirst {};
struct AStar {};
struct Dijkstra {};


/*
 * Iterator Path Pruning Traits
 */
struct MultiplePathPruning{};
struct NoPathPruning{};

/*
 * Iterator Traversal Trait
 */
struct Component{};
struct Full{};

template <typename T>
concept IsIteratorTrait = std::same_as<T, Basic> 
                        || std::same_as<T, Neighbour>
                        || std::same_as<T, Adjacent>
                        || std::same_as<T, EdgeIterator>
                        || std::same_as<T, InOrder>
                        || std::same_as<T, PreOrder>
                        || std::same_as<T, PostOrder>
                        || std::same_as<T, BestFirst>
                        || std::same_as<T, AStar>
                        || std::same_as<T, Dijkstra>;


template <typename T>
concept IsBasicTrait = std::same_as<T, Basic>;

template <typename T>
concept IsSearchTrait = std::same_as<T, InOrder>
                        || std::same_as<T, PreOrder>
                        || std::same_as<T, PostOrder>;

template <typename T>
concept IsOrderedSearchTrait = std::same_as<T, BestFirst>
                        || std::same_as<T, AStar>
                        || std::same_as<T, Dijkstra>;

template <typename T>
concept IsBestFirst = std::same_as<T, BestFirst>;

template <typename T>
concept IsAStar = std::same_as<T, AStar>;

template <typename T>
concept IsDijkstra = std::same_as<T, Dijkstra>;

template <typename T>
concept IsPathPruningTrait = std::same_as<T, MultiplePathPruning> || std::same_as<T, NoPathPruning>;
template <typename T>
concept IsNotPathPruningTrait = not IsPathPruningTrait<T>;

template <typename T>
concept IsTraversalTrait = std::same_as<T, Component> || std::same_as<T, Full>;
template <typename T>
concept IsNotTraversalTrait = not IsTraversalTrait<T>;

template <typename T>
concept IsCompleteTraversal = std::same_as<T, Full>;

template <typename T>
concept IsSetType = requires (T x, T::value_type y) {
    {x.contains(y)} -> std::same_as<bool>;
    {x.insert(y).second} -> std::same_as<bool&&>;
};
template <typename T>
concept IsNotSetType = not IsSetType<T>;

} // namespace Arachne

#endif // TRAITS_HPP
</file>

<file path="Types.hpp">
#ifndef TYPES_HPP
#define TYPES_HPP

#include <memory>
#include <set>
#include <unordered_set>
#include <string>
#include <type_traits>
#include <utility>
#include <variant>
#include <vector>

// #include "observer_ptr.hpp"

namespace Arachne {

using None = std::monostate;
using Int32 = int;
using Uint32 = unsigned int;
using Real = double;
using String = std::string;
using Bool = bool;
using Size = std::size_t;
using NodeIdx = std::size_t;
using EdgeIdx = std::pair<NodeIdx, NodeIdx>;

using SizeVec = std::vector<Size>;
using RealVec = std::vector<Real>;
using NodeIdxSet = std::set<NodeIdx>;
using SizeSet = std::set<Size>;

template <Size N>
using SizeConstant = std::integral_constant<Size, N>;
// template <typename T>
// using ObsPtr = nonstd::observer_ptr_lite::observer_ptr<T>;
template <typename T>
using SharedPtr = std::shared_ptr<T>;
template <typename T>
using UniquePtr = std::unique_ptr<T>;

}; // namespace Arachne

#endif // TYPES_HPP
</file>

</files>
