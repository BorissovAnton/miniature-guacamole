This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
Sample_Circuits/
  Loop/
    Block.cc
    Block.h
    CMakeLists.txt
    Loop.cc
    Loop.h
    main.cc
    Operator.cc
    Operator.h
    Sample.cc
    Sample.h
    SampleSparse.cc
    SampleSparse.h
    tests.cc
    tests.h
  CMakeLists.txt
  parse.cc
  parse.h
Test_Pauli/
  Circuit.cc
  Circuit.h
  CMakeLists.txt
  Loop.cc
  Loop.h
  main.cc
  Operator.cc
  Operator.h
  SampleLoop.cc
  SampleLoop.h
  Stim_Pauli.cc
  Stim_Pauli.h
  tests.cc
  tests.h
  Weights.h
Circuit.cc
Circuit.h
CMakeLists.txt
Loop.cc
Loop.h
main.cc
Operator.cc
Operator.h
Pauli.cc
Pauli.h
Permutation.cc
Permutation.h
SampleCircuit.cc
SampleCircuit.h
SampleLoop.cc
SampleLoop.h
tests.cc
tests.h
Weights.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Sample_Circuits/Loop/Block.cc">
#include "Block.h"

Block::Block(const std::initializer_list<Operator>& ops) {
    operators = std::vector<Operator> (ops); 
}

const Operator& Block::operator[] (size_t index) const {
    return operators[index]; 
}

Operator& Block::operator[] (size_t index) {
    return operators[index]; 
}

void Block::push(const Operator& op) {
    operators.push_back(op); 
}

void Block::push_first(const Operator& op) {
    operators.insert(operators.begin(), op); 
}

void Block::append(std::initializer_list<Operator> ops) {
     for (const Operator& op: ops) {
        operators.push_back(op); 
     }
}

void Block::append(std::initializer_list<Block> subcircs) {
    for (const Block& subcirc : subcircs) {
        for (const Operator& op : subcirc.operators) {
            operators.push_back(op); 
        }
    }
}

void Block::splice(size_t index, const Block& subcirc) {
    if (index > operators.size()) {
        throw std::out_of_range("Index out of range");
    } else {
        operators.erase(operators.begin() + index);
        operators.insert(operators.begin() + index, 
                         subcirc.operators.begin(), 
                         subcirc.operators.end());
    }
}

size_t Block::length() const {
    return operators.size(); 
}

size_t Block::qubits() const {
    size_t max_qubits = 0;
    for (const Operator& op : operators) {
        max_qubits = std::max(max_qubits, 
                            std::visit([](const auto& _op) -> size_t {
                                return _op.qubits();  
                            }, op));
    }
    return max_qubits;
}

std::set<size_t> Block::support(
    std::optional<size_t> left_index,
    std::optional<size_t> right_index
) const {
    size_t lindex = left_index ? *left_index : 0; // assumes c++ doesn't support custom indexing
    size_t rindex = right_index ? *right_index : operators.size() - 1; 
    std::set<size_t> supp; 
    for (size_t i = lindex; i <= rindex; ++i) 
        supp = set_union(supp, std::visit([](const auto& _op) -> std::set<size_t> {
                                return _op.support();
                                }, operators[i]));  
    return supp;
}

void Block::extract_measures(size_t index) { // the operator at index should be a measure
    Operator op = operators[index]; 
    if (!std::holds_alternative<Measure>(op)) return; 
    Measure& M = std::get<Measure>(op); 
    Block subcirc = Block(); 
    size_t q = qubits() + 1; 
    Vectorized_Pauli Xq = Vectorized_Pauli("X" + std::to_string(q)); 

    // ??? 
    subcirc.push(Reset("Z" + std::to_string(q)));
    subcirc.push(Clifford(M.pauli * Xq)); 
    subcirc.push(Clifford(M.pauli)); 
    subcirc.push(Clifford(Xq)); 
    subcirc.push(Error(M.pauli)); 
    subcirc.push(Measure("Z" + std::to_string(q), M.sign, M.probability)); 
    splice(index, subcirc); 
}

void Block::extract_measures() {
    size_t index = 0; 
    Operator op; 
    while (index < length()) {
        op = operators[index]; 
        if (std::holds_alternative<Measure>(op)) {
            // checks if this operation involves more than one qubit 
            if (std::visit([](const auto& _op) {return _op.weight(); }, op) > 1) {
                extract_measures(index); 
            }
            else 
            {
                // index of the first (and only) qubit in the operation
                size_t q = std::visit([](const auto& _op) {return *(_op.support().begin()); }, op); 
                // else, the operation involves a single qubit and you check whether there are more operations 
                // on this qubit after the measurement
                std::set<size_t> supp = support(index + 1); 
                if (supp.find(q) != supp.end()) {
                    extract_measures(index); 
                }
            }
        }
        ++index; 
    }
}

// doesn't add errors 
void Block::add_resets() {
    for (size_t q = 1; q <= qubits(); ++q) {
        Operator first_op = Operator(); // in case there is no operator acting on the qubit at index 
        // finds the first operator that acts on the qubit at index
        for (const Operator& op : operators) {
            std::set<size_t> supp = std::visit([](const auto& _op) {
                return _op.support();
            }, op);
            if (supp.find(q) != supp.end()) {
                first_op = op; 
                break; 
            }
        }
        if (!std::holds_alternative<Reset>(first_op)) 
            push_first(Reset(q)); 
    }
}

// for loops; also adds all the errors 
void Block::add_initial_resets() {
    for (size_t q = qubits(); q >= 1; --q) {
        Operator first_op = Operator(); // in case there is no operator acting on the qubit at index 
        // finds the first operator that acts on the qubit at index
        for (const Operator& op : operators) {
            std::set<size_t> supp = std::visit([](const auto& _op) {
                return _op.support();
            }, op);
            if (supp.find(q) != supp.end()) {
                first_op = op; 
                break; 
            }
        }
        if (!std::holds_alternative<Reset>(first_op)) {
            push_first(Error(Reset(q))); 
            push_first(Reset(q)); 
        }
    }
}

// returns the index of the first non-reset after this sort 
size_t Block::pull_resets_first() {
    size_t last_reset = 0; 
    for (size_t index = operators.size(); index > 0; --index) {
        if (std::holds_alternative<Reset>(operators[index - 1])) {
            last_reset = index;
            break;
        }
    }
    if (last_reset != 0) {
        size_t index = last_reset; 
        while (index > 0) {
            Operator& op = operators[index - 1]; 
            // commutes every non-reset forwards to past the last reset
            // only resets should occur between index (inclusive) and last_reset (non-inclusive)
            if (!std::holds_alternative<Reset>(op)) {
                for (size_t i = index; i < last_reset; ++i) {
                    const Reset& R = std::get<Reset>(operators[i]); 
                    std::visit([R](auto& _op) {commute_inplace(_op, R);}, op); 
                }
                operators.insert(operators.begin() + last_reset, std::move(op)); 
                operators.erase(operators.begin() + index - 1); // the -1 is because everything is greater by 1 to avoid a negative size_t
                --last_reset; 
            }
            --index; 
        }
        return last_reset; 
    }
    return 0; 
}

// this part of the circuit should only contain errors added for measurements
// and the measurements for the loop
// returns the index of the first measure after this sort 
size_t Block::push_merrors_last() {
    size_t first_measure = operators.size(); 
    for (size_t index = 0; index < operators.size(); ++index) {
        if (std::holds_alternative<Measure>(operators[index])) {
            first_measure = index; 
            break; 
        }
    }
    if (first_measure != operators.size()) {
        size_t index = operators.size() - 1; 
        while (index > first_measure) {
            const Operator& op = operators[index]; 
            // commutes every error in the last part past the measurements 
            if (std::holds_alternative<Error>(op)) {
                // The Error does not change when you commute it through with only errors and measurements 
                operators.insert(operators.end(), op); 
                operators.erase(operators.begin() + index);
            }
            --index; 
        }
    }
    return first_measure; 
}

void Block::pull_errors_through_gates(size_t first_gate, size_t last_error) {
    // number of errors 
    // std::cout << "Pulling errors through gates: the blocks is \n" << *this << std::endl; 
    int errors = 0; 
    for (size_t index = first_gate + 1; index <= last_error; ++index) {
        if (std::holds_alternative<Error>(operators[index])) {
            Error& E = std::get<Error>(operators[index]); 
            for (size_t i = index; i > first_gate + errors; --i) {
                const Operator& op2 = operators[i - 1];
                // std::cout << "Commuting error with " << op2 << std::endl;
                std::visit([&E](const auto& _op2) {commute_back_inplace(E, _op2); }, op2);
            }
            // since errors always commute with each other, we can always insert errors to the very beginning
            // and skip the commuting across the errors part             
            operators.insert(operators.begin(), std::move(E)); 
            operators.erase(operators.begin() + index + 1); // because there is something inserted into the operator, the index will be +1
            ++errors; 
        }
    }
}

void Block::push_measures_through_gates(size_t last_gate) {
    // std::cout << "Inside push measures: \n" << *this << std::endl; 
    size_t updated_last = last_gate; 
    for (size_t index = 0; index < updated_last;) {
        if (std::holds_alternative<Measure>(operators[index])) {
            Measure& M = std::get<Measure>(operators[index]);  
            // assumes that after the first measure and before the first reset, only gates and measures are possible
            for (size_t i = index + 1; i <= updated_last; ++i) { 
                if (std::holds_alternative<Clifford>(operators[i])) {
                    commute_inplace(M, std::get<Clifford>(operators[i])); 
                }
            }
            operators.insert(operators.begin() + last_gate + 1, std::move(M)); 
            operators.erase(operators.begin() + index); 
            --updated_last; 
        } else {
            ++index; 
        }
    }
}

void Block::reorder() {
    size_t index = 0; 
    while(index < length()) {
        const Operator& op = operators[index]; 
        if (std::holds_alternative<Reset>(op)) {
            operators.insert(operators.begin(), std::move(op));
            operators.erase(operators.begin() + index + 1); 
        } else {
            // moves all the measures to the end 
            // In general, it is assumed that only Errors will be after measurements at this point
            // and the errors and measurements should commute so WLOG, the errors can be commuted back 
            // through the measurements 
            if (std::holds_alternative<Measure>(op)) {
                // checks if anything after this operator is not a Measure 
                bool not_a_measure = false;
                for (size_t i = index + 1; i < operators.size(); ++i) {
                    if (!std::holds_alternative<Measure>(operators[i])) {
                        not_a_measure = true; 
                        break; 
                    }
                }
                if (not_a_measure) {
                    operators.insert(operators.end(), std::move(op)); 
                    operators.erase(operators.begin() + index); 
                    --index; 
                }
            }
        }
        ++index; 
    }
}

void Block::add_reset_errors() {
    size_t index = 0; 
    while (index < length()) {
        if (std::holds_alternative<Reset>(operators[index])) {
            operators.insert(operators.begin() + index + 1, Error(std::get<Reset>((*this)[index])));
            ++index;  
        }
        ++index; 
    }
}

void Block::add_measure_errors() {
    size_t index = 0; 
    while (index < length()) {
        if (std::holds_alternative<Measure>((operators[index]))) {
            operators.insert(operators.begin() + index + 1, Error(std::get<Measure>((*this)[index])));
            ++index; 
        }
        ++index; 
    }
}

void Block::standardize(bool am) {
    // if (am) extract_measures(); 
    // if (!am) add_measure_errors();     
    // reorder(); 
    // add_reset_errors(); 

    // put this modified circuit into the format: 
    //      RESETS - ERRORS - GATES - MEASURES - MEASURE ERRORS
    // size_t start = pull_resets_first(); // index of first non-reset in circuit
    // size_t end = push_merrors_last() - 1; // index of last error
    size_t size = operators.size(); 
    size_t last_gate = size; 
    size_t last_error = size; 
    size_t i = size - 1; 
    while(!std::holds_alternative<Clifford>(operators[i]) && i > 0) {
        --i; 
    }
    if (i != 0 || std::holds_alternative<Clifford>(operators[0])) {
        last_gate = i; 
        push_measures_through_gates(last_gate); 
    }
    i = size - 1; 
    while(!std::holds_alternative<Error>(operators[i]) && i > 0) {
        --i; 
    }
    if (i != 0 || std::holds_alternative<Error>(operators[0])) 
        last_error = i; 
    i = 0; 
    while (!std::holds_alternative<Clifford>(operators[i]) && i < size) {
        ++i; 
    }
    if (i != size) {
        pull_errors_through_gates(i, last_error); 
    }
    // std::cout << "After standardizing: \n" << *this; 
}

size_t Block::measurements() const {
    size_t count = 0; 
    for (const Operator& op : operators) {
        if (std::holds_alternative<Measure>(op)) ++count; 
    }
    return count; 
}

std::ostream& operator<<(std::ostream& os, const Block& circ) {
    // size_t q = circ.qubits();  
    for (const Operator& op : circ.operators)
        os << op << "\n";  
        // os << fixed_length_string(op, q) << "\n"; 
    return os; 
}

Block combine(const Block& C1, const Block& C2) {
    Block circ; 
    circ.operators = C1.operators; 
    for (const Operator& op: C2.operators) {
        circ.operators.push_back(op); 
    }
    return circ; 
}

Standardized_Block::Standardized_Block(const std::vector<Operator>& ops, std::optional<size_t> aq, bool am) {
    ancilla_measure = am; 
    std_block = Block(ops); 
    std_block.standardize(am); 
    actual_qubit = aq ? *aq : std_block.qubits(); 
}

Standardized_Block::Standardized_Block(const std::initializer_list<Operator>& ops, std::optional<size_t> aq, bool am) {
    ancilla_measure = am; 
    std_block = Block(ops); 
    std_block.standardize(am); 
    actual_qubit = aq ? *aq : std_block.qubits(); 
}

Standardized_Block::Standardized_Block(const Block& B, std::optional<size_t> aq, bool am) {
    ancilla_measure = am; 
    std_block = B; 
    std_block.standardize(am); 
    actual_qubit = aq ? *aq : std_block.qubits(); 
}

size_t Standardized_Block::length() const {
    return std_block.length(); 
}

size_t Standardized_Block::qubits() const {
    return std_block.qubits(); 
}

std::set<size_t> Standardized_Block::support(
    std::optional<size_t> left_index,
    std::optional<size_t> right_index
) const {
    return std_block.support(left_index, right_index); 
}

size_t Standardized_Block::measurements() const {
    return std_block.measurements(); 
}

std::ostream& operator<<(std::ostream& os, const Standardized_Block& block) {
    os << block.std_block; 
    return os; 
}

// size_t is the index of the repeat in the circ and uint64_t is the number of times the loop body is repeated
std::vector<Block> parse(Block& circ) { 
    std::vector<Block> lst; 
    size_t length = circ.length(); 
    size_t index = 0; 
    size_t start = 0; 
    size_t end = 0; 
    while (index < length) {
        while ((std::holds_alternative<Clifford>(circ[index]) || std::holds_alternative<Error>(circ[index])) && index < length) 
            ++index; 
        if (std::holds_alternative<Measure>(circ[index])) {
            while ((std::holds_alternative<Measure>(circ[index]) || std::holds_alternative<Clifford>(circ[index])) && index < length)
                ++index; 
            while (std::holds_alternative<Reset>(circ[index]) && index < length)
                ++index; 
            end = index; 
        } else { // holds a reset
            while (std::holds_alternative<Reset>(circ[index]) && index < length) 
                ++index; 
            end = index; 
        }
        std::vector<Operator> ops; 
        for (size_t i = 0; i < end - start; ++i) {
            ops.push_back(circ[start + i]); 
        }
        lst.push_back(Block(ops)); 
        start = end; 
    }
    return lst; 
}
</file>

<file path="Sample_Circuits/Loop/Block.h">
#ifndef _STIM_CIRCUIT
#define _STIM_CIRCUIT      

#include "../../Test_Pauli/Stim_Pauli.h"
#include "Operator.h"

// A subcircuit consisting of only Operators 
struct Block {
    std::vector<Operator> operators; 
    Block() = default; 
    Block(const Block&) = default; 
    Block(Block&&) noexcept = default;
    Block& operator=(const Block&) = default;
    Block& operator=(Block&&) noexcept = default;
    Block(const std::vector<Operator>& ops) : operators(ops) {} 
    Block(const std::initializer_list<Operator>& ops);

    const Operator& operator[] (size_t index) const; 
    Operator& operator[] (size_t index); 
    // set index
    void push(const Operator& op); 
    void push_first(const Operator& op); 
    void append(std::initializer_list<Operator> ops); 
    void append(std::initializer_list<Block> subcircs);
    void splice(size_t index, const Block& subcirc=Block());  

    size_t length() const; 
    size_t qubits() const; 
    std::set<size_t> support(
        std::optional<size_t> left_index=std::nullopt,
        std::optional<size_t> right_index=std::nullopt
    ) const; 
    void extract_measures(size_t index); 
    void extract_measures(); 
    void add_resets(); 
    void add_initial_resets(); 
    size_t pull_resets_first(); 
    size_t push_merrors_last(); 
    void pull_errors_through_gates(size_t first_gate, size_t last_error); 
    void push_measures_through_gates(size_t last_gate); 
    void reorder(); 
    void add_reset_errors(); 
    void add_measure_errors(); 
    void standardize(bool am = true); 

    size_t measurements() const; 
} ; 

std::ostream& operator<<(std::ostream& os, const Block& circ);

// A block in standardized form
struct Standardized_Block {
    bool ancilla_measure;
    Block std_block;  
    size_t actual_qubit; 

    Standardized_Block() = default; 
    Standardized_Block(const Standardized_Block&) = default; 
    Standardized_Block(Standardized_Block&&) noexcept = default;
    Standardized_Block& operator=(const Standardized_Block&) = default;
    Standardized_Block& operator=(Standardized_Block&&) noexcept = default;
    explicit Standardized_Block(const std::vector<Operator>& ops, std::optional<size_t> aq=std::nullopt, bool am=true);
    explicit Standardized_Block(const std::initializer_list<Operator>& ops, std::optional<size_t> aq=std::nullopt, bool am=true);
    explicit Standardized_Block(const Block& B, std::optional<size_t> aq=std::nullopt, bool am=true);

    size_t length() const; 
    size_t qubits() const; 
    std::set<size_t> support(
        std::optional<size_t> left_index=std::nullopt,
        std::optional<size_t> right_index=std::nullopt
    ) const; 
    size_t measurements() const; 
} ; 

std::ostream& operator<<(std::ostream& os, const Standardized_Block& block);
 
Block combine(const Block& C1, const Block& C2); 
std::vector<Block> parse(Block& circ);                                   

#endif
</file>

<file path="Sample_Circuits/Loop/CMakeLists.txt">
cmake_minimum_required(VERSION 3.10)
project(Stim LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -Wall -Wextra")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3 -march=native -mavx2 -ffast-math -DNDEBUG")
# add_compile_options(-Wall -Wextra -O3 -mavx2 -g)

set(SOURCES
    ../../Test_Pauli/Stim_Pauli.cc
    main.cc
    ../../Pauli.cc 
    ../../Permutation.cc
    Operator.cc
    Block.cc
    tests.cc
    Loop.cc
    Sample.cc
)

# Find M4RI library
find_path(M4RI_INCLUDE_DIR
    NAMES m4ri.h
    PATHS /usr/include /usr/local/include $ENV{M4RI_DIR}/include
)

find_library(M4RI_LIBRARY
    NAMES m4ri
    PATHS /usr/lib /usr/local/lib $ENV{M4RI_DIR}/lib
)

if(NOT M4RI_INCLUDE_DIR OR NOT M4RI_LIBRARY)
    message(FATAL_ERROR "Could not find M4RI library or headers. Please install M4RI or set M4RI_DIR.")
endif()

message(STATUS "Found M4RI include dir: ${M4RI_INCLUDE_DIR}")
message(STATUS "Found M4RI library: ${M4RI_LIBRARY}")

find_path(GraphBLAS_INCLUDE_DIR
    NAMES GraphBLAS.h
    PATHS $ENV{HOME}/graphblas-install/include
)

find_library(GraphBLAS_LIBRARY
    NAMES graphblas
    PATHS $ENV{HOME}/graphblas-install/lib
)

if(NOT GraphBLAS_INCLUDE_DIR OR NOT GraphBLAS_LIBRARY)
    message(FATAL_ERROR "Could not find GraphBLAS library or headers. Please check your installation.")
endif()

message(STATUS "Found GraphBLAS include dir: ${GraphBLAS_INCLUDE_DIR}")
message(STATUS "Found GraphBLAS library: ${GraphBLAS_LIBRARY}")

add_executable(test ${SOURCES})

target_include_directories(test PRIVATE ${M4RI_INCLUDE_DIR} ${GraphBLAS_INCLUDE_DIR})
target_link_libraries(test PRIVATE ${M4RI_LIBRARY} ${GraphBLAS_LIBRARY})
</file>

<file path="Sample_Circuits/Loop/Loop.cc">
#include "Loop.h"

Loop::Loop(const SubCircuit& C, int r) {
    reduced_body = std::vector<SubCircuit>{C}; 
    repeat = r; 
} 

Loop::Loop(const std::initializer_list<SubCircuit>& ops, int r) {
    reduced_body = std::vector<SubCircuit>(ops); 
    repeat = r; 
}

std::ostream& operator<<(std::ostream& os, const SubCircuit& sub) {
    std::visit([&os](const auto& _sub) {os << _sub;}, sub); 
    return os; 
}

std::ostream& operator<<(std::ostream& os, const Loop& loop) {
    os << "REPEAT FOR: " << loop.repeat << " TIMES \n";  
    os << "THE SIMPLIFIED BLOCK: " << std::endl; 
    for (const SubCircuit& reduced_b : loop.reduced_body) os << reduced_b << "\n"; 
    return os; 
}
</file>

<file path="Sample_Circuits/Loop/Loop.h">
#ifndef _STIM_LOOP
#define _STIM_LOOP

#include "Block.h"
#include <map>

struct Loop; 

using SubCircuit = std::variant<Standardized_Block, Loop>; 

struct Loop {
    std::vector<SubCircuit> reduced_body; 
    int repeat; 

    Loop() = default; 
    Loop(const Loop&) = default; 
    Loop& operator=(const Loop&) = default; 
    Loop(const SubCircuit& C, int r); 
    Loop(const std::initializer_list<SubCircuit>& ops, int r); 

    void set_repeat(int r) {repeat = r;} 
} ; 

// reproduces an equivalent circuit that is in the block format: (Resets), Errors, Gates, Measures, (Errors)
// gives reduced_body
void standardize(std::vector<SubCircuit>& body, bool am); 
Loop combine(const Loop& L1, const Loop& L2); 
std::ostream& operator<<(std::ostream& os, const Loop& loop); 

#endif
</file>

<file path="Sample_Circuits/Loop/main.cc">
#include "../../Test_Pauli/Stim_Pauli.h"
#include "Sample.h"
#include "tests.h"
#include <cassert>
#include <chrono>

using Clock = std::chrono::high_resolution_clock;

int main() {

    int shots = 1000000; 
    std::vector<std::pair<BitString, int64_t>> results; 
    SampleBlock l1 = SampleBlock(Standardized_Block(test2())); 
    std::cout << looptest2(); 
    SampleLoop l2 = SampleLoop((looptest2())); 
    std::cout << Standardized_Block(test2()); 
    std::cout << looptest2(); 
    std::cout << "\n\n" << l1 << l2; 

    auto start = Clock::now(); 
    results = bulk_measure(shots, std::vector<Sample>{l1, l2}); 
    auto end = Clock::now(); 
    std::cout << "It took: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << " ms \n"; 
    // SampleLoop sample_loop = SampleLoop(looptest2()); 
    // for (int i : sample_loop.rqubits) std::cout << i <<"\n"; 
    // for (Error E: sample_loop.errors) std::cout << "Actual Error: " << E << "\n"; 
    // for (Error E: sample_loop.merrors) std::cout << "Measurement Error: " << E << "\n"; 
    // for (std::pair<Pauli, std::pair<Pauli, BitString>> map : sample_loop.map) {
    //     std::cout << map.first << " maps to \n"; 
    //     std::cout << map.second.first << "\n"; 
    //     std::cout << map.second.second << "\n"; 
    // }
    // results = sample_loop.measure(shots, test2(), Circuit()); 
    for (std::pair<BitString, int64_t> pr : results) {
        std::cout << pr.first << " " << pr.second << "\n"; 
    }

    // benchmark_pauli_vs_vectorized(30000, 1000); 

    // // basic tests
    // Vectorized_Pauli P1 = Vectorized_Pauli({1, 2, 3, 4, 10}, {2, 6, 9}); 
    // std::cout << "The first Pauli is: " << P1 << "\n"; 
    // Vectorized_Pauli P2 = Vectorized_Pauli({1, 3, 5, 6, 7, 10}, {1, 2, 3, 4, 7, 9, 12}); 
    // std::cout << "The second Pauli is: " << P2 << "\n"; 
    // Vectorized_Pauli empty = Vectorized_Pauli({}, {});
    // std::cout << "The empty Pauli is: " << empty << "\n"; 

    // std::cout << "Pauli multiplication using * gives: " << P1 * P2 << "\n"; 
    // std::cout << "Pauli mulitplication using * the other way: " << P2 * P1 << "\n"; 
    // std::cout << "Pauli multiplication by idenity for P1: " << P1 * empty << "\n"; 
    // std::cout << "Pauli multiplication by idenity for P1 the other way: " << empty * P1 << "\n"; 
    // P1 *= P2; 
    // std::cout << "Pauli multiplication using *= for first smaller than second gives: " << P1 << "\n";  
    // P1 = Vectorized_Pauli({1, 2, 3, 4, 10}, {2, 6, 9});
    // P2 *= P1; 
    // std::cout << "Pauli multiplication using *= for second smaller than first gives: " << P2 << "\n";
    // P2 = Vectorized_Pauli({1, 3, 5, 6, 7, 10}, {1, 2, 3, 4, 7, 9, 12}); 
    // P1 *= empty; 
    // empty *= P2; 
    // std::cout << "Pauli multiplication using *= for identity gives: " << P1 << "\n"; 
    // std::cout << "Pauli multiplication using *= for identity gives: " << empty << "\n"; 

    // std::cout << P1[1] << " " << P1[3] << " " << P1[6] << "\n"; 
    // for (size_t i : P1.support()) {
    //     std::cout << i << " "; 
    // }
    // std::cout << "\n";
    // for (size_t i : P2.support()) {
    //     std::cout << i << " "; 
    // }
    // std::cout << "\n";
    // std::cout << P1.weight() << " " << P2.weight() << "\n"; 
    // std::cout << P1.qubits() << " " << P2.qubits() << "\n"; 
    // std::cout << (P1 ^ 0) << "\n"; 
    // std::cout << (P1 ^ 1) << "\n"; 
}
</file>

<file path="Sample_Circuits/Loop/Operator.cc">
#include "Operator.h"

// Cliffords 

Clifford::Clifford(const Clifford& C) {
    pauli = C.pauli.copy(); 
}

Clifford& Clifford::operator=(const Clifford& C) {
    pauli = C.pauli.copy(); 
    return *this; 
}


std::set<size_t> Clifford::support() const {
    return pauli.support(); 
}

size_t Clifford::weight() const {
    return pauli.weight(); 
}

size_t Clifford::qubits() const {
    return pauli.qubits(); 
}

void Clifford::change_qubit(size_t oldq, size_t newq) {
    pauli.change_qubit(oldq, newq); 
}

bool operator<(const Clifford& C1, const Clifford& C2) {
    return C1.pauli < C2.pauli; 
}

std::ostream& operator<<(std::ostream& os, const Clifford& C) {
    os << " C |" << C.pauli; 
    return os; 
}

std::string fixed_length_string(const Clifford& C, size_t qubits) {
    std::string str = " C | "; 
    str += fixed_length_string(C.pauli, qubits); 
    return str; 
}

Clifford commute(const Clifford& C, const Reset& R) {
    Vectorized_Pauli P = C.pauli.copy(); 
    P.delete_term(R.qubits());
    return Clifford(P); 
}

void commute_inplace(Clifford& C, const Reset& R) {
    C.pauli.delete_term(R.qubits()); 
}

// Resets 
Reset::Reset(const Reset& R) {
    pauli = R.pauli.copy(); 
}
    
Reset& Reset::operator=(const Reset& R) {
    pauli = R.pauli.copy();
    return *this; 
}

Reset::Reset(size_t index) 
    : Reset("Z" + std::to_string(index)) {}


Reset::Reset(const std::string& pauli_string) 
    : Reset(Vectorized_Pauli(pauli_string)) {}


std::set<size_t> Reset::support() const {
    return pauli.support(); 
}

size_t Reset::weight() const {
    return pauli.weight(); 
}

size_t Reset::qubits() const {
    return pauli.qubits(); 
}

bool operator<(const Reset& R1, const Reset& R2) {
    return R1.pauli < R2.pauli; 
}

std::ostream& operator<<(std::ostream& os, const Reset& R) {
    os << " R | " << R.pauli; 
    return os; 
}

std::string fixed_length_string(const Reset& R, size_t qubits) {
    std::string str = " R | "; 
    str += fixed_length_string(R.pauli, qubits); 
    return str;     
}

Reset commute(const Reset& R1, const Reset& R) {
    return R1; 
}

void commute_inplace(Reset& R1, const Reset& R2) {
    return; 
}

Vectorized_Pauli commute(const Vectorized_Pauli& P, const Reset& R) {
    Vectorized_Pauli P1 = P.copy(); 
    P1.delete_term(R.qubits());
    return P1; 
}

void commute_inplace(Vectorized_Pauli& P, const Reset& R) {
    P.delete_term(R.qubits()); 
}

void Reset::change_qubit(size_t oldq, size_t newq) {
    std::invalid_argument("The function change_qubit should not be called on a reset"); 
}

// Measures

Measure::Measure(const Measure& M) {
    pauli = M.pauli.copy(); 
    sign = M.sign; 
    probability = M.probability; 
}
    
Measure& Measure::operator=(const Measure& M) {
    pauli = M.pauli.copy(); 
    sign = M.sign; 
    probability = M.probability; 
    return *this; 
}

std::set<size_t> Measure::support() const {
    return pauli.support(); 
}

size_t Measure::weight() const {
    return pauli.weight(); 
}

size_t Measure::qubits() const {
    return pauli.qubits(); 
}

void Measure::change_qubit(size_t oldq, size_t newq) {
    pauli.change_qubit(oldq, newq); 
}

bool operator<(const Measure& M1, const Measure& M2) {
    return M1.pauli < M2.pauli; 
}

std::ostream& operator<<(std::ostream& os, const Measure& M) {
    os << (M.sign ? "-" : "+") << "M | " << M.pauli << " | " << M.probability; 
    return os; 
}

std::string fixed_length_string(const Measure& M, size_t qubits) {
    std::string str = (M.sign ? "-" : "+"); 
    str += "M | "; 
    str += fixed_length_string(M.pauli, qubits); 
    str += " | "; 
    str += std::to_string(M.probability); 
    return str;     
}

Measure commute(const Measure& M, const Reset& op) {
    throw std::invalid_argument("Cannot commute a measure forward through a reset"); 
} 

void commute_inplace(Measure& M, const Reset& R) {
    throw std::invalid_argument("Cannot commute a measure forward through a reset"); 
}

void commute_inplace(Measure&M, const Clifford& C) {
    commute_inplace(M.pauli, C.pauli); 
}

// Errors

Error::Error(const Error& E) {
    std::vector<Vectorized_Pauli> ps; 
    for (const Vectorized_Pauli& e: E.paulis) {
        ps.push_back(e.copy()); 
    }
    paulis = std::move(ps); 
    weights = E.weights; 
}

Error& Error::operator=(const Error& E) {
    if (this == &E) return *this; 
    std::vector<Vectorized_Pauli> ps; 
    for (const Vectorized_Pauli& P: E.paulis) {
        ps.push_back(P.copy()); 
    }
    paulis = std::move(ps); 
    weights = E.weights; 
    return *this; 
}

 Error::Error(const std::vector<Vectorized_Pauli>& Ps, const Weights& w) {
    if (Ps.size() != w.size()) throw std::invalid_argument("unmatched length"); 
    std::vector<Vectorized_Pauli> ps; 
    for (const Vectorized_Pauli& P: Ps) {
        ps.push_back(P.copy()); 
    }
    paulis = std::move(ps); 
    weights = w;
}

Error::Error(const Vectorized_Pauli& P) {
    paulis.push_back(Vectorized_Pauli()); 
    paulis.push_back(P.copy()); 
    weights = Weights({0.5, 0.5});
} 

Error::Error(const Reset& R) 
    : Error(R.pauli) {}


Error::Error(const Measure& M) 
    : Error(M.pauli) {}

// simplified model where every non-identity Vectorized Pauli errors occur with the same probability 
Error::Error(
    double probability, // probability that an error will occur (i.e. not just identity)
    const std::set<size_t>& support, 
    std::vector<char> pauli_terms
) {
    // Ensure 'I' is the first in the pauli terms 
    if (std::find(pauli_terms.begin(), pauli_terms.end(), 'I') != pauli_terms.begin()) {
        if (std::find(pauli_terms.begin(), pauli_terms.end(), 'I') != pauli_terms.end()) 
            pauli_terms.erase(std::find(pauli_terms.begin(), pauli_terms.end(), 'I')); 
        pauli_terms.insert(pauli_terms.begin(), 'I'); 
    }

    std::vector<Vectorized_Pauli> _paulis;
    std::vector<double> _weights;
    size_t w = static_cast<size_t>(std::pow(pauli_terms.size(), support.size())) - 1;

    _weights.push_back(1.0 - probability);
    for (size_t i = 0; i < w; ++i) {
        _weights.push_back(probability / w);
    }

    std::vector<std::vector<char>> combined_terms;
    cartesian_product(pauli_terms, support.size(), combined_terms);
        
    for (const std::vector<char>& term_seq : combined_terms) {
        std::vector<std::pair<char, size_t>> zipped;
        for (size_t i = 0; i < support.size(); ++i) {
            size_t index = *std::next(support.begin(), i); 
            std::pair<char, size_t> zip(term_seq[i], index); 
            zipped.push_back(zip);
        }
        _paulis.push_back(Vectorized_Pauli(zipped));
    }

    paulis = std::move(_paulis);
    weights = _weights; 
}

std::set<size_t> Error::support() const {
    std::set<size_t> res; 
    for (const Vectorized_Pauli& P : paulis) {
        std::set<size_t> supp = P.support(); 
        res.insert(supp.begin(), supp.end()); 
    }
    return res; 
}   

size_t Error::weight() const {
    return support().size(); 
}

size_t Error::qubits() const {
    const std::set<size_t>& supp = support(); 
    return supp.empty() ? 0 : *supp.rbegin(); // reverse begin posize_ts to the last and hence largest element
}

void Error::change_qubit(size_t oldq, size_t newq) {
    for (Vectorized_Pauli& P : paulis) {
        P.change_qubit(oldq, newq); 
    }
}

Error commute(const Error& E, const Clifford& C) {
    std::vector<Vectorized_Pauli> new_paulis;
    for (const Vectorized_Pauli& P : E.paulis) {
        new_paulis.push_back(commute(P, C.pauli)); 
    }
    return Error(new_paulis, E.weights);  
}

void commute_inplace(Error& E, const Clifford& C) {
    for (Vectorized_Pauli& P : E.paulis) {
        commute_inplace(P, C.pauli); 
    }
}

Vectorized_Pauli commute(const Vectorized_Pauli& P, const Clifford& C) {
    return commute(P, C.pauli); 
}

void commute_inplace(Vectorized_Pauli& P, const Clifford& C) {
    commute_inplace(P, C.pauli); 
}

Error commute(const Error& E1, const Error& E2) {
    return E1; 
}

void commute_inplace(Error& E1, const Error& E2) {
    return; 
}

Error commute(const Error& E, const Measure& M) {
    return E; 
}

void commute_inplace(Error& E, const Measure& M) {
    return; 
}

Error commute(const Error& E, const Reset& R) {
    std::vector<Vectorized_Pauli> new_paulis; 
    size_t q = R.qubits(); 
    for (const Vectorized_Pauli& P : E.paulis) {
        Vectorized_Pauli newP = P.copy(); 
        newP.delete_term(q);
        new_paulis.push_back(std::move(newP));
    }
    return Error(new_paulis, E.weights); 
}

void commute_inplace(Error& E, const Reset& R) {
    const size_t q = R.qubits(); 
    for (Vectorized_Pauli& P: E.paulis) {
        P.delete_term(q); 
    }
}

Error commute_back(const Error& E, const Clifford& C) {
    std::vector<Vectorized_Pauli> new_paulis;
    for (const Vectorized_Pauli& P : E.paulis) {
        new_paulis.push_back(commute(P, C.pauli)); 
    }
    return Error(new_paulis, E.weights);  
}

void commute_back_inplace(Error& E, const Clifford& C) {
    for (Vectorized_Pauli& P : E.paulis) {
        commute_back_inplace(P, C.pauli); 
    }
}

Error commute_back(const Error& E1, const Error& E2) {
    return E1; 
}

void commute_back_inplace(Error& E1, const Error& E2) {
    return; 
}

// an Error will only commute backwards with a measurement if the measurement does not measure the 
Error commute_back(const Error& E, const Measure& M) {
    throw std::invalid_argument("Cannot generally commute an error back through a measure"); 
}

void commute_back_inplace(Error& E, const Measure& M) {
    throw std::invalid_argument("Cannot generally commute an error back through a measure"); 
}

Error commute_back(const Error& E, const Reset& R) {
    throw std::invalid_argument("Cannot generally commute an error back through a reset"); 
}

void commute_back_inplace(Error& E, const Reset& R) {
    throw std::invalid_argument("Cannot generally commute an error back through a reset"); 
}

std::ostream& operator<<(std::ostream& os, const Error& E) {
    size_t q = E.qubits(); 
    for (size_t i = 0; i < E.paulis.size(); ++i) {
        os << " E | " << E.paulis[i] << " | " << std::to_string(E.weights.get(i));
        if (i != E.paulis.size() - 1) {
            os << "\n";
        }
    }
    return os; 
}

std::string fixed_length_string(const Error& E, size_t qubits) {
    std::string str = " E | "; 
    std::set<size_t> supp = E.support(); 
    size_t index = 1; 
    while (index <= qubits) {
        if (supp.find(index) != supp.end()) str += "E"; 
        else str += "."; 
        ++index; 
    }
    str += " | " + std::to_string(1 - E.weights.get(0)); 
    return str; 
}

bool operator<(const Operator& op1, const Operator& op2) {
    if (std::holds_alternative<Reset>(op1) && std::holds_alternative<Reset>(op2)) {
        return std::get<Reset>(op1) < std::get<Reset> (op2); 
    }
    else if (std::holds_alternative<Measure>(op1) && std::holds_alternative<Measure>(op2))
        return std::get<Measure>(op1) < std::get<Measure>(op2);
    else if (std::holds_alternative<Clifford>(op1) && std::holds_alternative<Clifford>(op2))
        return std::get<Clifford>(op1) < std::get<Clifford>(op2);
    else if (std::holds_alternative<Error>(op1) && std::holds_alternative<Error>(op2)) 
        throw::std::invalid_argument("Cannot compare two errors"); 
    else
        throw std::invalid_argument("Must compare two operators of the same type"); 
}

std::ostream& operator<<(std::ostream& os, const Operator& op) {
    if (std::holds_alternative<Reset>(op)) 
        os << std::get<Reset> (op); 
    else if (std::holds_alternative<Measure>(op))
        os << std::get<Measure>(op);
    else if (std::holds_alternative<Clifford>(op))
        os << std::get<Clifford>(op);
    else if (std::holds_alternative<Error>(op)) 
        os << std::get<Error>(op);
    return os; 
}

std::string fixed_length_string(const Operator& op, size_t qubits) {
    if (std::holds_alternative<Reset>(op)) 
        return fixed_length_string(std::get<Reset>(op), qubits); 
    else if (std::holds_alternative<Measure>(op))
        return fixed_length_string(std::get<Measure>(op), qubits);
    else if (std::holds_alternative<Clifford>(op)) {
        return fixed_length_string(std::get<Clifford>(op), qubits);
    }
    else if (std::holds_alternative<Error>(op)) 
        return fixed_length_string(std::get<Error>(op), qubits);
    throw std::logic_error("The Operator must be one of: Reset, Measure, Clifford, or Error"); 
}

// helper functions

// outputs the cartesian product of length lists
void cartesian_product(
    const std::vector<char>& lst,
    size_t n,
    std::vector<std::vector<char>>& result
) {
    size_t choices = lst.size();
    std::vector<size_t> indices(n, 0);
    std::vector<char> current(n, 'I');
    size_t pos = 0; 
    while (true) {
        while (indices[pos] <= choices - 1) {
            current[pos] = lst[indices[pos]]; 
            result.push_back(current);
            ++indices[pos];
        }
        --indices[pos]; // make it go back to choices - 1
        while (pos < n && indices[pos] == choices - 1) ++pos; 
        if (pos == n) break; 
        else {
            ++indices[pos]; 
            for (size_t i = 0; i < pos; ++i) {
                indices[i] = 0; 
                current[i] = 'I'; 
            }
            current[pos] = lst[indices[pos]]; 
            pos = 0; 
        }
    }
}
</file>

<file path="Sample_Circuits/Loop/Operator.h">
#ifndef _STIM_OPERATOR
#define _STIM_OPERATOR

#include "../../Test_Pauli/Stim_Pauli.h"
#include "../../Test_Pauli/Weights.h"
#include <variant>

struct Clifford {
    Vectorized_Pauli pauli; 

    explicit Clifford(const Vectorized_Pauli& P) : pauli(P.copy()) {}
    Clifford(const Clifford&);
    Clifford& operator=(const Clifford&);
    Clifford& operator=(Clifford&&) = default; 
    Clifford() = default; 
    template <typename T>
    Clifford(T any)
        : Clifford(Vectorized_Pauli(any)) {}

    std::set<size_t> support() const; 
    size_t weight() const; 
    size_t qubits() const; 
    void permute(const Permutation& perm); 

    void change_qubit(size_t oldq, size_t newq); 
} ; 

bool operator<(const Clifford& C1, const Clifford& C2); 

struct Reset {
    Vectorized_Pauli pauli; 

    explicit Reset(const Vectorized_Pauli& P) {
        if (P.weight() == 1) pauli = P.copy(); 
        else throw std::invalid_argument("Reset only valid for single-qubit Vectorized Pauli"); 
    }
    Reset(const Reset&);
    Reset& operator=(const Reset&);
    Reset& operator=(Reset&&) = default; 
    Reset() = default; 
    Reset(size_t index);
    Reset(const std::string& pauli_string); 

    std::set<size_t> support() const;
    size_t weight() const; 
    size_t qubits() const; 
    void permute(const Permutation& perm); 

    void change_qubit(size_t oldq, size_t newq); 
} ;

bool operator<(const Reset& R1, const Reset& R2); 

struct Measure {
    Vectorized_Pauli pauli; 
    bool sign; 
    double probability; 

    Measure() = default; 
    Measure(const Measure&);
    Measure& operator=(const Measure&);
    Measure& operator=(Measure&&) = default; 
    explicit Measure(const Vectorized_Pauli& P, bool sgn=false, double prob=0)
        : pauli(P.copy()), sign(sgn), probability((0 <= prob && prob <= 1) ? prob : throw std::invalid_argument("Probability must be between 0 and 1")) {}
    template <typename T>
    Measure(T any, bool sign=false, double probability=0) 
        : Measure(Vectorized_Pauli(any), sign, probability) {}
    

    std::set<size_t> support() const;
    size_t weight() const; 
    size_t qubits() const;  
    void permute(const Permutation& perm);

    void change_qubit(size_t oldq, size_t newq); 
} ;

bool operator<(const Measure& M1, const Measure& M2); 

struct Error {
    std::vector<Vectorized_Pauli> paulis;
    Weights weights;  

    Error() = default; 
    Error(const Error& E);
    Error& operator=(const Error& E); 
    Error& operator=(Error&&) = default; 
    explicit Error(const std::vector<Vectorized_Pauli>& Ps, const Weights& w); 
    explicit Error(const Vectorized_Pauli& P);
    explicit Error(const Reset& R);
    explicit Error(const Measure& M);
    template <typename T>
    Error(T any) 
        : Error(Vectorized_Pauli(any)) {}
    

    // simplified model where every non-identity Pauli errors occur with the same probability 
    Error(
        double probability, // probability that an error will occur (i.e. not just identity)
        const std::set<size_t>& support, 
        std::vector<char> pauli_terms = {'I', 'X', 'Y', 'Z'}
    );

    std::set<size_t> support() const;
    size_t weight() const; 
    size_t qubits() const; 
    void permute(const Permutation& perm); 

    void change_qubit(size_t oldq, size_t newq); 
} ;

// define Operator which is composed of Clifford, Reset, Measure, and Error
using Operator = std::variant<Clifford, Reset, Measure, Error>; 

Clifford commute(const Clifford& C, const Reset& R);
void commute_inplace(Clifford& C, const Reset& R); 
Vectorized_Pauli commute(const Vectorized_Pauli& P, const Clifford& C); 
void commute_inplace(Vectorized_Pauli& P, const Clifford& C); 
std::ostream& operator<<(std::ostream& os, const Clifford& C); 
std::string fixed_length_string(const Clifford& C, size_t qubits);

std::ostream& operator<<(std::ostream& os, const Reset& R); 
std::string fixed_length_string(const Reset& R, size_t qubits);
Reset commute(const Reset& R1, const Reset& R2); 
void commute_inplace(Reset& R1, const Reset& R2); 
Vectorized_Pauli commute(const Vectorized_Pauli& P, const Reset& R); 
void commute_inplace(Vectorized_Pauli& P, const Reset& R); 

Measure commute(const Measure& M, const Reset& op);
void commute_inplace(Measure& M, const Reset& R); 
void commute_inplace(Measure&M, const Clifford& C); 

std::ostream& operator<<(std::ostream& os, const Measure& M); 
std::string fixed_length_string(const Measure& M, size_t qubits);

Error commute(const Error& E, const Clifford& C);
void commute_inplace(Error& E, const Clifford& C); 
Error commute(const Error& E1, const Error& E2); 
void commute_inplace(Error& E1, const Error& E2); 
Error commute(const Error& E, const Measure& M); 
void commute_inplace(Error& E, const Measure& M); 
Error commute(const Error& E, const Reset& R); 
void commute_inplace(Error& E, const Reset& R); 
Error commute_back(const Error& E, const Clifford& C); 
void commute_back_inplace(Error& E, const Clifford& C); 
Error commute_back(const Error& E1, const Error& E2); 
void commute_back_inplace(Error& E1, const Error& E2); 
Error commute_back(const Error& E, const Measure& M); 
void commute_back_inplace(Error& E, const Measure& M); 
Error commute_back(const Error& E, const Reset& R); 
void commute_back_inplace(Error& E, const Reset& R); 
std::ostream& operator<<(std::ostream& os, const Error& E); 
std::string fixed_length_string(const Error& E, size_t qubits);  

bool operator<(const Operator& op1, const Operator& op2); 
std::ostream& operator<<(std::ostream& os, const Operator& op);
std::string fixed_length_string(const Operator& op, size_t qubits);  

// helper function 

void cartesian_product(
    const std::vector<char>& lst,
    size_t n,
    std::vector<std::vector<char>>& result
); 

#endif
</file>

<file path="Sample_Circuits/Loop/Sample.cc">
#include "Sample.h"
#include <chrono>

mzd_t* from_vectorized_avx(__m256i* data, size_t num_rows, size_t num_bits) {
    const size_t bits_per_word = 64;
    const size_t words_per_vec = 4;
    const size_t bits_per_vec = 256;
    const size_t vecs_per_row = (num_bits + bits_per_vec - 1) / bits_per_vec;

    // Allocate M4RI matrix
    mzd_t* M = mzd_init(num_rows, num_bits);

    for (size_t r = 0; r < num_rows; ++r) {
        word* row_dst = M->data + r * M->rowstride;
        const __m256i* row_src = &data[r * vecs_per_row];

        for (size_t v = 0; v < vecs_per_row; ++v) {
            __m256i chunk = row_src[v];
            _mm256_storeu_si256((__m256i*)&row_dst[v * words_per_vec], chunk);
        }
    }
    return M;
}

mzd_t* from_vectorized_avx(const std::vector<Vectorized_Pauli>& pauli, size_t actual_qubits) {
    const size_t actual_word = (actual_qubits + 255) / 256; 
    const size_t num_bits = pauli[0].num_words * 256; 
    __m256i* xptr, zptr; 
    mzd_t* M = mzd_init(pauli.size() / 2, pauli[0].num_words * 256);
    for (size_t r = 0; r < pauli.size() / 2; ++r) {
        xptr = pauli[2 * r].xs; 
        word* row_dst = M->data + r * M->rowstride; 
        const __m256i* row_src = pauli[r * ((num_bits))].xs; 

        for (size_t v = 0; v < pauli[0].num_words; ++v) {
            __m256i chunk = row_src[v];
            _mm256_storeu_si256((__m256i*)&row_dst[v * 4], chunk);
        }
    }
    return M; 
}

mzd_t* from_vectorized_avx(const std::vector<BitString>& bs) {
    const size_t num_bits = bs[0].num_words * 256; 
    __m256i* xptr, zptr; 
    mzd_t* M = mzd_init(bs.size() / 2, bs[0].num_words * 256);
    for (size_t r = 0; r < bs.size() / 2; ++r) {
        word* row_dst = M->data + r * M->rowstride; 
        const __m256i* row_src = bs[r * ((num_bits))].bs; 

        for (size_t v = 0; v < bs[0].num_words; ++v) {
            __m256i chunk = row_src[v];
            _mm256_storeu_si256((__m256i*)&row_dst[v * 4], chunk);
        }
    }
    return M; 
}

BitString& BitString::operator=(const BitString& other) {
    if (this != &other) {
        if (bs) _mm_free(bs);
        allocate(other.num_bits);
        std::memcpy(bs, other.bs, num_words * sizeof(__m256i));
    }
    return *this;
}

BitString& BitString::operator=(BitString&& other) noexcept {
    if (this != &other) {
        if (bs) _mm_free(bs);
        bs = other.bs;
        num_bits = other.num_bits;
        num_words = other.num_words;
        other.bs = nullptr;
        other.num_bits = 0;
        other.num_words = 0;
    }
    return *this;
}

// XOR operator
BitString BitString::operator^(const BitString& other) const {
    if (num_words != other.num_words) {
        throw std::runtime_error("BitStrings must be same length for XOR");
    }
    BitString result(num_bits); 
    for (size_t i = 0; i < num_words; ++i) {
        __m256i a = _mm256_load_si256(&bs[i]);
        __m256i b = _mm256_load_si256(&other.bs[i]);
        _mm256_store_si256(&result.bs[i], _mm256_xor_si256(a, b));
    }
    return result;
}

// XOR-assignment
BitString& BitString::operator^=(const BitString& other) {
    if (num_words < other.num_words) {
        BitString res = BitString(other.num_words * 256); 
        for (size_t i = 0; i < num_words; ++i) {
            res.bs[i] = _mm256_xor_si256(bs[i], other.bs[i]); 
        }
        std::memcpy(res.bs + num_words, other.bs + num_words, (other.num_words - num_words) * sizeof(__m256i)); 
        *this = std::move(res); 
        return *this; 
    } else {
        for (size_t i = 0; i < num_words; ++i) {
            bs[i] = _mm256_xor_si256(bs[i], other.bs[i]); 
        }
        return *this; 
    }
}

// Bit access
bool BitString::operator[](size_t i) const {
    size_t index = i / 256;
    size_t bit = i % 256;
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    const uint64_t* data = reinterpret_cast<const uint64_t*>(bs + index);
    return data[lane] & (1ULL << bit_in_lane);
}

// Bit set
void BitString::set(size_t i, bool value) {
    if (i >= num_bits) {
        std::cerr << "Index out of bounds: " << i << std::endl;
        std::exit(1);
    }
    size_t index = i / 256;
    size_t bit = i % 256;
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    uint64_t* data = reinterpret_cast<uint64_t*>(bs + index);
    if (value)
        data[lane] |= (1ULL << bit_in_lane);
    else
        data[lane] &= ~(1ULL << bit_in_lane);
}

void BitString::bit_xor(size_t i, bool value) {
    size_t index = i / 256;
    size_t bit = i % 256;
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    uint64_t* data = reinterpret_cast<uint64_t*>(bs + index);
    data[lane] ^= (1ULL << bit_in_lane); 
}

bool BitString::operator==(const BitString& other) const {
    if (num_bits != other.num_bits) return false;
    const size_t vec_count = (num_words + 3) / 4;
    return std::memcmp(bs, other.bs, vec_count * sizeof(__m256i)) == 0;
}

// Printing
std::ostream& operator<<(std::ostream& os, const BitString& bs) {
    for (size_t i = 0; i < bs.num_bits; ++i) {
        os << (bs[i] ? '1' : '0');
    }
    return os;
}

BitString BitString::operator+(const BitString& other) const {
    BitString result(num_bits + other.num_bits);

    const size_t w = num_bits / BITS_PER_INT;
    const size_t b = num_bits % BITS_PER_INT;

    // Copy current data
    size_t num_u64 = num_words;
    std::memcpy(result.bs, bs, num_u64 * sizeof(uint64_t));

    const uint64_t* other_data = reinterpret_cast<const uint64_t*>(other.bs);
    uint64_t* result_data = reinterpret_cast<uint64_t*>(result.bs);

    if (b == 0) {
        std::memcpy(result_data + w, other_data, other.num_words * sizeof(uint64_t));
    } else {
        const size_t shift = BITS_PER_INT - b;
        uint64_t carry = 0;

        for (size_t i = 0; i < other.num_words; ++i) {
            uint64_t current = other_data[i];
            result_data[w + i]     |= current << b;
            carry                   = current >> shift;
            result_data[w + i + 1] |= carry;
        }
    }

    return result;
}

BitString& BitString::operator+=(const BitString& other) {
    const size_t old_num_bits = num_bits;
    const size_t old_words = num_words;
    const size_t new_bits = num_bits + other.num_bits;
    const size_t new_words = (new_bits + BITS_PER_INT - 1) / BITS_PER_INT;

    // Allocate new space
    __m256i* new_bs = (__m256i*)_mm_malloc(((new_words + 3) / 4) * sizeof(__m256i), alignof(__m256i));
    std::memset(new_bs, 0, ((new_words + 3) / 4) * sizeof(__m256i));

    // Copy existing data
    std::memcpy(new_bs, bs, old_words * sizeof(uint64_t));
    _mm_free(bs);
    bs = new_bs;
    num_bits = new_bits;
    num_words = new_words;

    const size_t w = old_num_bits / BITS_PER_INT;
    const size_t b = old_num_bits % BITS_PER_INT;

    const uint64_t* other_data = reinterpret_cast<const uint64_t*>(other.bs);
    uint64_t* this_data = reinterpret_cast<uint64_t*>(bs);

    if (b == 0) {
        std::memcpy(this_data + w, other_data, other.num_words * sizeof(uint64_t));
    } else {
        const size_t shift = BITS_PER_INT - b;
        uint64_t carry = 0;

        for (size_t i = 0; i < other.num_words; ++i) {
            uint64_t current = other_data[i];
            this_data[w + i]     |= current << b;
            carry                 = current >> shift;
            this_data[w + i + 1] |= carry;
        }
    }

    return *this;
}

// BitString BitString::operator^(const BitString& other) const {
//     if (bs.size() != other.bs.size()) [[unlikely]] {
//         throw std::runtime_error("Vectors must have the same size");
//     }
//     BitString result; 
//     result.num_bits = num_bits; 
//     result.bs.resize(bs.size()); 
    
//     const uint64_t* lhs = bs.data();
//     const uint64_t* rhs = other.bs.data();
//     uint64_t* res = result.bs.data();

//     for (size_t i = 0; i < bs.size(); ++i) {
//         res[i] = lhs[i] ^ rhs[i];
//     }

//     return result;
// }

// BitString& BitString::operator^=(const BitString& other) {
//     const size_t other_size = other.bs.size();
//     const size_t this_size = bs.size();

//     const size_t max_words = std::max(this_size, other_size);
//     if (max_words > 100000) {
//         std::cout << other << " and " << *this << std::endl; 
//         std::cout << max_words << " " << this_size << std::endl; 
//     }
//     if (this_size < max_words) {
//         bs.resize(max_words, 0);  // pad with 0s
//     }

//     const uint64_t* rhs = other.bs.data();
//     uint64_t* lhs = bs.data();
//     const size_t limit = std::min(this_size, other_size);

//     for (size_t i = 0; i < limit; ++i) {
//         lhs[i] ^= rhs[i];
//     }
//     if (other_size > this_size) {
//         for (size_t i = this_size; i < other_size; ++i) {
//             lhs[i] = rhs[i];
//         }
//     }

//     num_bits = std::max(num_bits, other.num_bits);
//     return *this;
// }

// std::ostream& operator<<(std::ostream& os, const BitString& bs) {
//     for (size_t i = 0; i < bs.num_bits; ++i) {
//         os << (bs[i] ? '1' : '0'); 
//     }
//     return os;
// }

// bool BitString::operator[](size_t i) const {
//     size_t w = i / BITS_PER_INT;
//     size_t b = i % BITS_PER_INT;
//     return (bs[w] >> b) & 1ULL; // (unsigned long long) 1
// }

// void BitString::set(size_t i, bool value) {
//     size_t w = i / BITS_PER_INT;
//     size_t b = i % BITS_PER_INT; 
//     if (w >= bs.size()) {
//         std::cerr << "ERROR: BitString::set index out of bounds. i=" << i
//               << ", w=" << w << ", bs.size()=" << bs.size() << std::endl;
//         std::exit(1);
//     }
//     if (value) {
//         bs[w] |= (1ULL << b);
//     }
//     else {
//         bs[w] &= ~(1ULL << b);
//     }
// }

// BitString BitString::operator+(const BitString& other) const {
//     BitString result(num_bits + other.num_bits);

//     const size_t w = num_bits / BITS_PER_INT;
//     const size_t b = num_bits % BITS_PER_INT;

//     std::copy(bs.begin(), bs.end(), result.bs.begin());

//     if (b == 0) {
//         std::copy(other.bs.begin(), other.bs.end(), result.bs.begin() + w);
//     } else {
//         const size_t shift = BITS_PER_INT - b;;
//         uint64_t carry = 0;

//         for (size_t i = 0; i < other.bs.size(); ++i) {
//             uint64_t current = other.bs[i];
//             result.bs[w + i]     |= current << b;
//             carry = current >> shift;
//             result.bs[w + i + 1] |= carry;
//         }
//     }
//     return result;
// }

// BitString& BitString::operator+=(const BitString& other) {
//     const size_t old_num_bits = num_bits;
//     const size_t new_num_bits = num_bits + other.num_bits;

//     bs.resize((new_num_bits + BITS_PER_INT - 1) / BITS_PER_INT, 0);  
//     num_bits = new_num_bits;

//     const size_t w = old_num_bits / BITS_PER_INT;
//     const size_t b = old_num_bits % BITS_PER_INT;

//     if (b == 0) {
//         std::copy(other.bs.begin(), other.bs.end(), bs.begin() + w);
//     } else {
//         const size_t shift = BITS_PER_INT - b;
//         uint64_t carry = 0;

//         for (size_t i = 0; i < other.bs.size(); ++i) {
//             uint64_t current = other.bs[i];
//             bs[w + i]     |= current << b;
//             carry = current >> shift;
//             bs[w + i + 1] |= carry;
//         }
//     }
//     return *this;
// }

// bool BitString::operator==(const BitString& other) const {
//     return num_bits == other.num_bits && bs == other.bs;
// }

SimpError SimplifyError(const Error& E, size_t data_offset, size_t total_offset) {
    SimpError SE; 
    for (size_t i = 0; i < E.paulis.size(); ++i) {
        const Vectorized_Pauli& P = E.paulis[i]; 
        SE.eindex.push_back(to_xz_sets(P, data_offset, total_offset)); 
    }
    SE.weights = E.weights; 
    return SE; 
}

std::ostream& operator<<(std::ostream& os, const SimpError& E) {
    for (size_t i = 0; i < E.eindex.size(); ++i) {
        os << "The Error on data qubits "; 
        for (size_t q : E.eindex[i].first) os << q << " "; 
        os << "\nand on on ancilla qubits "; 
        for (size_t q : E.eindex[i].second) os << q << " "; 
        os << "has a " << E.weights.get(i) << " probability of being multiplied on\n";
    }
    return os; 
}

SampleBlock::SampleBlock(const Standardized_Block& B) {
    size_t index = 0; 
    data_qubit = B.actual_qubit; 
    total_qubit = B.std_block.qubits(); 
    const std::vector<Operator>& ops = B.std_block.operators;
    while (index < ops.size() && std::holds_alternative<Reset>(ops[index])) {
        ++index; 
    }
    rqubits = resets_list(B, 0, index); 
    while (index < ops.size() && std::holds_alternative<Error>(ops[index])) {
        const Error& E = std::get<Error>(ops[index]); 
        // if (E.weights.get(0) == 0.5 && E.weights.get(1) == 0.5 && E.paulis[1].qubits() == 1) {
        if (E.weights.get(0) == 0.5 && E.weights.get(1) == 0.5) {
            const Vectorized_Pauli& P = E.paulis[1]; 
            half_error.push_back(to_xz_sets(P, data_qubit, total_qubit)); 
        } else {
            errors.push_back(SimplifyError(E, data_qubit, total_qubit)); 
        }
        ++index; 
    }
    size_t start = index; 
    while (index < ops.size() && std::holds_alternative<Clifford>(ops[index])) {
        ++index; 
    }
    const auto& _map = gates_block(B, start, index);
    data_Tmatrix = _map[0]; 
    ancilla_Tmatrix = _map[1];
    data_BSmatrix = _map[2]; 
    ancilla_BSmatrix = _map[3]; 
    while (index < ops.size() && std::holds_alternative<Measure>(ops[index])) {
        const Measure& M = std::get<Measure>(ops[index]); 
        measures.push_back(M); 
        mflips.push_back(M.probability); 
        ++index; 
    }
    measurements = measures.size(); 
    while (index < ops.size()) {
        merrors.push_back(to_xz_sets(std::get<Error>(ops[index]).paulis[1], data_qubit, total_qubit)); 
        ++index; 
    }
}

SampleBlock::SampleBlock(const SampleBlock& sl) {
    errors = sl.errors; 
    rqubits = sl.rqubits; 
    half_error = sl.half_error; 
    measures = sl.measures; 
    merrors = sl.merrors; 
    mflips = sl.mflips; 
    for (const auto& pr: sl.map) {
        map.push_back({pr.first.copy(), pr.second}); 
    }
}

SampleBlock& SampleBlock::operator=(const SampleBlock& sl) {
    errors = sl.errors; 
    rqubits = sl.rqubits; 
    half_error = sl.half_error; 
    measures = sl.measures; 
    merrors = sl.merrors; 
    mflips = sl.mflips; 
    for (auto& pr: map) {
        pr.first.free(); 
    }
    map.clear(); 
    for (const auto& pr: sl.map) {
        map.push_back({pr.first.copy(), pr.second}); 
    }
    return *this; 
}

void map_sampled_error_resets(const std::set<size_t>& rqubits, Vectorized_Pauli& P) {
    for (size_t i : rqubits) {
        P.delete_term(i); 
    }
}

void map_sampled_error_gates(
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& map, 
    const std::vector<double>& mflips, 
    Vectorized_Pauli& P, BitString& bs
) {
    static thread_local std::mt19937 gen(std::random_device{}()); 
    static thread_local std::uniform_real_distribution<double> dist(0, 1);
    BitString flips = BitString(map[0].second.num_bits); 
    // this require you knowing in advance the maximum qubit
    static Vectorized_Pauli _P; 
    uint64_t* xptr = reinterpret_cast<uint64_t*>(P.xs); 
    uint64_t* zptr = reinterpret_cast<uint64_t*>(P.zs); 
    for (size_t i = 0; i < P.num_words * 4; ++i) {
        uint64_t* xword = xptr + i;
        uint64_t* zword = zptr + i;  
        while (*xword) {
            int bit = __builtin_ctzll(*xword); 
            const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit]; 
            _P *= transformed.first; 
            flips ^= transformed.second;
            *xword &= *xword - 1; 
        }
        while (*zword) {
            int bit = __builtin_ctzll(*zword); 
            const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit + 1]; 
            _P *= transformed.first;  
            flips ^= transformed.second;
            *zword &= *zword - 1;
        }
    }
    std::swap(_P, P); 
    bs += flips; 
}

std::ostream& operator<<(std::ostream& os, const SampleBlock& sb) {
    os << "The resets: \n"; 
    for (size_t i : sb.rqubits) os << i << "\n"; 
    os << "The 50-50 errors: \n"; 
    for (auto& pr : sb.half_error) {
        os << "The Error on data qubits "; 
        for (size_t q : pr.first) os << q << " "; 
        os << "and on ancilla qubits "; 
        for (size_t q : pr.second) os << q << " "; 
        os << "has a " << "0.5 probability of being multiplied on\n";
    }
    os << "The errors: \n"; 
    for  (const SimpError& E: sb.errors) os << E << "\n\n"; 
    os << "The map: \n"; 
    for (const std::pair<Vectorized_Pauli, BitString>& pr: sb.map) os << pr.first << " " << pr.second << "\n"; 
    os << "The measurements: \n"; 
    for (const Measure& M: sb.measures) os << M << "\n"; 
    os << "The measurement errors: \n"; 
    for (size_t i = 0; i < sb.merrors.size(); ++i) {
        os << "The Error on data qubits "; 
        for (size_t q : sb.merrors[i].first) os << q << " "; 
        os << "and on ancilla qubits "; 
        for (size_t q : sb.merrors[i].second) os << q << " "; 
        os << "has a " << "0.5 probability of being multiplied on\n";
    } 
    return os; 
}

// returns the list of qubits to set to zero give [start, end) are all resets 
std::set<size_t> resets_list(
    const Standardized_Block& circ, 
    std::optional<size_t> start,
    std::optional<size_t> end
) {
    size_t first = circ.std_block.operators.size();
    size_t last = 0; 
    std::set<size_t> resets; 
    if (start) first = std::max((size_t)0, *start); 
    else {
        for (size_t i = 0; i < circ.std_block.operators.size(); ++i) {
            if (std::holds_alternative<Reset>(circ.std_block.operators[i])) {
                first = i; 
                break; 
            }
        }
    }
    if (end) last = std::max((size_t)0, *end); 
    else {
        for (size_t i = circ.std_block.operators.size(); i > 0; --i) {
            if (std::holds_alternative<Reset>(circ.std_block.operators[i - 1])) {
                last = i; 
                break; 
            }
        }
    }
    for (size_t i = first; i < last; ++i) {
        resets.insert(std::get<Reset>(circ.std_block[i]).qubits()); 
    }
    return resets; 
}

void transpose_inplace(
    size_t qubits, 
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& gates, 
    std::vector<Vectorized_Pauli>& Tmatrix,
    std::vector<BitString>& BSmatrix 
) {
    for (size_t q = 0; q < qubits; ++q) {
        const Vectorized_Pauli& Tx = gates[q].first; 
        const Vectorized_Pauli& Tz = gates[q + qubits].first; 
        const uint64_t* xptr = reinterpret_cast<uint64_t*>(Tx.xs); 
        const uint64_t* zptr = reinterpret_cast<uint64_t*>(Tx.zs); 
        for (size_t i = 0; i < Tx.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= qubits) break; 
                Tmatrix[2 * bit + 128 * i].set_index(q, 1); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= qubits) break; 
                Tmatrix[2 * qubits + 2 * bit + 128 * i].set_index(q, 1); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<uint64_t*>(Tz.xs); 
        zptr = reinterpret_cast<uint64_t*>(Tz.zs); 
        for (size_t i = 0; i < Tz.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= qubits) break; 
                Tmatrix[2 * bit + 128 * i + 1].set_index(q, 1); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= qubits) break; 
                Tmatrix[2 * qubits + 2 * bit + 128 * i + 1].set_index(q, 1); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<const uint64_t*>(gates[q].second.bs); 
        zptr = reinterpret_cast<const uint64_t*>(gates[q + qubits].second.bs); 
        for (size_t i = 0; i < gates[q].second.num_words; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i];
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                BSmatrix[2 * bit + 128 * i].set(q, 1);
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                BSmatrix[2 * bit + 128 * i + 1].set(q, 1);
                zword &= zword - 1; 
            }
        }
    }
}

void mzd_copy_first_n_paulis(
    mzd_t* dest, mzd_t* source, 
    size_t qubits, size_t offset
) {
    for (size_t r = 0; r < qubits; ++r) {
        mzd_copy_row(dest, r, source, r); 
    }
    for (size_t r = 0; r < qubits; ++r) {
        mzd_copy_row(dest, r + qubits, source, r + offset); 
    }
}

void transpose_inplace(
    size_t data_qubits,
    size_t total_qubits, 
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& gates, 
    mzd_t* data_Tmatrix,
    mzd_t* ancilla_Tmatrix,
    mzd_t* data_BSmatrix,
    mzd_t* ancilla_BSmatrix 
) { 
    for (size_t q = 0; q < data_qubits; ++q) {
        const Vectorized_Pauli& Tx = gates[q].first; 
        const Vectorized_Pauli& Tz = gates[q + total_qubits].first; 
        const uint64_t* xptr = reinterpret_cast<uint64_t*>(Tx.xs); // transformed pauli x-part of X_q
        const uint64_t* zptr = reinterpret_cast<uint64_t*>(Tx.zs); // transformed pauli z-part of X_q
        for (size_t i = 0; i < Tx.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= data_qubits) break; 
                mzd_write_bit(data_Tmatrix, bit + 64 * i, q, 1); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= data_qubits) break; 
                mzd_write_bit(data_Tmatrix, data_qubits + bit + 64 * i, q, 1); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<uint64_t*>(Tz.xs); // transfored pauli x-part of Z_q
        zptr = reinterpret_cast<uint64_t*>(Tz.zs); // transfored pauli z-part of Z_q
        for (size_t i = 0; i < Tz.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= data_qubits) break; 
                mzd_write_bit(data_Tmatrix, bit + 64 * i, q + data_qubits, 1);
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= data_qubits) break; 
                mzd_write_bit(data_Tmatrix, data_qubits + bit + 64 * i, q + data_qubits, 1); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<uint64_t*>(gates[q].second.bs); // transformation of X_q as a BitString
        zptr = reinterpret_cast<uint64_t*>(gates[q + total_qubits].second.bs); // transformation of Z_q as a BitString
        for (size_t i = 0; i < gates[q].second.num_words; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i];
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                mzd_write_bit(data_BSmatrix, bit + 64 * i, q, 1); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                mzd_write_bit(data_BSmatrix, bit + 64 * i, q + total_qubits, 1); 
                zword &= zword - 1; 
            }
        }
    }
    for (size_t q = data_qubits; q < total_qubits; ++q) {
        const Vectorized_Pauli& Tx = gates[q].first; 
        const Vectorized_Pauli& Tz = gates[q + total_qubits].first; 
        const uint64_t* xptr = reinterpret_cast<uint64_t*>(Tx.xs); // transformed pauli x-part of X_q
        const uint64_t* zptr = reinterpret_cast<uint64_t*>(Tx.zs); // transformed pauli z-part of X_q
        for (size_t i = 0; i < Tx.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= data_qubits) break; 
                mzd_write_bit(ancilla_Tmatrix, bit + 64 * i, q, 1); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= data_qubits) break; 
                mzd_write_bit(ancilla_Tmatrix, data_qubits + bit + 64 * i, q, 1); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<uint64_t*>(Tz.xs); // transfored pauli x-part of Z_q
        zptr = reinterpret_cast<uint64_t*>(Tz.zs); // transfored pauli z-part of Z_q
        for (size_t i = 0; i < Tz.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= data_qubits) break; 
                mzd_write_bit(ancilla_Tmatrix, bit + 64 * i, q + data_qubits, 1);
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= data_qubits) break; 
                mzd_write_bit(ancilla_Tmatrix, data_qubits + bit + 64 * i, q + data_qubits, 1); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<const uint64_t*>(gates[q].second.bs); // transformation of X_q as a BitString
        zptr = reinterpret_cast<const uint64_t*>(gates[q + total_qubits].second.bs); // transformation of Z_q as a BitString
        for (size_t i = 0; i < gates[q].second.num_words; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i];
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                mzd_write_bit(ancilla_BSmatrix, bit + 64 * i, q, 1); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                mzd_write_bit(ancilla_BSmatrix, bit + 64 * i, q + total_qubits, 1); 
                zword &= zword - 1; 
            }
        }
    }
}

std::vector<mzd_t*> gates_block(
    const Standardized_Block& circ, 
    std::optional<size_t> start, 
    std::optional<size_t> end
) {
    const size_t n = circ.std_block.operators.size();
    size_t cfirst = n + 1;
    size_t clast = n + 1; 
    size_t mlast = n + 1; 
    std::vector<std::pair<Vectorized_Pauli, BitString>> gates; 
    std::cout << circ << std::endl; 

    if (start) cfirst = *start; 
    else {
        for (size_t i = 0; i < n; ++i) {
            if (std::holds_alternative<Clifford>(circ.std_block.operators[i])) {
                cfirst = i; 
                break; 
            }
        }
    }
    if (end) clast = *end; 
    else {
        for (size_t i = n; i > 0; --i) {
            if (std::holds_alternative<Clifford>(circ.std_block.operators[i - 1])) {
                clast = i; 
                break; 
            }
        }
    }
    for (size_t i = n; i > 0; --i) {
        if (std::holds_alternative<Measure>(circ.std_block.operators[i - 1])) {
            mlast = i; 
            break; 
        }
    }
    if (mlast == n + 1) mlast = clast; 
    const size_t qubits = circ.qubits(); 
    // std::cout << "cfirst " << cfirst << " clast " << clast << " mlast " << mlast << " n " << n << std::endl; 
    for (size_t q = 1; q <= qubits; ++q) {
        Vectorized_Pauli X = Vectorized_Pauli("X" + std::to_string(q));
        Vectorized_Pauli Z = Vectorized_Pauli("Z" + std::to_string(q));
        for (size_t i = cfirst; i < clast; ++i) {
            commute_inplace(X, std::get<Clifford>(circ.std_block.operators[i])); 
            commute_inplace(Z, std::get<Clifford>(circ.std_block.operators[i])); 
        }
        BitString Xflip = BitString(mlast - clast); 
        BitString Zflip = BitString(mlast - clast); 
        // goes through all the measures 
        // the flips correspond to the measurement outputs AFTER the basis pauli has gone through all the gates 
        for (size_t i = clast; i < mlast; ++i) {
            const Measure& M = std::get<Measure>(circ.std_block[i]);
            Xflip.set(i - clast, ((X % M.pauli) != M.sign)); 
            Zflip.set(i - clast, ((Z % M.pauli) != M.sign));
        }
        std::cout << "X" << q <<  " maps to " << X << std::endl; 
        std::cout << "Z" << q <<  " maps to " << Z << std::endl; 
        gates.push_back(std::pair{std::move(X), Xflip}); 
        gates.push_back(std::pair{std::move(Z), Zflip}); 
    }
    std::cout << "The map has been created" << std::endl; 
    mzd_t* data_Tmatrix = mzd_init(2 * circ.actual_qubit, 2 * circ.actual_qubit); 
    mzd_t* ancilla_Tmatrix = mzd_init(2 * circ.actual_qubit, 2 * (qubits - circ.actual_qubit)); 
    mzd_t* data_BSmatrix = mzd_init(mlast - clast, 2 * circ.actual_qubit); 
    mzd_t* ancilla_BSmatrix = mzd_init(mlast - clast, 2 * (qubits - circ.actual_qubit)); 
    transpose_inplace(circ.actual_qubit, qubits, gates, data_Tmatrix, ancilla_Tmatrix, data_BSmatrix, ancilla_BSmatrix); 
    return std::vector<mzd_t*>{data_Tmatrix, ancilla_Tmatrix, data_BSmatrix, ancilla_BSmatrix};
}

void sample(const std::vector<Error>& errors, Vectorized_Pauli& P) {
    static std::mt19937 gen(std::random_device{}()); 
    for (const Error& E: errors) {
        std::discrete_distribution<> dist(E.weights.begin(), E.weights.end()); 
        const Vectorized_Pauli& choice = E.paulis[dist(gen)]; 
        P *= choice; 
    }
}

SampleLoop::SampleLoop(const Loop& L) {
    repeat = L.repeat; 
    for (const SubCircuit& subcirc : L.reduced_body) {
        if (std::holds_alternative<Standardized_Block>(subcirc)) {
            circ_lst.push_back(SampleBlock(std::get<Standardized_Block>(subcirc))); 
        } else {
            circ_lst.push_back(SampleLoop(std::get<Loop>(subcirc))); 
        }
    }
}

const Sample& SampleLoop::operator[](size_t index) const {
    return circ_lst[index]; 
}

// to compile for now 
void sample(const std::vector<SimpError>&, Vectorized_Pauli& P) {}
void sample(const std::vector<std::pair<std::set<size_t>, std::set<size_t>>>&, Vectorized_Pauli& P) {}

void measure(const SampleBlock& sb, Vectorized_Pauli& P, BitString& bs) {
    map_sampled_error_resets(sb.rqubits, P); 
    sample(sb.errors, P); 
    map_sampled_error_gates(sb.map, sb.mflips, P, bs); 
    sample(sb.merrors, P); 
}

void measure(const SampleLoop& sl, Vectorized_Pauli& P, BitString& bs) {
    for (int r = 0; r < sl.repeat; ++r) {
        for (const Sample& S : sl.circ_lst) {
            if (std::holds_alternative<SampleBlock>(S)) {
                measure(std::get<SampleBlock>(S), P, bs); 
            } else {
                measure(std::get<SampleLoop>(S), P, bs); 
            }
        }
    }
}

std::vector<std::pair<BitString, int64_t>> measure(int shots, const std::vector<Sample>& lst) {
    std::unordered_map<BitString, int64_t> samples; 
    std::vector<Error> first_reset_errors; 
    if (std::holds_alternative<SampleBlock>(lst[0])) {
        const SampleBlock& block = std::get<SampleBlock>(lst[0]); 
        for (size_t q = 1; q <= block.map.size() / 2; ++q) {
            if (block.rqubits.find(q) == block.rqubits.end())
                first_reset_errors.emplace_back(Vectorized_Pauli("Z" + std::to_string(q)));
        } 
    } else {
        const SampleLoop* loop = &std::get<SampleLoop>(lst[0]); 
        while (std::holds_alternative<SampleLoop>((*loop)[0])) loop = &std::get<SampleLoop>((*loop)[0]); 
        const SampleBlock& block = std::get<SampleBlock>((*loop)[0]); 
        for (size_t q = 1; q <= block.map.size() / 2; ++q) {
            if (block.rqubits.find(q) == block.rqubits.end())
                first_reset_errors.emplace_back(Vectorized_Pauli("Z" + std::to_string(q)));
        } 
    }
    
    for (int i = 0; i < shots; ++i) {
        if (i % 1000 == 0) std::cout << i << "\n"; 
        Vectorized_Pauli P; 
        sample(first_reset_errors, P); 
        BitString res = BitString(0); 
        for (const Sample& s : lst) {
            std::visit([&P, &res](const auto& _s) {measure(_s, P, res);}, s); 
        }
        ++(samples[res]); 
    }
    std::vector<std::pair<BitString, int64_t>> sorted(samples.begin(), samples.end()); 
    std::sort(sorted.begin(), sorted.end(), 
        [](const std::pair<BitString, int64_t>& a, const std::pair<BitString, int64_t>& b) { return a.second < b.second; }); 
    return sorted; 
}

void bulk_reset_map(const std::set<size_t>& rqubits, std::vector<Vectorized_Pauli>& paulis) {
    for (size_t i : rqubits) {
        for (Vectorized_Pauli& P: paulis)
            P.delete_term(i); 
    }
}

void bulk_reset_map(const std::set<size_t>& rqubits, mzd_t* data) {
    const size_t z_offset = data->nrows / 2; 
    const size_t row_bytes = data->rowstride * sizeof(word);
    for (size_t i : rqubits) {
        --i; 
        word* x_row_ptr = mzd_row(data, i);
        std::memset(x_row_ptr, 0, row_bytes);
        word* z_row_ptr = mzd_row(data, i + z_offset);
        std::memset(z_row_ptr, 0, row_bytes);
    }
}

void bulk_gate_map(
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& map, 
    const std::vector<double>& mflips, 
    std::vector<Vectorized_Pauli>& paulis,
    std::vector<BitString>& bs
) {
    static std::mt19937 gen(std::random_device{}()); 
    static std::uniform_real_distribution<double> dist(0.0, 1.0);
    static Vectorized_Pauli _P; 
    const int bits = map[0].second.num_bits;  
    const size_t size = map.size(); 
    for (size_t j = 0; j < paulis.size(); ++j) {
        Vectorized_Pauli& P = paulis[j]; 
        BitString flips = BitString(bits); 
        uint64_t* xptr = reinterpret_cast<uint64_t*>(P.xs); 
        uint64_t* zptr = reinterpret_cast<uint64_t*>(P.zs); 
        uint64_t* xend = xptr + P.num_words * 4; 
        uint64_t* zend = zptr + P.num_words * 4; 
        size_t index = 0; 
        while (xptr < xend) {
            while (*xptr) {
                int bit = __builtin_ctzll(*xptr); 
                if (index + 2 * bit >= size) {
                    while (xptr < xend) {
                        *xptr = 0; 
                        xptr++; 
                    }
                    break; 
                }
                const std::pair<Vectorized_Pauli, BitString>& transformed = map[index + 2 * bit]; 
                _P *= transformed.first; 
                flips ^= transformed.second;
                *xptr &= *xptr - 1; 
            }
            while (*zptr) { 
                int bit = __builtin_ctzll(*zptr); 
                if (index + 2 * bit + 1 >= size) {
                    while (zptr < zend) {
                        *zptr = 0; 
                        zptr++; 
                    }
                    break; 
                }
                const std::pair<Vectorized_Pauli, BitString>& transformed = map[index + 2 * bit + 1];
                _P *= transformed.first;  
                flips ^= transformed.second;
                *zptr &= *zptr - 1;
            }
            ++xptr; 
            ++zptr;
            index += 128; 
        }
        // for (size_t i = 0; i < mflips.size(); ++i) {
        //     if (dist(gen) < mflips[i]) {
        //         flips.bit_xor(i, 1);
        //     }
        // } 
        swap(_P, P); 
        // bs[j] += flips; 
    }
}

void bulk_gate_map(
    const mzd_t* data_Tmatrix,
    const mzd_t* ancilla_Tmatrix,
    const mzd_t* data_BSmatrix, 
    const mzd_t* ancilla_BSmatrix,
    const std::vector<double>& mflips, 
    mzd_t*& data,
    mzd_t* ancilla,
    mzd_t* flips
) {
    static std::mt19937 gen(std::random_device{}()); 
    static std::uniform_real_distribution<double> dist(0.0, 1.0);

    // std::cout << data->nrows << " " << data->ncols << std::endl;  
    mzd_t* temp = mzd_init(data->nrows, data->ncols); 

    mzd_mul(temp, data_Tmatrix, data, 128); 
    mzd_mul(flips, data_BSmatrix, data, 128); 
    if (ancilla)  {
        mzd_addmul(temp, ancilla_Tmatrix, ancilla, 128); 
        mzd_addmul(flips, ancilla_BSmatrix, ancilla, 128); 
    }
    std::swap(temp, data); 
    mzd_free(temp); 
    temp = nullptr; 
    // for (size_t i = 0; i < mflips.size(); ++i) {
    //     if (dist(gen) < mflips[i]) {
    //         flips.bit_xor(i, 1);
    //     }
    // } 
    // bs[j] += flips; 
}

void bulk_sample(const std::vector<Error>& errors, std::vector<Vectorized_Pauli>& P) {
    static thread_local std::mt19937_64 rng(std::random_device{}()); 
    size_t index; 
    float prob; 
    for (const Error& E: errors) {
        prob = 1 - E.weights.get(0); 
        std::geometric_distribution<size_t> dist(prob); 
        index = dist(rng); 
        while (index < P.size()) {
            int p = (E.paulis.size() <= 2) ? 1 : 1 + (rng() % (E.paulis.size() - 2)); 
            P[index] *= E.paulis[p]; 
            index += dist(rng); 
        }
    }
}

// this current implementation guarantees that every row is accessed only once but keeps an unordered map
// the other implementation to try is to access each row of the error every time an error is hit
void bulk_sample(const std::vector<SimpError>& errors, mzd_t* data, mzd_t* ancilla) {
    static thread_local std::mt19937_64 rng(std::random_device{}()); 
    std::unordered_map<size_t, std::vector<size_t>> data_hits; // the qubits number (row) and the trials for data qubits
    std::unordered_map<size_t, std::vector<size_t>> ancilla_hits; // the qubits number (row) and the trials for ancilla qubits
    size_t index; 
    float prob; 
    for (const SimpError& E: errors) {
        prob = 1 - E.weights.get(0); 
        std::geometric_distribution<size_t> dist(prob); 
        index = dist(rng); // the frame number (column)
        while (index < data->ncols) { // data->ncols = ancilla->ncols = number of trails in a go
            int p = (E.weights.size() <= 2) ? 1 : 1 + (rng() % (E.weights.size() - 2)); 
            for (size_t i : E.eindex[p].first) {
                data_hits[i].push_back(index); 
            }
            for (size_t i : E.eindex[p].second) {
                ancilla_hits[i].push_back(index); 
            }
            index += dist(rng); 
        }
    }
    for (const auto& pr : data_hits) {
        word *row = mzd_row(data, pr.first); 
        for (size_t c : pr.second) { // this is index in the above while loop
            row[c / 64] ^= 1ULL << c % 64; 
        }
    }
    for (const auto& pr : ancilla_hits) {
        word *row = mzd_row(ancilla, pr.first); 
        for (size_t c : pr.second) { // this is index in the above while loop
            row[c / 64] ^= 1ULL << c % 64; 
        }
    }
}

__m256i random_m256i(std::mt19937_64& rng) {
    alignas(32) uint64_t buffer[4] = { rng(), rng(), rng(), rng() };
    return _mm256_load_si256(reinterpret_cast<__m256i*>(buffer));
}

// assumes that every Pauli in paulis is initialized and hence at least as long as P
void bulk_sample_half(const Vectorized_Pauli& P, std::vector<Vectorized_Pauli>& paulis) {
    static thread_local std::mt19937_64 rng(std::random_device{}()); 
    for (Vectorized_Pauli& pauli : paulis) {
       for (size_t i = 0; i < P.num_words; ++i) {
            pauli.xs[i] = _mm256_xor_si256(pauli.xs[i], _mm256_and_si256(P.xs[i], _mm256_set_epi64x(rng(), rng(), rng(), rng())));
            pauli.zs[i] = _mm256_xor_si256(pauli.zs[i], _mm256_and_si256(P.zs[i], _mm256_set_epi64x(rng(), rng(), rng(), rng()))); 
        } 
    }
}

void bulk_sample_half(
    const std::vector<std::pair<std::set<size_t>, std::set<size_t>>>& half_error, 
    mzd_t* data, 
    mzd_t* ancilla
) {
    static thread_local std::mt19937_64 rng(std::random_device{}()); 
    const wi_t drowstride = data->rowstride;  
    const wi_t dwidth = data->width; 
    const wi_t arowstride = ancilla ? ancilla->rowstride : 0;  
    const wi_t awidth = ancilla ? ancilla->width : 0; 
    for (const std::pair<std::set<size_t>, std::set<size_t>>& pr : half_error) {
        std::vector<uint64_t> random; 
        word* row; 
        if (!pr.first.empty()) {
            row = data->data + *pr.first.begin() * drowstride; 
            for (wi_t w = 0; w < dwidth; ++w) {
                random.push_back(rng()); 
                row[w] ^= random[w]; 
            }
            for (auto it = std::next(pr.first.begin()); it != pr.first.end(); ++it) {
                word* row = data->data + *it * drowstride;
                for (wi_t w = 0; w < dwidth; ++w) {
                    row[w] ^= random[w]; 
                } 
            }
        }
        if (!pr.second.empty()) {
            row = ancilla->data + *pr.second.begin() * arowstride; 
            for (wi_t w = 0; w < awidth; ++w) {
                random.push_back(rng()); 
                row[w] ^= random[dwidth + w]; 
            }
            for (auto it = std::next(pr.second.begin()); it != pr.second.end(); ++it) {
                word* row = ancilla->data + *it * arowstride; 
                for (wi_t w = 0; w < awidth; ++w) {
                    row[w] ^= random[dwidth + w]; 
                }
            }
        }
        
    }
}

void bulk_measure(const SampleBlock& sb, mzd_t*& data, std::vector<mzd_t*>& allBS) {
    mzd_t* bs = mzd_init(sb.data_BSmatrix->nrows, data->ncols); 
    mzd_t* ancilla = nullptr; 
    if (sb.data_qubit != sb.total_qubit) {
        ancilla = mzd_init(2 * (sb.total_qubit - sb.data_qubit), data->ncols); 
    } 
    if (data->nrows != sb.data_Tmatrix->ncols) {
        mzd_t* temp = mzd_init(sb.data_Tmatrix->ncols, data->ncols);
        mzd_copy_first_n_paulis(temp, data, sb.data_Tmatrix->ncols / 2, data->nrows / 2); 
        std::swap(data, temp); 
        mzd_free(temp); 
        temp = nullptr; 
    }
    bulk_reset_map(sb.rqubits, data); 
    bulk_sample(sb.errors, data, ancilla);  
    bulk_sample_half(sb.half_error, data, ancilla);  
    bulk_gate_map(sb.data_Tmatrix, sb.ancilla_Tmatrix, sb.data_BSmatrix, sb.ancilla_BSmatrix, sb.mflips, data, ancilla, bs); 
    bulk_sample_half(sb.merrors, data, ancilla); 
    allBS.push_back(bs); 
    if (ancilla) {
        mzd_free(ancilla); 
        ancilla = nullptr; 
    }
}

void bulk_measure(const SampleLoop& sl, mzd_t*& P, std::vector<mzd_t*>& bs) {
    for (int r = 0; r < sl.repeat; ++r) {
        for (const Sample& S : sl.circ_lst) {
            if (std::holds_alternative<SampleBlock>(S)) {  
                bulk_measure(std::get<SampleBlock>(S), P, bs); 
            } else {
                bulk_measure(std::get<SampleLoop>(S), P, bs);
            }
        }
    }
}

std::vector<std::pair<BitString, int64_t>> bulk_measure(int shots, std::vector<Sample>& lst) {
    std::unordered_map<BitString, int64_t> samples; 
    std::vector<std::pair<std::set<size_t>, std::set<size_t>>> first_reset_errors; 
    size_t data_qubit; 
    size_t ancilla_qubit; 
    if (std::holds_alternative<SampleBlock>(lst[0])) {
        const SampleBlock& block = std::get<SampleBlock>(lst[0]); 
        data_qubit = block.data_qubit; 
        ancilla_qubit = block.total_qubit - data_qubit; 
        for (size_t q = 1; q <= block.total_qubit; ++q) {
            if (block.rqubits.find(q) == block.rqubits.end()) {
                if (q < data_qubit) 
                    first_reset_errors.emplace_back(std::pair{std::set<size_t>{q + data_qubit}, std::set<size_t>()}); 
                else
                    first_reset_errors.emplace_back(std::pair{std::set<size_t>(), std::set<size_t>{q + ancilla_qubit}});
            }
        } 
    } else {
        SampleLoop& loop = std::get<SampleLoop>(lst[0]);  
        while (std::holds_alternative<SampleLoop>(loop.circ_lst[0])) {
            loop = std::get<SampleLoop>(loop.circ_lst[0]); 
        }
        const SampleBlock& block = std::get<SampleBlock>((loop)[0]); 
        data_qubit = block.data_qubit; 
        ancilla_qubit = block.total_qubit - data_qubit; 
        for (size_t q = 1; q <= block.total_qubit; ++q) {
            if (block.rqubits.find(q) == block.rqubits.end()) {
                if (q < data_qubit) 
                    first_reset_errors.emplace_back(std::pair{std::set<size_t>{q + data_qubit}, std::set<size_t>()}); 
                else
                    first_reset_errors.emplace_back(std::pair{std::set<size_t>(), std::set<size_t>{q + ancilla_qubit}});
            }
        } 
    }

    for (int i = 0; i < shots/2000; ++i) {
        std::cout << i + 1 << "th 2000 samples \n"; 
        mzd_t* P = mzd_init(data_qubit * 2, 2000);
        bulk_sample_half(first_reset_errors, P, nullptr); 
        std::vector<mzd_t*> res; 
        for (const Sample& s : lst) { 
            std::visit([&P, &res](const auto& _s) {bulk_measure(_s, P, res);}, s); 
        }
        mzd_free(P); 
        P = nullptr; 
        // for (int j = 0; j < 2000; ++j) ++samples[res[j]]; 
    }
    std::vector<std::pair<BitString, int64_t>> sorted(samples.begin(), samples.end()); 
    // std::sort(sorted.begin(), sorted.end(), 
    //     [](const std::pair<BitString, int64_t>& a, const std::pair<BitString, int64_t>& b) { return a.second < b.second; }); 
    return sorted; 
}

std::ostream& operator<<(std::ostream& os, const SampleLoop& sl) {
    os << "This sample loop repeats for " << sl.repeat << " times\n"; 
    os << "There are " << sl.circ_lst.size() << " many elements in the loop body \n"; 
    for (const Sample& s : sl.circ_lst) {
        std::visit([&os](const auto& _s) { os << _s; }, s); 
    }
    os << "\n"; 
    return os; 
}
</file>

<file path="Sample_Circuits/Loop/Sample.h">
#ifndef _STIM_SAMPLELOOP
#define _STIM_SAMPLELOOP
#define M4RI_USE_C99

extern "C" {
    #include <m4ri/m4ri.h>
}

#include "Loop.h"
#include "Block.h"
#include <unordered_map>
#include "../../Test_Pauli/Stim_Pauli.h"

struct BitString {
    static constexpr size_t BITS_PER_INT = 64;
    static constexpr size_t WORDS_PER_VEC = 4; 

    __m256i* bs = nullptr;
    size_t num_bits = 0;
    size_t num_words = 0;

    void allocate(size_t bits) {
        num_bits = bits;
        num_words = (bits + 255) / 256;
        bs = (__m256i*)_mm_malloc(num_words * sizeof(__m256i), sizeof(__m256i));
        if (!bs) throw std::bad_alloc();
        std::memset(bs, 0, num_words * sizeof(__m256i));
    }

    // Destructor
    ~BitString() {
        _mm_free(bs);
    }

    // Default, copy, and move constructors
    BitString() = default;
    BitString(size_t bits) {
        if (bits != 0) allocate(bits);
    }

    BitString(const BitString& other) {
        if (other.num_bits != 0) {
            allocate(other.num_bits);
            std::memcpy(bs, other.bs, num_words * sizeof(__m256i));
        }
    }

    BitString(BitString&& other) noexcept {
        bs = other.bs;
        num_bits = other.num_bits;
        num_words = other.num_words;
        other.bs = nullptr;
        other.num_bits = 0;
        other.num_words = 0;
    }

    BitString& operator=(const BitString& other); 
    BitString& operator=(BitString&& other) noexcept; 
    BitString operator^(const BitString& other) const; 
    BitString& operator^=(const BitString& other); 
    bool operator[](size_t i) const;
    void set(size_t i, bool value); 
    void bit_xor(size_t i, bool value); 
    bool operator==(const BitString& other) const; 
    BitString operator+(const BitString& other) const; 
    BitString& operator+=(const BitString& other);

    // std::vector<uint64_t> bs; 
    // size_t num_bits; 

    // static constexpr size_t BITS_PER_INT = 64;

    // BitString(size_t n) : num_bits(n) {
    //     bs.resize((n + BITS_PER_INT - 1) / BITS_PER_INT, 0);
    // }

    // BitString() = default;
    // BitString(const BitString&) = default; 
    // BitString(BitString&&) = default;  
    // BitString& operator=(const BitString&) = default; 
    // BitString& operator=(BitString&&) = default; 
    // BitString(const std::vector<uint64_t>& _bs) : bs(_bs) {} 

    // BitString operator^(const BitString& BS) const; 
    // BitString& operator^=(const BitString& other); 
    // bool operator[](size_t i) const; 
    // BitString operator+(const BitString& b) const; 
    // BitString& operator+=(const BitString& other); 
    // bool operator==(const BitString& other) const; 
    // void set(size_t i, bool value); 
}; 

std::ostream& operator<<(std::ostream& os, const BitString& bs); 
namespace std {
    template<>
    struct hash<BitString> {
        std::size_t operator()(const BitString& b) const {
            std::size_t h = std::hash<size_t>{}(b.num_bits);
            const uint64_t* data = reinterpret_cast<const uint64_t*>(b.bs);

            for (size_t i = 0; i < b.num_words; ++i) {
                std::size_t word_hash = std::hash<uint64_t>{}(data[i]);
                h ^= word_hash + 0x9e3779b9 + (h << 6) + (h >> 2);  // hash combine
            }

            return h;
        }
    };
}

struct SimpError {
    std::vector<std::pair<std::set<size_t>, std::set<size_t>>> eindex; // the error on data qubits and then ancilla qubits
    Weights weights; 
} ; 

SimpError SimplifyError(const Error& E, size_t data_offset, size_t total_offset); 
std::ostream& operator<<(std::ostream& os, const SimpError& E);

struct SampleBlock {
    size_t data_qubit; 
    size_t total_qubit; 
    std::set<size_t> rqubits; 
    std::vector<SimpError> errors; 
    std::vector<std::pair<std::set<size_t>, std::set<size_t>>> half_error; 
    std::vector<std::pair<Vectorized_Pauli, BitString>> map; 
    mzd_t* data_Tmatrix;
    mzd_t* ancilla_Tmatrix; 
    mzd_t* data_BSmatrix; 
    mzd_t* ancilla_BSmatrix;
    std::vector<Measure> measures; 
    size_t measurements; 
    std::vector<std::pair<std::set<size_t>, std::set<size_t>>> merrors; 
    std::vector<double> mflips; 

    SampleBlock() = default; 
    SampleBlock(const SampleBlock& sl); 
    SampleBlock(SampleBlock&&) = default; 
    SampleBlock& operator=(const SampleBlock& sl); 
    SampleBlock& operator=(SampleBlock&&) = default;
    SampleBlock(const Standardized_Block& B); 
}; 

std::set<size_t> resets_list(
    const Standardized_Block& circ, 
    std::optional<size_t> start,
    std::optional<size_t> end
); 
std::vector<mzd_t*> gates_block(
    const Standardized_Block& circ, 
    std::optional<size_t> start, 
    std::optional<size_t> end
); 
void sample(const std::vector<Error>& errors, Vectorized_Pauli& P); 
void sample(const std::vector<SimpError>& errors, Vectorized_Pauli& P); 
void map_sampled_error_resets(const std::set<size_t>& rqubits, Vectorized_Pauli& P); 
void map_sampled_error_gates(
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& map, 
    const std::vector<double>& mflips,
    Vectorized_Pauli& P, 
    BitString& bs
); 
std::ostream& operator<<(std::ostream& os, const SampleBlock& sb); 

struct SampleLoop; 

using Sample = std::variant<SampleBlock, SampleLoop>;

struct SampleLoop {
    int repeat; 
    std::vector<Sample> circ_lst;
    
    SampleLoop() = default; 
    SampleLoop(const SampleLoop&) = default; 
    SampleLoop(SampleLoop&&) = default; 
    SampleLoop& operator=(const SampleLoop&) = default; 
    SampleLoop& operator=(SampleLoop&&) = default; 
    SampleLoop(const std::initializer_list<Sample>& lst, int r=1) : repeat(r), circ_lst(std::vector<Sample>(lst)) {}
    SampleLoop(const std::vector<Sample>& lst, int r=1) : repeat(r), circ_lst(lst) {}
    SampleLoop(const Sample& s, int r=1) :  repeat(r), circ_lst(std::vector<Sample>{s}) {}
    SampleLoop(const Loop& L); 

    const Sample& operator[](size_t index) const; 
}; 

void mzd_copy_submatrix(
    mzd_t* dest, mzd_t* source, 
    size_t start_r, size_t end_r
); 
void transpose_inplace(
    size_t qubits, 
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& gates, 
    std::vector<Vectorized_Pauli>& Tmatrix,
    std::vector<BitString>& BSmatrix 
); 

std::vector<std::pair<BitString, int64_t>> measure(int shots, const std::vector<Sample>& lst); 
std::vector<std::pair<BitString, int64_t>> bulk_measure(int shots, std::vector<Sample>& lst);
std::ostream& operator<<(std::ostream& os, const SampleLoop& sl); 

void printSampledLoop(const Loop& loop);
void printCircuitwithLoop(const Block& circ1, const Loop& loop, const Block& circ2); 

#endif
</file>

<file path="Sample_Circuits/Loop/SampleSparse.cc">
#include "SampleSparse.h"
#include <chrono>

BitString& BitString::operator=(const BitString& other) {
    if (this != &other) {
        if (bs) _mm_free(bs);
        allocate(other.num_bits);
        std::memcpy(bs, other.bs, num_words * sizeof(__m256i));
    }
    return *this;
}

BitString& BitString::operator=(BitString&& other) noexcept {
    if (this != &other) {
        if (bs) _mm_free(bs);
        bs = other.bs;
        num_bits = other.num_bits;
        num_words = other.num_words;
        other.bs = nullptr;
        other.num_bits = 0;
        other.num_words = 0;
    }
    return *this;
}

// XOR operator
BitString BitString::operator^(const BitString& other) const {
    if (num_words != other.num_words) {
        throw std::runtime_error("BitStrings must be same length for XOR");
    }
    BitString result(num_bits); 
    for (size_t i = 0; i < num_words; ++i) {
        __m256i a = _mm256_load_si256(&bs[i]);
        __m256i b = _mm256_load_si256(&other.bs[i]);
        _mm256_store_si256(&result.bs[i], _mm256_xor_si256(a, b));
    }
    return result;
}

// XOR-assignment
BitString& BitString::operator^=(const BitString& other) {
    if (num_words < other.num_words) {
        BitString res = BitString(other.num_words * 256); 
        for (size_t i = 0; i < num_words; ++i) {
            res.bs[i] = _mm256_xor_si256(bs[i], other.bs[i]); 
        }
        std::memcpy(res.bs + num_words, other.bs + num_words, (other.num_words - num_words) * sizeof(__m256i)); 
        *this = std::move(res); 
        return *this; 
    } else {
        for (size_t i = 0; i < num_words; ++i) {
            bs[i] = _mm256_xor_si256(bs[i], other.bs[i]); 
        }
        return *this; 
    }
}

// Bit access
bool BitString::operator[](size_t i) const {
    size_t index = i / 256;
    size_t bit = i % 256;
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    const uint64_t* data = reinterpret_cast<const uint64_t*>(bs + index);
    return data[lane] & (1ULL << bit_in_lane);
}

// Bit set
void BitString::set(size_t i, bool value) {
    if (i >= num_bits) {
        std::cerr << "Index out of bounds: " << i << std::endl;
        std::exit(1);
    }
    size_t index = i / 256;
    size_t bit = i % 256;
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    uint64_t* data = reinterpret_cast<uint64_t*>(bs + index);
    if (value)
        data[lane] |= (1ULL << bit_in_lane);
    else
        data[lane] &= ~(1ULL << bit_in_lane);
}

void BitString::bit_xor(size_t i, bool value) {
    size_t index = i / 256;
    size_t bit = i % 256;
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    uint64_t* data = reinterpret_cast<uint64_t*>(bs + index);
    data[lane] ^= (1ULL << bit_in_lane); 
}

bool BitString::operator==(const BitString& other) const {
    if (num_bits != other.num_bits) return false;
    const size_t vec_count = (num_words + 3) / 4;
    return std::memcmp(bs, other.bs, vec_count * sizeof(__m256i)) == 0;
}

// Printing
std::ostream& operator<<(std::ostream& os, const BitString& bs) {
    for (size_t i = 0; i < bs.num_bits; ++i) {
        os << (bs[i] ? '1' : '0');
    }
    return os;
}

BitString BitString::operator+(const BitString& other) const {
    BitString result(num_bits + other.num_bits);

    const size_t w = num_bits / BITS_PER_INT;
    const size_t b = num_bits % BITS_PER_INT;

    // Copy current data
    size_t num_u64 = num_words;
    std::memcpy(result.bs, bs, num_u64 * sizeof(uint64_t));

    const uint64_t* other_data = reinterpret_cast<const uint64_t*>(other.bs);
    uint64_t* result_data = reinterpret_cast<uint64_t*>(result.bs);

    if (b == 0) {
        std::memcpy(result_data + w, other_data, other.num_words * sizeof(uint64_t));
    } else {
        const size_t shift = BITS_PER_INT - b;
        uint64_t carry = 0;

        for (size_t i = 0; i < other.num_words; ++i) {
            uint64_t current = other_data[i];
            result_data[w + i]     |= current << b;
            carry                   = current >> shift;
            result_data[w + i + 1] |= carry;
        }
    }

    return result;
}

BitString& BitString::operator+=(const BitString& other) {
    const size_t old_num_bits = num_bits;
    const size_t old_words = num_words;
    const size_t new_bits = num_bits + other.num_bits;
    const size_t new_words = (new_bits + BITS_PER_INT - 1) / BITS_PER_INT;

    // Allocate new space
    __m256i* new_bs = (__m256i*)_mm_malloc(((new_words + 3) / 4) * sizeof(__m256i), alignof(__m256i));
    std::memset(new_bs, 0, ((new_words + 3) / 4) * sizeof(__m256i));

    // Copy existing data
    std::memcpy(new_bs, bs, old_words * sizeof(uint64_t));
    _mm_free(bs);
    bs = new_bs;
    num_bits = new_bits;
    num_words = new_words;

    const size_t w = old_num_bits / BITS_PER_INT;
    const size_t b = old_num_bits % BITS_PER_INT;

    const uint64_t* other_data = reinterpret_cast<const uint64_t*>(other.bs);
    uint64_t* this_data = reinterpret_cast<uint64_t*>(bs);

    if (b == 0) {
        std::memcpy(this_data + w, other_data, other.num_words * sizeof(uint64_t));
    } else {
        const size_t shift = BITS_PER_INT - b;
        uint64_t carry = 0;

        for (size_t i = 0; i < other.num_words; ++i) {
            uint64_t current = other_data[i];
            this_data[w + i]     |= current << b;
            carry                 = current >> shift;
            this_data[w + i + 1] |= carry;
        }
    }

    return *this;
}

SimpError SimplifyError(const Error& E, size_t data_offset, size_t total_offset) {
    SimpError SE; 
    for (size_t i = 0; i < E.paulis.size(); ++i) {
        const Vectorized_Pauli& P = E.paulis[i]; 
        SE.eindex.push_back(to_xz_sets(P, data_offset, total_offset)); 
    }
    SE.weights = E.weights; 
    return SE; 
}

std::ostream& operator<<(std::ostream& os, const SimpError& E) {
    for (size_t i = 0; i < E.eindex.size(); ++i) {
        os << "The Error on data qubits "; 
        for (size_t q : E.eindex[i].first) os << q << " "; 
        os << "\nand on on ancilla qubits "; 
        for (size_t q : E.eindex[i].second) os << q << " "; 
        os << "has a " << E.weights.get(i) << " probability of being multiplied on\n";
    }
    return os; 
}

SampleBlock::SampleBlock(const Standardized_Block& B) {
    size_t index = 0; 
    data_qubit = B.actual_qubit; 
    total_qubit = B.std_block.qubits(); 
    const std::vector<Operator>& ops = B.std_block.operators;
    while (index < ops.size() && std::holds_alternative<Error>(ops[index])) {
        const Error& E = std::get<Error>(ops[index]); 
        if (E.weights.get(0) == 0.5 && E.weights.get(1) == 0.5) {
            const Vectorized_Pauli& P = E.paulis[1]; 
            half_error.push_back(to_xz_sets(P, data_qubit, total_qubit)); 
        } else {
            errors.push_back(SimplifyError(E, data_qubit, total_qubit)); 
        }
        ++index; 
    }
    size_t start = index; 
    while (index < ops.size() && std::holds_alternative<Clifford>(ops[index])) {
        ++index; 
    } 
    size_t end = index; 
    while (index < ops.size() && std::holds_alternative<Measure>(ops[index])) {
        const Measure& M = std::get<Measure>(ops[index]); 
        measures.push_back(M); 
        mflips.push_back(M.probability); 
        ++index; 
    }
    measurements = measures.size(); 
    rqubits = resets_list(B, index); 
    gates_block(B, rqubits, start, end, data_Tmatrix, ancilla_Tmatrix, data_BSmatrix, ancilla_BSmatrix);
}

SampleBlock::SampleBlock(const SampleBlock& sl) {
    errors = sl.errors; 
    rqubits = sl.rqubits; 
    half_error = sl.half_error; 
    measures = sl.measures; 
    merrors = sl.merrors; 
    mflips = sl.mflips; 
    for (const auto& pr: sl.map) {
        map.push_back({pr.first.copy(), pr.second}); 
    }
}

SampleBlock& SampleBlock::operator=(const SampleBlock& sl) {
    errors = sl.errors; 
    rqubits = sl.rqubits; 
    half_error = sl.half_error; 
    measures = sl.measures; 
    merrors = sl.merrors; 
    mflips = sl.mflips; 
    for (auto& pr: map) {
        pr.first.free(); 
    }
    map.clear(); 
    for (const auto& pr: sl.map) {
        map.push_back({pr.first.copy(), pr.second}); 
    }
    return *this; 
}

void map_sampled_error_resets(const std::set<size_t>& rqubits, Vectorized_Pauli& P) {
    for (size_t i : rqubits) {
        P.delete_term(i); 
    }
}

void map_sampled_error_gates(
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& map, 
    const std::vector<double>& mflips, 
    Vectorized_Pauli& P, BitString& bs
) {
    static thread_local std::mt19937 gen(std::random_device{}()); 
    static thread_local std::uniform_real_distribution<double> dist(0, 1);
    BitString flips = BitString(map[0].second.num_bits); 
    // this require you knowing in advance the maximum qubit
    static Vectorized_Pauli _P; 
    uint64_t* xptr = reinterpret_cast<uint64_t*>(P.xs); 
    uint64_t* zptr = reinterpret_cast<uint64_t*>(P.zs); 
    for (size_t i = 0; i < P.num_words * 4; ++i) {
        uint64_t* xword = xptr + i;
        uint64_t* zword = zptr + i;  
        while (*xword) {
            int bit = __builtin_ctzll(*xword); 
            const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit]; 
            _P *= transformed.first; 
            flips ^= transformed.second;
            *xword &= *xword - 1; 
        }
        while (*zword) {
            int bit = __builtin_ctzll(*zword); 
            const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit + 1]; 
            _P *= transformed.first;  
            flips ^= transformed.second;
            *zword &= *zword - 1;
        }
    }
    std::swap(_P, P); 
    bs += flips; 
}

std::ostream& operator<<(std::ostream& os, const SampleBlock& sb) {
    os << "The resets: \n"; 
    for (size_t i : sb.rqubits) os << i << "\n"; 
    os << "The 50-50 errors: \n"; 
    for (auto& pr : sb.half_error) {
        os << "The Error on data qubits "; 
        for (size_t q : pr.first) os << q << " "; 
        os << "and on ancilla qubits "; 
        for (size_t q : pr.second) os << q << " "; 
        os << "has a " << "0.5 probability of being multiplied on\n";
    }
    os << "The errors: \n"; 
    for  (const SimpError& E: sb.errors) os << E << "\n\n"; 
    os << "The map: \n"; 
    for (const std::pair<Vectorized_Pauli, BitString>& pr: sb.map) os << pr.first << " " << pr.second << "\n"; 
    os << "The measurements: \n"; 
    for (const Measure& M: sb.measures) os << M << "\n"; 
    os << "The measurement errors: \n"; 
    for (size_t i = 0; i < sb.merrors.size(); ++i) {
        os << "The Error on data qubits "; 
        for (size_t q : sb.merrors[i].first) os << q << " "; 
        os << "and on ancilla qubits "; 
        for (size_t q : sb.merrors[i].second) os << q << " "; 
        os << "has a " << "0.5 probability of being multiplied on\n";
    } 
    return os; 
}

// returns the list of qubits to set to zero give [start, end) are all resets 
std::set<size_t> resets_list(const Standardized_Block& circ, std::optional<size_t> first_reset) {
    size_t first = circ.std_block.operators.size();
    size_t last = first; 
    std::set<size_t> resets; 
    if (first_reset) first = *first_reset; 
    else {
        for (size_t i = 0; i < circ.std_block.operators.size(); ++i) {
            if (std::holds_alternative<Reset>(circ.std_block.operators[i])) {
                first = i; 
                break; 
            }
        }
    }
    for (size_t i = first; i < last; ++i) {
        resets.insert(std::get<Reset>(circ.std_block[i]).qubits()); 
    }
    return resets; 
}

void transpose_inplace(
    size_t data_qubits,
    size_t total_qubits, 
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& gates, 
    GrB_Matrix data_Tmatrix,
    GrB_Matrix ancilla_Tmatrix,
    GrB_Matrix data_BSmatrix,
    GrB_Matrix ancilla_BSmatrix 
) { 
    for (size_t q = 0; q < data_qubits; ++q) {
        const Vectorized_Pauli& Tx = gates[q].first; 
        const Vectorized_Pauli& Tz = gates[q + total_qubits].first; 
        const uint64_t* xptr = reinterpret_cast<uint64_t*>(Tx.xs); // transformed pauli x-part of X_q
        const uint64_t* zptr = reinterpret_cast<uint64_t*>(Tx.zs); // transformed pauli z-part of X_q
        for (size_t i = 0; i < Tx.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= data_qubits) break; 
                GrB_Matrix_setElement_BOOL(data_Tmatrix, true, bit + 64 * i, q); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= data_qubits) break; 
                GrB_Matrix_setElement_BOOL(data_Tmatrix, true, data_qubits + bit + 64 * i, q); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<uint64_t*>(Tz.xs); // transfored pauli x-part of Z_q
        zptr = reinterpret_cast<uint64_t*>(Tz.zs); // transfored pauli z-part of Z_q
        for (size_t i = 0; i < Tz.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= data_qubits) break; 
                GrB_Matrix_setElement_BOOL(data_Tmatrix, true, bit + 64 * i, q + data_qubits);
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= data_qubits) break; 
                GrB_Matrix_setElement_BOOL(data_Tmatrix, true, data_qubits + bit + 64 * i, q + data_qubits); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<uint64_t*>(gates[q].second.bs); // transformation of X_q as a BitString
        zptr = reinterpret_cast<uint64_t*>(gates[q + total_qubits].second.bs); // transformation of Z_q as a BitString
        for (size_t i = 0; i < gates[q].second.num_words; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i];
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                GrB_Matrix_setElement_BOOL(data_BSmatrix, true, bit + 64 * i, q); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                GrB_Matrix_setElement_BOOL(data_BSmatrix, true, bit + 64 * i, q + total_qubits); 
                zword &= zword - 1; 
            }
        }
    }
    for (size_t q = data_qubits; q < total_qubits; ++q) {
        const Vectorized_Pauli& Tx = gates[q].first; 
        const Vectorized_Pauli& Tz = gates[q + total_qubits].first; 
        const uint64_t* xptr = reinterpret_cast<uint64_t*>(Tx.xs); // transformed pauli x-part of X_q
        const uint64_t* zptr = reinterpret_cast<uint64_t*>(Tx.zs); // transformed pauli z-part of X_q
        for (size_t i = 0; i < Tx.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= data_qubits) break; 
                GrB_Matrix_setElement_BOOL(ancilla_Tmatrix, true, bit + 64 * i, q); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= data_qubits) break; 
                GrB_Matrix_setElement_BOOL(ancilla_Tmatrix, true, data_qubits + bit + 64 * i, q); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<uint64_t*>(Tz.xs); // transfored pauli x-part of Z_q
        zptr = reinterpret_cast<uint64_t*>(Tz.zs); // transfored pauli z-part of Z_q
        for (size_t i = 0; i < Tz.num_words * 4; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                if (bit + 64 * i >= data_qubits) break; 
                GrB_Matrix_setElement_BOOL(ancilla_Tmatrix, true, bit + 64 * i, q + data_qubits);
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                if (bit + 64 * i >= data_qubits) break; 
                GrB_Matrix_setElement_BOOL(ancilla_Tmatrix, true, data_qubits + bit + 64 * i, q + data_qubits); 
                zword &= zword - 1; 
            }
        }
        xptr = reinterpret_cast<const uint64_t*>(gates[q].second.bs); // transformation of X_q as a BitString
        zptr = reinterpret_cast<const uint64_t*>(gates[q + total_qubits].second.bs); // transformation of Z_q as a BitString
        for (size_t i = 0; i < gates[q].second.num_words; ++i) {
            uint64_t xword = xptr[i]; 
            uint64_t zword = zptr[i];
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                GrB_Matrix_setElement_BOOL(ancilla_BSmatrix, true, bit + 64 * i, q); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                GrB_Matrix_setElement_BOOL(ancilla_BSmatrix, true, bit + 64 * i, q + total_qubits); 
                zword &= zword - 1; 
            }
        }
    }
}

void gates_block(
    const Standardized_Block& circ, 
    const std::set<size_t> rqubits,
    std::optional<size_t> start, 
    std::optional<size_t> end, 
    GrB_Matrix& data_Tmatrix, GrB_Matrix& ancilla_Tmatrix, 
    GrB_Matrix& data_BSmatrix, GrB_Matrix& ancilla_BSmatrix
) {
    const size_t n = circ.std_block.operators.size();
    size_t cfirst = n + 1;
    size_t mfirst = n + 1;
    size_t mlast = n + 1; 
    std::vector<std::pair<Vectorized_Pauli, BitString>> gates; 
    if (start) cfirst = *start; 
    else {
        for (size_t i = 0; i < n; ++i) {
            if (std::holds_alternative<Clifford>(circ.std_block.operators[i])) {
                cfirst = i; 
                break; 
            }
        }
    }
    if (end) mfirst = *end; 
    else {
        for (size_t i = n; i > 0; --i) {
            if (std::holds_alternative<Clifford>(circ.std_block.operators[i - 1])) {
                mfirst = i; 
                break; 
            }
        }
    }
    for (size_t i = n; i > 0; --i) {
        if (std::holds_alternative<Measure>(circ.std_block.operators[i - 1])) {
            mlast = i; 
            break; 
        }
    }
    if (mlast == n + 1) mlast = mfirst; 
    // std::cout << "n: " << n << " cfirst: " << cfirst << " mfirst: " << mfirst << " mlast: " << mlast << std::endl; 
    const size_t qubits = circ.qubits(); 
    for (size_t q = 1; q <= qubits; ++q) {
        Vectorized_Pauli X = Vectorized_Pauli("X" + std::to_string(q));
        Vectorized_Pauli Z = Vectorized_Pauli("Z" + std::to_string(q));
        for (size_t i = cfirst; i < mfirst; ++i) {
            commute_inplace(X, std::get<Clifford>(circ.std_block.operators[i])); 
            commute_inplace(Z, std::get<Clifford>(circ.std_block.operators[i])); 
        }
        BitString Xflip = BitString(mlast - mfirst); 
        BitString Zflip = BitString(mlast - mfirst); 
        // goes through all the measures 
        // the flips correspond to the measurement outputs AFTER the basis pauli has gone through all the gates 
        for (size_t i = mfirst; i < mlast; ++i) {
            const Measure& M = std::get<Measure>(circ.std_block[i]);
            Xflip.set(i - mfirst, ((X % M.pauli) != M.sign)); 
            Zflip.set(i - mfirst, ((Z % M.pauli) != M.sign));
        }
        for (size_t i : rqubits) {
            X.delete_term(i); 
            Z.delete_term(i); 
        }
        gates.push_back(std::pair{std::move(X), Xflip}); 
        gates.push_back(std::pair{std::move(Z), Zflip}); 
    }
    GrB_Matrix_new(&data_Tmatrix, GrB_BOOL, 2 * circ.actual_qubit, 2 * circ.actual_qubit); 
    GrB_Matrix_new(&ancilla_Tmatrix, GrB_BOOL, 2 * circ.actual_qubit, 2 * (qubits - circ.actual_qubit));
    GrB_Matrix_new(&data_BSmatrix, GrB_BOOL, mlast - mfirst, 2 * circ.actual_qubit); 
    GrB_Matrix_new(&ancilla_BSmatrix, GrB_BOOL, mlast - mfirst, 2 * (qubits - circ.actual_qubit)); 
    transpose_inplace(circ.actual_qubit, qubits, gates, data_Tmatrix, ancilla_Tmatrix, data_BSmatrix, ancilla_BSmatrix); 
}

void sample(const std::vector<Error>& errors, Vectorized_Pauli& P) {
    static std::mt19937 gen(std::random_device{}()); 
    for (const Error& E: errors) {
        std::discrete_distribution<> dist(E.weights.begin(), E.weights.end()); 
        const Vectorized_Pauli& choice = E.paulis[dist(gen)]; 
        P *= choice; 
    }
}

SampleLoop::SampleLoop(const Loop& L) {
    repeat = L.repeat; 
    for (const SubCircuit& subcirc : L.reduced_body) {
        if (std::holds_alternative<Standardized_Block>(subcirc)) {
            circ_lst.push_back(SampleBlock(std::get<Standardized_Block>(subcirc))); 
        } else {
            circ_lst.push_back(SampleLoop(std::get<Loop>(subcirc))); 
        }
    }
}

const Sample& SampleLoop::operator[](size_t index) const {
    return circ_lst[index]; 
}

void bulk_reset_map(const std::set<size_t>& rqubits, GrB_Matrix data) {
    GrB_Index rows, cols; 
    GrB_Matrix_nrows(&rows, data); 
    GrB_Matrix_ncols(&cols, data); 
    const size_t z_offset = rows / 2; 

    for (size_t i : rqubits) {
        --i; 
        GrB_Index row_idx = i;
        GrB_Matrix_assign_BOOL(data, NULL, NULL, false, &row_idx, 1, GrB_ALL, cols, NULL);
        row_idx = i + z_offset;  
        GrB_Matrix_assign_BOOL(data, NULL, NULL, false, &row_idx, 1, GrB_ALL, cols, NULL);
    }
}

void bulk_gate_map(
    const GrB_Matrix data_Tmatrix,
    const GrB_Matrix ancilla_Tmatrix,
    const GrB_Matrix data_BSmatrix, 
    const GrB_Matrix ancilla_BSmatrix,
    const std::vector<double>& mflips, 
    GrB_Matrix& data,
    GrB_Matrix ancilla,
    GrB_Matrix flips
) {
    static std::mt19937 gen(std::random_device{}()); 
    static std::uniform_real_distribution<double> dist(0.0, 1.0);

    // std::cout << data->nrows << " " << data->ncols << std::endl;  
    GrB_Matrix temp, selected;
    GrB_Index data_nrows, data_ncols, data_entries, ancilla_nrows, ancilla_ncols, ancilla_entries;
    GrB_Matrix_nrows(&data_nrows, data); 
    GrB_Matrix_ncols(&data_ncols, data); 
    // GrB_Matrix_new(&selected, GrB_BOOL, data_nrows, data_ncols); 
    // GrB_Matrix_select_BOOL(selected, NULL, NULL, GrB_VALUEEQ_BOOL, data, true, NULL); 
    // GrB_Matrix_nvals(&data_entries, selected); 
    GrB_Matrix_new(&temp, GrB_BOOL, data_nrows, data_ncols); 
    // std::cout << "The " << data_nrows << " by " << data_ncols << " data matrix has " << data_entries << " 1 entries\n";   
    // GrB_Matrix_free(&selected); 

    // GrB_Matrix_nrows(&data_nrows, data_Tmatrix); 
    // GrB_Matrix_ncols(&data_ncols, data_Tmatrix); 
    // GrB_Matrix_new(&selected, GrB_BOOL, data_nrows, data_ncols); 
    // GrB_Matrix_select_BOOL(selected, NULL, NULL, GrB_VALUEEQ_BOOL, data_Tmatrix, true, NULL); 
    // GrB_Matrix_nvals(&data_entries, selected);
    // std::cout << "The " << data_nrows << " by " << data_ncols << " data Tmatrix has " << data_entries << " 1 entries\n"; 
    // GrB_Matrix_free(&selected); 

    // GrB_Matrix_nrows(&data_nrows, data_BSmatrix); 
    // GrB_Matrix_ncols(&data_ncols, data_BSmatrix); 
    // GrB_Matrix_nvals(&data_entries, data_BSmatrix);
    // std::cout << "The " << data_nrows << " by " << data_ncols << " data BSmatrix has " << data_entries << " 1 entries\n\n"; 

    GrB_mxm(temp, NULL, NULL, GxB_LXOR_LAND_BOOL, data_Tmatrix, data, NULL); 
    GrB_mxm(flips, NULL, NULL, GxB_LXOR_LAND_BOOL, data_BSmatrix, data, NULL); 
    if (ancilla)  {
        // GrB_Matrix_nrows(&ancilla_nrows, ancilla); 
        // GrB_Matrix_ncols(&ancilla_ncols, ancilla); 
        // GrB_Matrix_new(&selected, GrB_BOOL, ancilla_nrows, ancilla_ncols); 
        // GrB_Matrix_select_BOOL(selected, NULL, NULL, GrB_VALUEEQ_BOOL, ancilla, true, NULL); 
        // GrB_Matrix_nvals(&ancilla_entries, selected); 
        // std::cout << "The " << ancilla_nrows << " by " << ancilla_ncols << " ancilla matrix has " << ancilla_entries << " 1 entries\n";
        // GrB_Matrix_free(&selected); 

        // GrB_Matrix_nrows(&data_nrows, ancilla_Tmatrix); 
        // GrB_Matrix_ncols(&data_ncols, ancilla_Tmatrix); 
        // GrB_Matrix_new(&selected, GrB_BOOL, data_nrows, data_ncols); 
        // GrB_Matrix_select_BOOL(selected, NULL, NULL, GrB_VALUEEQ_BOOL, ancilla_Tmatrix, true, NULL); 
        // GrB_Matrix_nvals(&data_entries, selected);
        // std::cout << "The " << data_nrows << " by " << data_ncols << " ancilla Tmatrix has " << data_entries << " 1 entries\n";
        // GrB_Matrix_free(&selected); 

        // GrB_Matrix_nrows(&data_nrows, ancilla_BSmatrix); 
        // GrB_Matrix_ncols(&data_ncols, ancilla_BSmatrix); 
        // GrB_Matrix_nvals(&data_entries, ancilla_BSmatrix);
        // std::cout << "The " << data_nrows << " by " << data_ncols << " ancilla BSmatrix has " << data_entries << " 1 entries\n\n";     
        
        GrB_mxm(temp, NULL, GrB_LXOR, GxB_LXOR_LAND_BOOL, ancilla_Tmatrix, ancilla, NULL); 
        GrB_mxm(flips, NULL, GrB_LXOR, GxB_LXOR_LAND_BOOL, ancilla_BSmatrix, ancilla, NULL);  
    }
    GrB_Matrix_free(&data); 
    data = temp;
    // for (size_t i = 0; i < mflips.size(); ++i) {
    //     if (dist(gen) < mflips[i]) {
    //         flips.bit_xor(i, 1);
    //     }
    // } 
    // bs[j] += flips; 
}

// this current implementation guarantees access each row of the error every time an error is hit
void bulk_sample(const std::vector<SimpError>& errors, GrB_Matrix data, GrB_Matrix ancilla) {
    static thread_local std::mt19937_64 rng(std::random_device{}()); 
    static GrB_Scalar s;
    GrB_Scalar_new(&s, GrB_BOOL);
    GrB_Scalar_setElement_BOOL(s, true);

    GrB_Index nrows_data, ncols_data; 
    GrB_Index nrows_ancilla, ncols_ancilla; 
    GrB_Matrix_nrows(&nrows_data, data); 
    GrB_Matrix_ncols(&ncols_data, data); 
    GrB_Matrix_nrows(&nrows_ancilla, ancilla); 
    GrB_Matrix_ncols(&ncols_ancilla, ancilla); 

    std::vector<GrB_Index> data_indices, ancilla_indices, data_frames, ancilla_frames;
    size_t index;
    float prob;

    for (const SimpError& E : errors) {
        prob = 1 - E.weights.get(0);
        std::geometric_distribution<size_t> dist(prob);
        index = dist(rng);

        while (index < ncols_data) {
            int p = (E.weights.size() <= 2) ? 1 : 1 + (rng() % (E.weights.size() - 2));
            for (size_t i : E.eindex[p].first) {
                data_indices.push_back(i);
                data_frames.push_back(index);
            }
            for (size_t i : E.eindex[p].second) {
                ancilla_indices.push_back(i);
                ancilla_frames.push_back(index);
            }
            index += dist(rng);
        }
    }

    GrB_Matrix flip;
    GrB_Matrix_new(&flip, GrB_BOOL, nrows_data, ncols_data);
    GxB_Matrix_build_Scalar(flip, data_indices.data(), data_frames.data(), s, data_indices.size());
    GrB_Matrix_eWiseAdd_BinaryOp(data, NULL, NULL, GrB_LXOR, data, flip, NULL);
    GrB_Matrix_free(&flip); 
    GrB_Matrix_new(&flip, GrB_BOOL, nrows_ancilla, ncols_ancilla);
    GxB_Matrix_build_Scalar(flip, ancilla_indices.data(), ancilla_frames.data(), s, ancilla_indices.size()); 
    GrB_Matrix_eWiseAdd_BinaryOp(ancilla, NULL, NULL, GrB_LXOR, ancilla, flip, NULL); 
    GrB_Matrix_free(&flip);
}

GrB_Matrix random_bool_vector(size_t ncols, std::mt19937_64& rng) {
    GrB_Index num_cols = ncols; 
    GrB_Matrix rand; 
    GrB_Matrix_new(&rand, GrB_BOOL, 1, num_cols);

    size_t num_uint64 = (num_cols + 63) / 64; 
    GrB_Index* row_indices = (GrB_Index*) malloc(num_cols * sizeof(GrB_Index)); 
    GrB_Index* col_indices = (GrB_Index*) malloc(num_cols * sizeof(GrB_Index)); 
    bool *values = (bool*) malloc(num_cols * sizeof(bool)); 
    GrB_Index count = 0; 
    memset(row_indices, 0, num_cols * sizeof(GrB_Index));
    memset(values, 1, num_cols * sizeof(bool)); 

    for (GrB_Index word_idx = 0; word_idx < num_uint64; word_idx++) {
        uint64_t word = rng();

        // Mask last word if necessary
        if (word_idx == num_uint64 - 1) {
            size_t bits_in_last = num_cols - (word_idx * 64);
            if (bits_in_last < 64) {
                word &= (~0ULL) >> (64 - bits_in_last);
            }
        }

        for (GrB_Index bit = 0; bit < 64; bit++) {
            if (word & (1ULL << bit)) {
                GrB_Index col = word_idx * 64 + bit;
                col_indices[count] = col;
                count++;
            }
        }
    }

    GrB_Matrix_build_BOOL(rand, row_indices, col_indices, values, count, GrB_LXOR); 
    free(row_indices); 
    free(col_indices); 
    free(values); 
    return rand;
}

void random_bool_matrix(
    size_t frames, 
    const std::vector<std::pair<std::set<size_t>, std::set<size_t>>>& rows, 
    GrB_Matrix data_flips, GrB_Matrix ancilla_flips, 
    std::mt19937_64& rng
) {
    static GrB_Scalar s;
    GrB_Scalar_new(&s, GrB_BOOL);
    GrB_Scalar_setElement_BOOL(s, true);

    // I expect that the 50-50 errors won't have a lot of overlapping rows so this is the choosen method to generate the matrix
    std::unordered_map<size_t, std::unordered_set<size_t>> data_row_column;
    std::unordered_map<size_t, std::unordered_set<size_t>> ancilla_row_column; 
    size_t num_words = (frames + 63) / 64; 

    for (const std::pair<std::set<size_t>, std::set<size_t>>& pr : rows) {
        std::unordered_set<size_t> columns; 

        // generates a random row and records where all the 1s are at
        for (size_t word_idx = 0; word_idx < num_words; word_idx++) {
            uint64_t word = rng(); 

            if (word_idx == num_words - 1) {
                size_t bits_in_last = frames - (word_idx * 64);
                if (bits_in_last < 64) {
                    word &= (~0ULL) >> (64 - bits_in_last);
                }
            }
            while (word) {
                int bit = __builtin_ctzll(word); 
                columns.insert(word_idx * 64 + bit); 
                word &= word - 1; 
            }
        }

        // updates the unordered map such that the corresponding row reflects XOR this new random row
        for (size_t data_row : pr.first) {
            if (!data_row_column.insert(std::pair{data_row, columns}).second) { // if insertion failed i.e. key already exists
                std::unordered_set<size_t>& original = data_row_column[data_row]; 
                for (size_t col : columns) {
                    auto it = original.find(col); 
                    if (it != original.end()) original.erase(it); 
                    else original.insert(col); 
                }
            } 
        }
        for (size_t ancilla_row : pr.second) {
            if (!ancilla_row_column.insert(std::pair{ancilla_row, columns}).second) { // if insertion failed i.e. key already exists
                std::unordered_set<size_t>& original = data_row_column[ancilla_row]; 
                for (size_t col : columns) {
                    auto it = original.find(col); 
                    if (it != original.end()) original.erase(it); 
                    else original.insert(col); 
                }
            } 
        }
    }
    // converts from unordered map to row and column indices
    size_t data_size = 0; 
    size_t ancilla_size = 0;
    size_t index = 0; 
    for (const auto& key_value : data_row_column) data_size += key_value.second.size(); 
    for (const auto& key_value : ancilla_row_column) ancilla_size += key_value.second.size(); 
    GrB_Index* data_row_indices = (GrB_Index*) malloc(data_size * sizeof(GrB_Index)); 
    GrB_Index* data_col_indices = (GrB_Index*) malloc(data_size * sizeof(GrB_Index)); 
    GrB_Index* ancilla_row_indices = (GrB_Index*) malloc(ancilla_size * sizeof(GrB_Index)); 
    GrB_Index* ancilla_col_indices = (GrB_Index*) malloc(ancilla_size * sizeof(GrB_Index)); 
    for (const auto& key_value : data_row_column) {
        const size_t row = key_value.first;
        for (size_t col : key_value.second) {
            data_row_indices[index] = row; 
            data_col_indices[index] = col; 
            ++index; 
        }
    }
    index = 0; 
    for (const auto& key_value : ancilla_row_column) {
        const size_t row = key_value.first; 
        for (size_t col : key_value.second) {
            ancilla_row_indices[index] = row; 
            ancilla_col_indices[index] = col; 
            ++index; 
        }
    }
    GxB_Matrix_build_Scalar(data_flips, data_row_indices, data_col_indices, s, data_size); 
    GxB_Matrix_build_Scalar(ancilla_flips, ancilla_row_indices, ancilla_col_indices, s, ancilla_size); 
    free(data_row_indices); 
    free(data_col_indices); 
    free(ancilla_row_indices); 
    free(ancilla_col_indices); 
}

void bulk_sample_half(
    const std::vector<std::pair<std::set<size_t>, std::set<size_t>>>& half_error, 
    GrB_Matrix& data, 
    GrB_Matrix ancilla
) {
    static thread_local std::mt19937_64 rng(std::random_device{}()); 
    if (half_error.empty()) return; 
    GrB_Index frames = 0; 
    GrB_Matrix_ncols(&frames, data); 
    GrB_Matrix rand_data_Matrix, rand_ancilla_Matrix;
    GrB_Index nrows_data, nrows_ancilla; 
    GrB_Matrix_nrows(&nrows_data, data); 
    GrB_Matrix_nrows(&nrows_ancilla, ancilla); 
    GrB_Matrix_new(&rand_data_Matrix, GrB_BOOL, nrows_data, frames); 
    GrB_Matrix_new(&rand_ancilla_Matrix, GrB_BOOL, nrows_ancilla, frames); 

    random_bool_matrix(frames, half_error, rand_data_Matrix, rand_ancilla_Matrix, rng); 

    GrB_Matrix_eWiseAdd_BinaryOp(data, NULL, NULL, GrB_LXOR, data, rand_data_Matrix, NULL); 
    GrB_Matrix_eWiseAdd_BinaryOp(ancilla, NULL, NULL, GrB_LXOR, ancilla, rand_ancilla_Matrix, NULL); 
    GrB_Matrix_free(&rand_data_Matrix); 
    GrB_Matrix_free(&rand_ancilla_Matrix); 

    // for (const std::pair<std::set<size_t>, std::set<size_t>>& pr : half_error) {
    //     GrB_Matrix rand_row = random_bool_vector(ncols_data, rng); 
    //     if (!pr.first.empty()) {
    //         GrB_Index* row_indices = (GrB_Index*) malloc(pr.first.size() * sizeof(GrB_Index)); 
    //         for (size_t row : pr.first) {
    //             row_indices[0] = row;
    //             ++row_indices; 
    //         }
    //         GrB_Matrix_assign(data, 
    //                               NULL, 
    //                               GrB_LXOR, 
    //                               rand_row, 
    //                               row_indices, pr.first.size(), 
    //                               GrB_ALL, ncols_data, 
    //                               NULL); 
    //     }
    //     if (!pr.second.empty()) {
    //         for (size_t row : pr.second) {
    //             GrB_Index row_idx[1] = {(GrB_Index) row}; 
    //             GrB_Matrix_assign(ancilla, 
    //                               NULL, 
    //                               GrB_LXOR, 
    //                               rand_row, 
    //                               row_idx, 1, 
    //                               GrB_ALL, ncols_ancilla, 
    //                               NULL); 
    //         }
    //     }
    // }
}

void GrB_copy_first_n_paulis(
    GrB_Matrix dest, GrB_Matrix source, 
    size_t qubits, size_t offset, size_t cols
) {
    GrB_Index* rows1 = (GrB_Index*) malloc(qubits * sizeof(GrB_Index)); 
    GrB_Index* dest_rows2 = (GrB_Index*) malloc(qubits * sizeof(GrB_Index));
    GrB_Index* src_rows2 = (GrB_Index*) malloc(qubits * sizeof(GrB_Index)); 
    GrB_Matrix sub_src;
    GrB_Matrix_new(&sub_src, GrB_BOOL, qubits, cols); 
    for (size_t i = 0; i < qubits; ++i) {
        rows1[i] = i; 
        dest_rows2[i] = i + qubits;  
        src_rows2[i] = i + offset; 
    }
    GrB_Matrix_extract(sub_src, 
                       NULL, NULL, 
                       source, 
                       rows1, qubits, 
                       GrB_ALL, cols, 
                       NULL); 
    GrB_Matrix_assign(dest,
                      NULL, NULL,
                      sub_src, 
                      rows1, qubits,
                      GrB_ALL, cols, 
                      NULL); 
    
    GrB_Matrix_extract(sub_src,
                       NULL, NULL, 
                       source, 
                       src_rows2, qubits, 
                       GrB_ALL, cols, 
                       NULL);
    GrB_Matrix_assign(dest,
                      NULL, NULL,
                      sub_src, 
                      dest_rows2, qubits,
                      GrB_ALL, cols, 
                      NULL);
    GrB_Matrix_free(&sub_src); 
    free(rows1); 
    free(dest_rows2);      
    free(src_rows2);           
}

void bulk_measure(const SampleBlock& sb, GrB_Matrix& data, std::vector<GrB_Matrix>& allBS) {
    GrB_Matrix bs;
    GrB_Index frames, nmeasure, data_nrow, data_Tmatrix_ncol; 
    GrB_Matrix_nrows(&nmeasure, sb.data_BSmatrix); 
    GrB_Matrix_nrows(&data_nrow, data); 
    GrB_Matrix_ncols(&frames, data); 
    GrB_Matrix_ncols(&data_Tmatrix_ncol, sb.data_Tmatrix); 
    GrB_Matrix_new(&bs, GrB_BOOL, nmeasure, frames); 
    GrB_Matrix ancilla = nullptr; 
    if (sb.data_qubit != sb.total_qubit) {
        GrB_Matrix_new(&ancilla, GrB_BOOL, 2 * (sb.total_qubit - sb.data_qubit), frames); 
        // GrB_Matrix_set_INT32(ancilla, GxB_FULL, GxB_SPARSITY_CONTROL); 
    } 
    if (data_nrow != data_Tmatrix_ncol) {
        GrB_Index entries; 
        GrB_Matrix temp;
        GrB_Matrix_new(&temp, GrB_BOOL, data_Tmatrix_ncol, frames);
        GrB_copy_first_n_paulis(temp, data, data_Tmatrix_ncol / 2, data_nrow / 2, frames);
        GrB_Matrix_free(&data); 
        data = temp; 
    }
    bulk_sample(sb.errors, data, ancilla);  
    bulk_sample_half(sb.half_error, data, ancilla);  
    bulk_gate_map(sb.data_Tmatrix, sb.ancilla_Tmatrix, sb.data_BSmatrix, sb.ancilla_BSmatrix, sb.mflips, data, ancilla, bs); 
    allBS.push_back(bs); 
    if (ancilla) {
        GrB_Matrix_free(&ancilla); 
    }
}

void bulk_measure(const SampleLoop& sl, GrB_Matrix& P, std::vector<GrB_Matrix>& bs) {
    for (int r = 0; r < sl.repeat; ++r) {
        for (const Sample& S : sl.circ_lst) {
            if (std::holds_alternative<SampleBlock>(S)) {  
                bulk_measure(std::get<SampleBlock>(S), P, bs); 
            } else {
                bulk_measure(std::get<SampleLoop>(S), P, bs);
            }
        }
    }
}

std::vector<std::pair<BitString, int64_t>> bulk_measure(int shots, std::vector<Sample>& lst) {
    std::unordered_map<BitString, int64_t> samples; 
    std::vector<std::pair<std::set<size_t>, std::set<size_t>>> first_reset_errors; 
    size_t data_qubit; 
    size_t ancilla_qubit; 
    if (std::holds_alternative<SampleBlock>(lst[0])) {
        const SampleBlock& block = std::get<SampleBlock>(lst[0]); 
        data_qubit = block.data_qubit; 
        ancilla_qubit = block.total_qubit - data_qubit; 
        for (size_t q = 1; q <= block.total_qubit; ++q) {
            if (block.rqubits.find(q) == block.rqubits.end()) {
                if (q < data_qubit) 
                    first_reset_errors.emplace_back(std::pair{std::set<size_t>{q + data_qubit}, std::set<size_t>()}); 
                else
                    first_reset_errors.emplace_back(std::pair{std::set<size_t>(), std::set<size_t>{q + ancilla_qubit}});
            }  
        } 
    } else {
        SampleLoop& loop = std::get<SampleLoop>(lst[0]); 
        while (std::holds_alternative<SampleLoop>(loop.circ_lst[0])) {
            loop = std::get<SampleLoop>(loop.circ_lst[0]); 
        }
        const SampleBlock& block = std::get<SampleBlock>((loop)[0]); 
        data_qubit = block.data_qubit; 
        ancilla_qubit = block.total_qubit - data_qubit; 
        for (size_t q = 1; q <= block.total_qubit; ++q) {
            if (block.rqubits.find(q) == block.rqubits.end()) {
                if (q < data_qubit) 
                    first_reset_errors.emplace_back(std::pair{std::set<size_t>{q + data_qubit}, std::set<size_t>()}); 
                else
                    first_reset_errors.emplace_back(std::pair{std::set<size_t>(), std::set<size_t>{q + ancilla_qubit}});
            }
        } 
    }

    for (int i = 0; i < shots/1000; ++i) {
        std::cout << i + 1 << "th 1000 samples \n"; 
        GrB_Matrix P;
        GrB_Matrix_new(&P, GrB_BOOL, data_qubit * 2, 1000);
        // GrB_Matrix_set_INT32(P, GxB_FULL, GxB_SPARSITY_CONTROL); 
        // bulk_sample_half(first_reset_errors, P, nullptr); 
        std::vector<GrB_Matrix> res; 
        for (const Sample& s : lst) { 
            std::visit([&P, &res](const auto& _s) {bulk_measure(_s, P, res);}, s); 
        }
        GrB_Matrix_free(&P);
        // for (int j = 0; j < 2000; ++j) ++samples[res[j]]; 
    }
    std::vector<std::pair<BitString, int64_t>> sorted(samples.begin(), samples.end()); 
    // std::sort(sorted.begin(), sorted.end(), 
    //     [](const std::pair<BitString, int64_t>& a, const std::pair<BitString, int64_t>& b) { return a.second < b.second; }); 

    return sorted; 
}

std::ostream& operator<<(std::ostream& os, const SampleLoop& sl) {
    os << "This sample loop repeats for " << sl.repeat << " times\n"; 
    os << "There are " << sl.circ_lst.size() << " many elements in the loop body \n"; 
    for (const Sample& s : sl.circ_lst) {
        std::visit([&os](const auto& _s) { os << _s; }, s); 
    }
    os << "\n"; 
    return os; 
}
</file>

<file path="Sample_Circuits/Loop/SampleSparse.h">
#ifndef _STIM_SAMPLESPARSE
#define _STIM_SAMPLESPARSE

#include "Loop.h"
#include "Block.h"
#include <unordered_map>
#include <unordered_set>
#include "../../Test_Pauli/Stim_Pauli.h"
#include "../GraphBlas/GraphBLAS.h"

struct BitString {
    static constexpr size_t BITS_PER_INT = 64;
    static constexpr size_t WORDS_PER_VEC = 4; 

    __m256i* bs = nullptr;
    size_t num_bits = 0;
    size_t num_words = 0;

    void allocate(size_t bits) {
        num_bits = bits;
        num_words = (bits + 255) / 256;
        bs = (__m256i*)_mm_malloc(num_words * sizeof(__m256i), sizeof(__m256i));
        if (!bs) throw std::bad_alloc();
        std::memset(bs, 0, num_words * sizeof(__m256i));
    }

    // Destructor
    ~BitString() {
        _mm_free(bs);
    }

    // Default, copy, and move constructors
    BitString() = default;
    BitString(size_t bits) {
        if (bits != 0) allocate(bits);
    }

    BitString(const BitString& other) {
        if (other.num_bits != 0) {
            allocate(other.num_bits);
            std::memcpy(bs, other.bs, num_words * sizeof(__m256i));
        }
    }

    BitString(BitString&& other) noexcept {
        bs = other.bs;
        num_bits = other.num_bits;
        num_words = other.num_words;
        other.bs = nullptr;
        other.num_bits = 0;
        other.num_words = 0;
    }

    BitString& operator=(const BitString& other); 
    BitString& operator=(BitString&& other) noexcept; 
    BitString operator^(const BitString& other) const; 
    BitString& operator^=(const BitString& other); 
    bool operator[](size_t i) const;
    void set(size_t i, bool value); 
    void bit_xor(size_t i, bool value); 
    bool operator==(const BitString& other) const; 
    BitString operator+(const BitString& other) const; 
    BitString& operator+=(const BitString& other);
}; 

std::ostream& operator<<(std::ostream& os, const BitString& bs); 
namespace std {
    template<>
    struct hash<BitString> {
        std::size_t operator()(const BitString& b) const {
            std::size_t h = std::hash<size_t>{}(b.num_bits);
            const uint64_t* data = reinterpret_cast<const uint64_t*>(b.bs);

            for (size_t i = 0; i < b.num_words; ++i) {
                std::size_t word_hash = std::hash<uint64_t>{}(data[i]);
                h ^= word_hash + 0x9e3779b9 + (h << 6) + (h >> 2);  // hash combine
            }

            return h;
        }
    };
}

struct SimpError {
    std::vector<std::pair<std::set<size_t>, std::set<size_t>>> eindex; // the error on data qubits and then ancilla qubits
    Weights weights; 
} ; 

SimpError SimplifyError(const Error& E, size_t data_offset, size_t total_offset); 
std::ostream& operator<<(std::ostream& os, const SimpError& E);

struct SampleBlock {
    size_t data_qubit; 
    size_t total_qubit; 
    std::set<size_t> rqubits; 
    std::vector<SimpError> errors; 
    std::vector<std::pair<std::set<size_t>, std::set<size_t>>> half_error; 
    std::vector<std::pair<Vectorized_Pauli, BitString>> map; 
    GrB_Matrix data_Tmatrix;
    GrB_Matrix ancilla_Tmatrix; 
    GrB_Matrix data_BSmatrix; 
    GrB_Matrix ancilla_BSmatrix;
    std::vector<Measure> measures; 
    size_t measurements; 
    std::vector<std::pair<std::set<size_t>, std::set<size_t>>> merrors; 
    std::vector<double> mflips; 

    SampleBlock() = default; 
    SampleBlock(const SampleBlock& sl); 
    SampleBlock(SampleBlock&&) = default; 
    SampleBlock& operator=(const SampleBlock& sl); 
    SampleBlock& operator=(SampleBlock&&) = default;
    SampleBlock(const Standardized_Block& B); 
}; 

std::set<size_t> resets_list(const Standardized_Block& circ, std::optional<size_t> first_reset); 
void gates_block(
    const Standardized_Block& circ, 
    const std::set<size_t> rqubits,
    std::optional<size_t> start, 
    std::optional<size_t> end, 
    GrB_Matrix& data_Tmatrix, GrB_Matrix& ancilla_Tmatrix, 
    GrB_Matrix& data_BSmatrix, GrB_Matrix& ancilla_BSmatrix
); 
void sample(const std::vector<Error>& errors, Vectorized_Pauli& P); 
void sample(const std::vector<SimpError>& errors, Vectorized_Pauli& P); 
void map_sampled_error_resets(const std::set<size_t>& rqubits, Vectorized_Pauli& P); 
void map_sampled_error_gates(
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& map, 
    const std::vector<double>& mflips,
    Vectorized_Pauli& P, 
    BitString& bs
); 
std::ostream& operator<<(std::ostream& os, const SampleBlock& sb); 

struct SampleLoop; 

using Sample = std::variant<SampleBlock, SampleLoop>;

struct SampleLoop {
    int repeat; 
    std::vector<Sample> circ_lst;
    
    SampleLoop() = default; 
    SampleLoop(const SampleLoop&) = default; 
    SampleLoop(SampleLoop&&) = default; 
    SampleLoop& operator=(const SampleLoop&) = default; 
    SampleLoop& operator=(SampleLoop&&) = default; 
    SampleLoop(const std::initializer_list<Sample>& lst, int r=1) : repeat(r), circ_lst(std::vector<Sample>(lst)) {}
    SampleLoop(const std::vector<Sample>& lst, int r=1) : repeat(r), circ_lst(lst) {}
    SampleLoop(const Sample& s, int r=1) :  repeat(r), circ_lst(std::vector<Sample>{s}) {}
    SampleLoop(const Loop& L); 

    const Sample& operator[](size_t index) const; 
}; 

// void mzd_copy_submatrix(
//     mzd_t* dest, mzd_t* source, 
//     size_t start_r, size_t end_r
// ); 
void transpose_inplace(
    size_t qubits, 
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& gates, 
    std::vector<Vectorized_Pauli>& Tmatrix,
    std::vector<BitString>& BSmatrix 
); 

std::vector<std::pair<BitString, int64_t>> measure(int shots, const std::vector<Sample>& lst); 
std::vector<std::pair<BitString, int64_t>> bulk_measure(int shots, std::vector<Sample>& lst);
std::ostream& operator<<(std::ostream& os, const SampleLoop& sl); 

void printSampledLoop(const Loop& loop);
void printCircuitwithLoop(const Block& circ1, const Loop& loop, const Block& circ2); 

#endif
</file>

<file path="Sample_Circuits/Loop/tests.cc">
#include "tests.h"

Block test1() {
    double error_prob = 0.000003; 
    double measure_prob = 0.000003; 
    int repeats = 5; 
    std::vector<Operator> operators; 
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Y3"));
    operators.push_back(Clifford("Y4"));
    operators.push_back(Clifford("Z3 X5"));
    operators.push_back(Clifford("Z3")); 
    operators.push_back(Clifford("X5")); 
    operators.push_back(Clifford("Z4 X2"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X2"));
    operators.push_back(Clifford("Y2"));
    operators.push_back(Clifford("Z4 X5"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X5"));
    operators.push_back(Clifford("Z2 X1"));
    operators.push_back(Clifford("Z2")); 
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Z3"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Z2"));
    operators.push_back(Clifford("Z5 X1"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Y5"));
    operators.push_back(Clifford("Z5 X2"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X2"));

    for (int r = 0; r < repeats; ++r) {
        if (error_prob > 0) {
            for (size_t i = 1; i <= 5; ++i) {
                operators.emplace_back(Error(error_prob, std::set<size_t>{i}));
            }
        }
        operators.emplace_back(Measure("X1 Z2 Z3 X4", false, measure_prob));
        operators.emplace_back(Measure("X2 Z3 Z4 X5", false, measure_prob));
        operators.emplace_back(Measure("X3 Z4 Z5 X1", false, measure_prob));
        operators.emplace_back(Measure("X4 Z5 Z1 X2", false, measure_prob));
    }

    return Block(operators); 
}

Block test2() {
    std::vector<Operator> operators; 
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Y3"));
    operators.push_back(Clifford("Y4"));
    operators.push_back(Clifford("Z3 X5"));
    operators.push_back(Clifford("Z3")); 
    operators.push_back(Clifford("X5")); 
    operators.push_back(Clifford("Z4 X2"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X2"));
    operators.push_back(Clifford("Y2"));
    operators.push_back(Clifford("Z4 X5"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X5"));
    operators.push_back(Clifford("Z2 X1"));
    operators.push_back(Clifford("Z2")); 
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Z3"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Z2"));
    operators.push_back(Clifford("Z5 X1"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Y5"));
    operators.push_back(Clifford("Z5 X2"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X2"));

    return Block(operators); 
}

Loop looptest2() {
    double error_prob = 0.000003; 
    double measure_prob = 0.000003; 
    int repeats = 5; 
    std::vector<Operator> operators;  
    if (error_prob > 0) {
        for (size_t i = 1; i <= 5; ++i) {
            operators.emplace_back(Error(error_prob, std::set<size_t>{i}));
        }
    }
    operators.emplace_back(Measure("X1 Z2 Z3 X4", false, measure_prob));
    operators.emplace_back(Measure("X2 Z3 Z4 X5", false, measure_prob));
    operators.emplace_back(Measure("X3 Z4 Z5 X1", false, measure_prob));
    operators.emplace_back(Measure("X4 Z5 Z1 X2", false, measure_prob));

    return Loop(Standardized_Block(operators, std::nullopt, false), repeats); 
}
</file>

<file path="Sample_Circuits/Loop/tests.h">
#ifndef _STIM_TESTS
#define _STIM TESTS 

#include "Loop.h"
#include "Sample.h"
#include "Block.h"
#include "Operator.h"

Block test1(); 
Block test2(); 
Loop looptest1(); 
Loop looptest2(); 

#endif
</file>

<file path="Sample_Circuits/CMakeLists.txt">
cmake_minimum_required(VERSION 3.10)

if(NOT CMAKE_C_COMPILER)
    set(CMAKE_C_COMPILER gcc)
endif()

if(NOT CMAKE_CXX_COMPILER)
    set(CMAKE_CXX_COMPILER "g++")
endif()

project(MyStimProgram)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_CXX_FLAGS_DEBUG "-g -Wall -Wextra -mavx2")
set(CMAKE_CXX_FLAGS_RELEASE "-O3 -march=native -mavx2 -ffast-math -DNDEBUG")

# Find OpenMP  
find_package(OpenMP REQUIRED COMPONENTS C CXX)  
if(OpenMP_CXX_FOUND)  
    message(STATUS "OpenMP found: ${OpenMP_CXX_VERSION}")  
    message(STATUS "OpenMP CXX flags: ${OpenMP_CXX_FLAGS}")  
else()  
    message(FATAL_ERROR "OpenMP not found!")  
endif()  

# Your source files
add_executable(test 
    parse.cc
    ../Loop/Block.cc
    ../Loop/Loop.cc
    ../Loop/Operator.cc
    # ../Loop/Sample.cc
    ../Loop/SampleSparse.cc
    ../Test_Pauli/Stim_Pauli.cc
    ../Pauli.cc
    ../Permutation.cc
)

# Include Stim headers and lib directories
target_include_directories(test PRIVATE ${CMAKE_SOURCE_DIR}/Stim/src)

target_link_directories(test PRIVATE ${CMAKE_SOURCE_DIR}/Stim/out/out)

# Add M4RI include directory (adjust if installed elsewhere)
target_include_directories(test PRIVATE /usr/local/include)
# Add M4RI library directory
link_directories(/usr/local/lib)

target_include_directories(test PRIVATE $ENV{HOME}/graphblas-install/include)
find_library(GRAPHBLAS_LIB graphblas PATHS "$ENV{HOME}/graphblas-install/lib" NO_DEFAULT_PATH)
link_directories($ENV{HOME}/graphblas-install/lib)

# Link libraries: stim and m4ri
if (GRAPHBLAS_LIB)
    target_link_libraries(test stim m4ri ${GRAPHBLAS_LIB})
else()
    message(FATAL_ERROR "GraphBLAS library not found!")
endif()

target_compile_options(test PRIVATE ${OpenMP_CXX_FLAGS})
</file>

<file path="Sample_Circuits/parse.cc">
#include "parse.h"
#include <chrono>
  
// Right now, I am completely ignoring the possidbility of conditionals on gates 

void translateH(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets) {
    for (auto it = targets.begin(); it != targets.end(); ++it) {
        circ.operators.push_back(Clifford(Vectorized_Pauli({it->qubit_value() + 1}, {it->qubit_value() + 1}))); // Y_q 
    }
}

void translateCX(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets) {
    for (auto it = targets.begin(); it < targets.end(); ++it) {
        circ.operators.push_back(Clifford(Vectorized_Pauli({(it + 1)->qubit_value() + 1}, {it->qubit_value() + 1}))); // Z_{q_1} X_{q_2}
        circ.operators.push_back(Clifford(Vectorized_Pauli({}, {it->qubit_value() + 1}))); // Z_{q_1}
        circ.operators.push_back(Clifford(Vectorized_Pauli({(++it)->qubit_value() + 1}, {}))); // X_{q_2}
    }
}

void translateCY(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets) {
    for (auto it = targets.begin(); it < targets.end(); ++it) {
        circ.operators.push_back(Clifford(Vectorized_Pauli({(it + 1)->qubit_value() + 1}, {it->qubit_value() + 1, (it + 1)-> qubit_value() + 1}))); // Z_{q_1} Y_{q_2}
        circ.operators.push_back(Clifford(Vectorized_Pauli({}, {it->qubit_value() + 1}))); // Z_{q_1} 
        circ.operators.push_back(Clifford(Vectorized_Pauli({(it + 1)->qubit_value() + 1}, {(it + 1)->qubit_value() + 1}))); // Y_{q_2}
        ++it;
    }
}

void translateCZ(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets) {
    for (auto it = targets.begin(); it < targets.end(); ++it) {
        circ.operators.push_back(Clifford(Vectorized_Pauli({}, {it->qubit_value() + 1, (it + 1)->qubit_value() + 1}))); // Z_{q_1} Z_{q_2}
        circ.operators.push_back(Clifford(Vectorized_Pauli({}, {it->qubit_value() + 1}))); // Z_{q_1} 
        circ.operators.push_back(Clifford(Vectorized_Pauli({}, {(++it)->qubit_value() + 1}))); // Z_{q_2}
    }
}

void translateM(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets, double prob) {
    for (auto it = targets.begin(); it != targets.end(); ++it) {
        circ.operators.push_back(Measure(Vectorized_Pauli({}, {it->qubit_value() + 1}), false, prob)); 
    }
}

void translateMR(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets, double prob) {
    for (auto it = targets.begin(); it != targets.end(); ++it) {
        circ.operators.push_back(Measure(Vectorized_Pauli({}, {it->qubit_value() + 1}), false, prob));
    }
    for (auto it = targets.begin(); it != targets.end(); ++it) {
        circ.operators.push_back(Reset(it->qubit_value() + 1)); 
    }
}

void translateMX(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets, double prob) {
    for (auto it = targets.begin(); it != targets.end(); ++it) {
        circ.operators.push_back(Measure(Vectorized_Pauli({it->qubit_value() + 1}, {}), false, prob));
    }
}

void translateR(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets) {
    for (auto it = targets.begin(); it != targets.end(); ++it) {
        circ.operators.push_back(Reset(it->qubit_value() + 1)); 
    }
}

void translateRX(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets) {
    for (auto it = targets.begin(); it != targets.end(); ++it) {
        circ.operators.push_back(Reset(Vectorized_Pauli({it->qubit_value() + 1}, {}))); 
    }
}

void translateDEPO1(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets, double prob) {
    if (prob != 0) {
        for (auto it = targets.begin(); it != targets.end(); ++it) {
            circ.operators.push_back(Error(prob, {it-> qubit_value() + 1})); 
        }
    } else {
        for (auto it = targets.begin(); it != targets.end(); ++it) {
            circ.operators.push_back(Error(0.00001, {it-> qubit_value() + 1})); 
        }
    }
    
}

void translateDEPO2(Block& circ, const stim::SpanRef<const stim::GateTarget>& targets, double prob) {
    if (prob != 0) {
        for (auto it = targets.begin(); it != targets.end(); ++it) {
            circ.operators.push_back(Error(prob, {it-> qubit_value() + 1, (++it)-> qubit_value() + 1})); 
        }
    } else {
        for (auto it = targets.begin(); it != targets.end(); ++it) {
            circ.operators.push_back(Error(0.00001, {it-> qubit_value() + 1, (++it)-> qubit_value() + 1})); 
        }
    }
}

// populates circs with what the representation of repeat_body in this code
void translateREPEAT(std::vector<SubCircuit>& circs, const stim::Circuit& repeat_body) {
    Block circ = Block(); 
    repeat_body.for_each_operation([&circ, &circs, repeat_body](const stim::CircuitInstruction& op) {
        translate(circ, circs, repeat_body, op); 
    }); 
    for (Block& B: parse(circ)) {
        B.standardize(); 
        Standardized_Block standard = Standardized_Block(); 
        standard.std_block = std::move(B); 
        standard.ancilla_measure = true; 
        standard.actual_qubit = standard.std_block.qubits(); 
        circs.push_back(std::move(standard)); 
    }
}

void translate(
    Block& circ,
    std::vector<SubCircuit>& circs, 
    const stim::Circuit& circuit, 
    const stim::CircuitInstruction& op
) {
    static Loop loop = Loop(); 
    static std::vector<Block> parsed = std::vector<Block>(); 
    switch (op.gate_type) {
        case stim::GateType::H : 
            translateH(circ, op.targets); 
            break; 
        case stim::GateType::CX : 
            translateCX(circ, op.targets); 
            break; 
        case stim::GateType::CY : 
            translateCY(circ, op.targets); 
            break;
        case stim::GateType::CZ :
            translateCZ(circ, op.targets);  
            break; 
        case stim::GateType::M : 
            if (!op.args.empty()) translateM(circ, op.targets, *op.args.begin()); 
            else translateM(circ, op.targets, 0); 
            break; 
        case stim::GateType::MX : 
            if (!op.args.empty()) translateMX(circ, op.targets, *op.args.begin()); 
            else translateMX(circ, op.targets, 0);
            break; 
        case stim::GateType::MR : 
            if (!op.args.empty()) translateMR(circ, op.targets, *op.args.begin()); 
            else translateMR(circ, op.targets, 0); 
            break; 
        case stim::GateType::TICK : 
            break; 
        case stim::GateType::R : 
            translateR(circ, op.targets); 
            break; 
        case stim::GateType::RX : 
            translateRX(circ, op.targets); 
            break; 
        case stim::GateType::DEPOLARIZE1 : 
            translateDEPO1(circ, op.targets, *op.args.begin()); 
            break; 
        case stim::GateType::DEPOLARIZE2 : 
            translateDEPO2(circ, op.targets, *op.args.begin()); 
            break; 
        case stim::GateType::OBSERVABLE_INCLUDE : 
            break; 
        case stim::GateType::DETECTOR : 
            break; 
        case stim::GateType::REPEAT : 
            std::cout << "In repeat" << std::endl;  
            parsed = parse(circ); 
            std::cout << "Done parsing" << std::endl; 
            int index = 0; 
            for (Block& B: parsed) {
                if (index == 0) {
                    ++index; 
                    continue; 
                }
                // std::cout << "This is a list of unstandardized operators\n"; 
                // for (const Operator& op: B.operators) std::cout << op << "\n"; 
                B.standardize(); 
                Standardized_Block standard = Standardized_Block(); 
                standard.std_block = std::move(B); 
                standard.ancilla_measure = true; 
                standard.actual_qubit = standard.std_block.qubits(); 
                circs.push_back(std::move(standard)); 
            }
            std::cout << "After parsing the first part" << std::endl; 
            circ = Block(); 
            translateREPEAT(loop.reduced_body, op.repeat_block_body(circuit)); 
            std::cout << "After pushing back operators from the repeat block" << std::endl; 
            loop.repeat = op.repeat_block_rep_count(); 
            circs.push_back(std::move(loop)); 
            loop = Loop(); 
            break; 
        // default : 
            // std::cout << "Error\n"; 
    }
}

void group_resets(const Standardized_Block& B, Standardized_Block& next) {
    for (const Operator& op: B.std_block.operators) {
        const Reset& R = std::get<Reset>(op); 
        next.std_block.operators.push_back(R); 
    }
}

void group_resets(SubCircuit& last, Loop& L) {
    Standardized_Block& resets = std::get<Standardized_Block>(L.reduced_body[0]); 
    if (!std::holds_alternative<Reset>(resets.std_block.operators[0])) return; 
    while (std::holds_alternative<Loop>(L.reduced_body[L.reduced_body.size() - 1])) 
        L = std::get<Loop>(L.reduced_body[L.reduced_body.size() - 1]); 
    Standardized_Block& last_block_of_loop = std::get<Standardized_Block>(L.reduced_body[L.reduced_body.size() - 1]);
    if (std::holds_alternative<Standardized_Block>(last)) {
        Standardized_Block& last_block = std::get<Standardized_Block>(last); 
        for (const Operator& op: resets.std_block.operators) {
            const Reset& R = std::get<Reset>(op); 
            last_block.std_block.operators.push_back(R); 
            last_block_of_loop.std_block.operators.push_back(R); 
        }
    }
    for (const Operator& op: resets.std_block.operators) {
        const Reset& R = std::get<Reset>(op); 
        last_block_of_loop.std_block.operators.push_back(R); 
    }
    L.reduced_body.erase(L.reduced_body.begin()); 
}

// If there are any single blocks consisting of only resets, this function will group them with the previous block
void group_resets(std::vector<SubCircuit>& circ) {
    for (size_t i = 1; i < circ.size(); ++i) {
        if (std::holds_alternative<Standardized_Block>(circ[i])) {
            Standardized_Block& B = std::get<Standardized_Block>(circ[i]); 
            if (std::holds_alternative<Reset>(B.std_block.operators[0])) {
                if (std::holds_alternative<Standardized_Block>(circ[i + 1])) {
                    group_resets(B, std::get<Standardized_Block>(circ[i+1])); 
                }
                circ.erase(circ.begin() + i);  
            }
        } else {
            group_resets(circ[i - 1], std::get<Loop>(circ[i])); 
        }
    }
    if (std::holds_alternative<Standardized_Block>(circ[0])) {
        Standardized_Block& B = std::get<Standardized_Block>(circ[0]); 
        if (std::holds_alternative<Reset>(B.std_block.operators[0])) 
            circ.erase(circ.begin()); 
    }
}

Standardized_Block remove_resets(const std::vector<Standardized_Block>& L) {
    for (const SubCircuit& S : L) {
        if (std::holds_alternative<Loop>(S)) std::invalid_argument("Does not support nested loops"); 
    }
    std::vector<Operator> res; 
    size_t lastactual = L[0].std_block.qubits(); 
    size_t lastqubit = 0; 
    for (const Operator& op : L[0].std_block.operators) {
        if (std::holds_alternative<Reset>(op)) {
            const Reset& R = std::get<Reset>(op); 
            lastqubit = std::max(lastqubit, R.qubits()); 
            lastactual = std::min(lastactual, R.qubits()); 
        } else {
            res.push_back(op); 
        }
    }
    --lastactual; 
    ++lastqubit; 
    for (size_t i = 1; i < L.size(); ++i) {
        const SubCircuit& subcirc = L[i]; 
        std::map<size_t, size_t> reset_map; 
        for (const Operator& op : std::get<Standardized_Block>(subcirc).std_block.operators) {
            if (std::holds_alternative<Reset>(op)) {
                reset_map.insert({std::get<Reset>(op).qubits(), lastqubit}); 
                ++lastqubit; 
            } 
        }
        for (const Operator& op : std::get<Standardized_Block>(subcirc).std_block.operators) {
            if (!std::holds_alternative<Reset>(op)) {
                auto Op = op; 
                std::visit([reset_map](auto& _op) {
                    for (const std::pair<const size_t, size_t>& pr : reset_map) {
                        _op.change_qubit(pr.first, pr.second); 
                    }
                }, Op); 
                res.push_back(std::move(Op)); 
            }
        }
    }
    for (size_t reset = lastactual + 1; reset < lastqubit; ++reset) {
        res.push_back(Reset(reset)); 
    }
    // Assumed: This will be the format after measurements are extracted 
    Block B; 
    B.operators = std::move(res);
    Standardized_Block std_B = Standardized_Block(); 
    std_B.std_block = std::move(B); 
    std_B.std_block.standardize(); 
    std_B.ancilla_measure = false; 
    std_B.actual_qubit = lastactual; 
    return std_B; 
}

Loop remove_resets(const Loop& L) {
    for (const SubCircuit& S : L.reduced_body) {
        if (std::holds_alternative<Loop>(S)) std::invalid_argument("Does not support nested loops"); 
    }
    std::vector<Operator> res; 
    size_t lastactual = std::get<Standardized_Block>(L.reduced_body[0]).std_block.qubits(); 
    size_t lastqubit = 0; 
    for (const Operator& op : std::get<Standardized_Block>(L.reduced_body[0]).std_block.operators) {
        if (std::holds_alternative<Reset>(op)) {
            const Reset& R = std::get<Reset>(op); 
            lastqubit = std::max(lastqubit, R.qubits()); 
            lastactual = std::min(lastactual, R.qubits()); 
        } else {
            res.push_back(op); 
        }
    }
    --lastactual; 
    ++lastqubit; 
    for (size_t i = 1; i < L.reduced_body.size(); ++i) {
        const SubCircuit& subcirc = L.reduced_body[i]; 
        std::map<size_t, size_t> reset_map; 
        for (const Operator& op : std::get<Standardized_Block>(subcirc).std_block.operators) {
            if (std::holds_alternative<Reset>(op)) {
                reset_map.insert({std::get<Reset>(op).qubits(), lastqubit}); 
                ++lastqubit; 
            } 
        }
        for (const Operator& op : std::get<Standardized_Block>(subcirc).std_block.operators) {
            if (!std::holds_alternative<Reset>(op)) {
                auto Op = op; 
                std::visit([reset_map](auto& _op) {
                    for (const std::pair<const size_t, size_t>& pr : reset_map) {
                        _op.change_qubit(pr.first, pr.second); 
                    }
                }, Op); 
                res.push_back(std::move(Op)); 
            }
        }
    }
    for (size_t reset = lastactual + 1; reset < lastqubit; ++reset) {
        res.push_back(Reset(reset)); 
    }
    // Assumed: This will be the format after measurements are extracted 
    Block B; 
    B.operators = std::move(res);
    Standardized_Block std_B = Standardized_Block(); 
    std_B.std_block = std::move(B); 
    std_B.std_block.standardize(); 
    std_B.ancilla_measure = false; 
    std_B.actual_qubit = lastactual; 
    return Loop(std_B, L.repeat); 
}

int main() {  
    // Load circuit from file  
    FILE* f = fopen("../surface_code_100.stim", "r"); 
    if (!f) {
        perror("Failed to open file");
        return 1;
    }
    stim::Circuit circuit = stim::Circuit::from_file(f);  

    GrB_init(GrB_BLOCKING);
    GrB_Global_set_INT32(GrB_GLOBAL, GrB_ROWMAJOR, GrB_STORAGE_ORIENTATION_HINT); 

    std::cout << "compiled\n"; 
    std::vector<SubCircuit> circs; 
    Block circ = Block(); 
    circuit.for_each([&circ, &circs, circuit](const stim::CircuitInstruction& op) {  
        translate(circ, circs, circuit, op); 
    });   
    for (Block& B: parse(circ)) {
        // std::cout << "This is a list of unstandardized operators\n"; 
        // for (const Operator& op: B.operators) std::cout << op << "\n"; 
        B.standardize(); 
        Standardized_Block standard = Standardized_Block(); 
        standard.std_block = std::move(B); 
        standard.ancilla_measure = true; 
        standard.actual_qubit = standard.std_block.qubits(); 
        circs.push_back(std::move(standard)); 
    }

    std::vector<Sample> lst; 
    int index = 0; 

    // for (const SubCircuit& c: circs) {
    //     std::cout << index << std::endl; 
    //     if (std::holds_alternative<Standardized_Block>(c)) {
    //         std::cout << "This is a block\n"; 
    //         std::cout << std::get<Standardized_Block>(c) << "\n\n"; 
    //         // lst.push_back(SampleBlock(std::get<Standardized_Block>(c)));
    //     }
    //     else { 
    //         std::cout << "This is a Loop\n"; 
    //         std::cout << std::get<Loop>(c) << "\n\n"; 
    //         // lst.push_back(SampleLoop(remove_resets(std::get<Loop>(c))));
    //         // lst.push_back((std::get<Loop>(c)));
    //     }   
    //     ++index; 
    // }
    group_resets(circs); 
    std::cout << circs.size() << std::endl; 

    for (const SubCircuit& c: circs) {
        std::cout << index << std::endl; 
        if (std::holds_alternative<Standardized_Block>(c)) {
            std::cout << "This is a block\n"; 
            // std::cout << std::get<Standardized_Block>(c) << "\n\n"; 
            lst.push_back(SampleBlock(std::get<Standardized_Block>(c)));
        }
        else { 
            std::cout << "This is a Loop\n"; 
            // std::cout << std::get<Loop>(c) << "\n\n"; 
            // const Loop& L = remove_resets(std::get<Loop>(c)); 
            const Loop& L = std::get<Loop>(c); 
            // std::cout << "After removing resets: " << L << std::endl; 
            lst.push_back(SampleLoop(L));
        }   
        ++index; 
    }
    // circs.clear();

    using Clock = std::chrono::high_resolution_clock;

    std::vector<std::pair<BitString, int64_t>> results; 
    auto start_vectorized = Clock::now();
    std::cout << "Starting to measure" << std::endl; 
    results = bulk_measure(100000, lst); 
    auto end_vectorized = Clock::now();

    auto time = std::chrono::duration_cast<std::chrono::milliseconds>(end_vectorized - start_vectorized).count();
    std::cout << "it took: " << time << " ms\n";
    GrB_finalize();
    // for (std::pair<BitString, int64_t> pr : results) {
    //     std::cout << pr.first << " " << pr.second << "\n"; 
    // }

    return 0;  
}
</file>

<file path="Sample_Circuits/parse.h">
#ifndef _STIM_PARSE
#define _STIM_PARSE

#include "Stim/src/stim.h"  
#include "Loop/SampleSparse.h"
#include "Loop/Block.h"
#include <iostream>  

void translate(
    Block& circ,
    std::vector<SubCircuit>& circs, 
    const stim::Circuit& circuit, 
    const stim::CircuitInstruction& op
);

#endif
</file>

<file path="Test_Pauli/Circuit.cc">
#include "Circuit.h"

Circuit::Circuit(const std::initializer_list<Operator>& ops) {
    operators = std::vector<Operator> (ops); 
}

const Operator& Circuit::operator[] (size_t index) const {
    return operators[index]; 
}

Operator& Circuit::operator[] (size_t index) {
    return operators[index]; 
}

void Circuit::push(const Operator& op) {
    operators.push_back(op); 
}

void Circuit::push_first(const Operator& op) {
    operators.insert(operators.begin(), op); 
}

void Circuit::append(std::initializer_list<Operator> ops) {
     for (const Operator& op: ops) {
        operators.push_back(op); 
     }
}

void Circuit::append(std::initializer_list<Circuit> subcircs) {
    for (const Circuit& subcirc : subcircs) {
        for (const Operator& op : subcirc.operators) {
            operators.push_back(op); 
        }
    }
}

void Circuit::splice(size_t index, const Circuit& subcirc) {
    if (index > operators.size()) {
        throw std::out_of_range("Index out of range");
    } else {
        operators.erase(operators.begin() + index);
        operators.insert(operators.begin() + index, 
                         subcirc.operators.begin(), 
                         subcirc.operators.end());
    }
}

size_t Circuit::length() const {
    return operators.size(); 
}

size_t Circuit::qubits() const {
    size_t max_qubits = 0;
    for (const Operator& op : operators) {
        max_qubits = std::max(max_qubits, 
                            std::visit([](const auto& _op) -> size_t {
                                return _op.qubits();  
                            }, op));
    }
    return max_qubits;
}

std::set<size_t> Circuit::support(
    std::optional<size_t> left_index,
    std::optional<size_t> right_index
) const {
    size_t lindex = left_index ? *left_index : 0; // assumes c++ doesn't support custom indexing
    size_t rindex = right_index ? *right_index : operators.size() - 1; 
    std::set<size_t> supp; 
    for (size_t i = lindex; i <= rindex; ++i) 
        supp = set_union(supp, std::visit([](const auto& _op) -> std::set<size_t> {
                                return _op.support();
                                }, operators[i]));  
    return supp;
}

void Circuit::extract_measures(size_t index) { // the operator at index should be a measure
    Operator op = operators[index]; 
    if (!std::holds_alternative<Measure>(op)) return; 
    Measure& M = std::get<Measure>(op); 
    Circuit subcirc = Circuit(); 
    size_t q = qubits() + 1; 
    Vectorized_Pauli Xq = Vectorized_Pauli("X" + std::to_string(q)); 

    // ??? 
    subcirc.push(Reset("Z" + std::to_string(q)));
    subcirc.push(Clifford(M.pauli * Xq)); 
    subcirc.push(Clifford(M.pauli)); 
    subcirc.push(Clifford(Xq)); 
    subcirc.push(Error(M.pauli)); 
    subcirc.push(Measure("Z" + std::to_string(q), M.sign, M.probability)); 
    splice(index, subcirc); 
}

void Circuit::extract_measures() {
    size_t index = 0; 
    Operator op; 
    while (index < length()) {
        op = operators[index]; 
        if (std::holds_alternative<Measure>(op)) {
            // checks if this operation involves more than one qubit 
            if (std::visit([](const auto& _op) {return _op.weight(); }, op) > 1) {
                extract_measures(index); 
            }
            else 
            {
                // index of the first (and only) qubit in the operation
                size_t q = std::visit([](const auto& _op) {return *(_op.support().begin()); }, op); 
                // else, the operation involves a single qubit and you check whether there are more operations 
                // on this qubit after the measurement
                std::set<size_t> supp = support(index + 1); 
                if (supp.find(q) != supp.end()) {
                    extract_measures(index); 
                }
            }
        }
        ++index; 
    }
}

// doesn't add errors 
void Circuit::add_resets() {
    for (size_t q = 1; q <= qubits(); ++q) {
        Operator first_op = Operator(); // in case there is no operator acting on the qubit at index 
        // finds the first operator that acts on the qubit at index
        for (const Operator& op : operators) {
            std::set<size_t> supp = std::visit([](const auto& _op) {
                return _op.support();
            }, op);
            if (supp.find(q) != supp.end()) {
                first_op = op; 
                break; 
            }
        }
        if (!std::holds_alternative<Reset>(first_op)) 
            push_first(Reset(q)); 
    }
}

// for loops; also adds all the errors 
void Circuit::add_initial_resets() {
    for (size_t q = qubits(); q >= 1; --q) {
        Operator first_op = Operator(); // in case there is no operator acting on the qubit at index 
        // finds the first operator that acts on the qubit at index
        for (const Operator& op : operators) {
            std::set<size_t> supp = std::visit([](const auto& _op) {
                return _op.support();
            }, op);
            if (supp.find(q) != supp.end()) {
                first_op = op; 
                break; 
            }
        }
        if (!std::holds_alternative<Reset>(first_op)) {
            push_first(Error(Reset(q))); 
            push_first(Reset(q)); 
        }
    }
}

// returns the index of the first non-reset after this sort 
size_t Circuit::pull_resets_first() {
    size_t last_reset = 0; 
    for (size_t index = operators.size(); index > 0; --index) {
        if (std::holds_alternative<Reset>(operators[index - 1])) {
            last_reset = index;
            break;
        }
    }
    if (last_reset != 0) {
        size_t index = last_reset; 
        while (index > 0) {
            Operator& op = operators[index - 1]; 
            // commutes every non-reset forwards to past the last reset
            // only resets should occur between index (inclusive) and last_reset (non-inclusive)
            if (!std::holds_alternative<Reset>(op)) {
                for (size_t i = index; i < last_reset; ++i) {
                    const Reset& R = std::get<Reset>(operators[i]); 
                    std::visit([R](auto& _op) {commute_inplace(_op, R);}, op); 
                }
                operators.insert(operators.begin() + last_reset, std::move(op)); 
                operators.erase(operators.begin() + index - 1); // the -1 is because everything is greater by 1 to avoid a negative size_t
                --last_reset; 
            }
            --index; 
        }
        return last_reset; 
    }
    return 0; 
}

// this part of the circuit should only contain errors added for measurements
// and the measurements for the loop
// returns the index of the first measure after this sort 
size_t Circuit::push_merrors_last() {
    size_t first_measure = operators.size(); 
    for (size_t index = 0; index < operators.size(); ++index) {
        if (std::holds_alternative<Measure>(operators[index])) {
            first_measure = index; 
            break; 
        }
    }
    if (first_measure != operators.size()) {
        size_t index = operators.size() - 1; 
        while (index > first_measure) {
            const Operator& op = operators[index]; 
            // commutes every error in the last part past the measurements 
            if (std::holds_alternative<Error>(op)) {
                // The Error does not change when you commute it through with only errors and measurements 
                operators.insert(operators.end(), op); 
                operators.erase(operators.begin() + index);
            }
            --index; 
        }
    }
    return first_measure; 
}

void Circuit::pull_errors_through_gates(int start, int end) {
    // number of errors 
    int errors = 0; 
    for (int index = start + 1; index <= end; ++index) {
        if (std::holds_alternative<Error>(operators[index])) {
            Error& E = std::get<Error>(operators[index]); 
            for (int i = index - 1; i >= start + errors; --i) {
                const Operator& op2 = operators[i];
                std::visit([&E](const auto& _op2) {commute_back_inplace(E, _op2); }, op2);
            }
            // since errors always commute with each other, we can always insert errors to the very beginning
            // and skip the commuting across the errors part             
            operators.insert(operators.begin() + start, std::move(operators[index + 1])); // because there is something inserted into the operator, the index will be +1
            operators.erase(operators.begin() + index + 1); 
            ++errors; 
        }
    }
}

void Circuit::reorder() {
    size_t index = 0; 
    while(index < length()) {
        const Operator& op = operators[index]; 
        if (std::holds_alternative<Reset>(op)) {
            operators.insert(operators.begin(), std::move(op));
            operators.erase(operators.begin() + index + 1); 
        } else {
            // moves all the measures to the end 
            if (std::holds_alternative<Measure>(op)) {
                // checks if anything after this operator is not a Measure 
                bool not_a_measure = false;
                for (size_t i = index + 1; i < operators.size(); ++i) {
                    if (!std::holds_alternative<Measure>(operators[i])) {
                        not_a_measure = true; 
                        break; 
                    }
                }
                if (not_a_measure) {
                    operators.insert(operators.end(), std::move(op)); 
                    operators.erase(operators.begin() + index); 
                    --index; 
                }
            }
        }
        ++index; 
    }
}

void Circuit::add_reset_errors() {
    size_t index = 0; 
    while (index < length()) {
        if (std::holds_alternative<Reset>(operators[index])) {
            operators.insert(operators.begin() + index + 1, Error(std::get<Reset>((*this)[index])));
            ++index;  
        }
        ++index; 
    }
}

void Circuit::add_measure_errors() {
    size_t index = 0; 
    while (index < length()) {
        if (std::holds_alternative<Measure>((operators[index]))) {
            operators.insert(operators.begin() + index + 1, Error(std::get<Measure>((*this)[index])));
            ++index; 
        }
        ++index; 
    }
}

size_t Circuit::measurements() const {
    size_t count = 0; 
    for (const Operator& op : operators) {
        if (std::holds_alternative<Measure>(op)) ++count; 
    }
    return count; 
}

std::ostream& operator<<(std::ostream& os, const Circuit& circ) {
    size_t q = circ.qubits();  
    for (const Operator& op : circ.operators)
        os << op << "\n";  
        // os << fixed_length_string(op, q) << "\n"; 
    return os; 
}

Circuit combine(const Circuit& C1, const Circuit& C2) {
    Circuit circ; 
    circ.operators = C1.operators; 
    for (const Operator& op: C2.operators) {
        circ.operators.push_back(op); 
    }
    return circ; 
}

// size_t is the index of the repeat in the circ and uint64_t is the number of times the loop body is repeated
std::vector<Circuit> parse(const Circuit& circ) { 
    std::vector<Circuit> lst; 
    size_t length = circ.length(); 
    size_t index = 0; 
    size_t start = 0; 
    size_t end = 0; 
    while (index < length) {
        while ((std::holds_alternative<Clifford>(circ[index]) || std::holds_alternative<Error>(circ[index])) && index < length) 
            ++index; 
        if (std::holds_alternative<Measure>(circ[index])) {
            while ((std::holds_alternative<Measure>(circ[index]) || std::holds_alternative<Clifford>(circ[index])) && index < length)
                ++index; 
            end = index; 
        } else { // holds a reset
            while (!std::holds_alternative<Measure>(circ[index]) && index < length) 
                ++index; 
            while ((std::holds_alternative<Measure>(circ[index]) || std::holds_alternative<Clifford>(circ[index])) && index < length)
                ++index;
            end = index; 
        }
        std::vector<Operator> ops; 
        for (int i = 0; i < end - start; ++i) {
            ops.push_back(circ[start + i]); 
        }
        lst.push_back(Circuit(ops)); 
        start = end; 
    }
    return lst; 
}
</file>

<file path="Test_Pauli/Circuit.h">
#ifndef _STIM_CIRCUIT
#define _STIM_CIRCUIT      

#include "Stim_Pauli.h"
#include "Operator.h"

struct Circuit {
    std::vector<Operator> operators; 
    Circuit() = default; 
    Circuit(const Circuit&) = default; 
    Circuit(Circuit&&) noexcept = default;
    Circuit(std::vector<Operator> ops) : operators(std::move(ops)) {}
    Circuit& operator=(const Circuit&) = default;
    Circuit& operator=(Circuit&&) noexcept = default;
    Circuit(const std::initializer_list<Operator>& ops);

    const Operator& operator[] (size_t index) const; 
    Operator& operator[] (size_t index); 
    // set index
    void push(const Operator& op); 
    void push_first(const Operator& op); 
    void append(std::initializer_list<Operator> ops); 
    void append(std::initializer_list<Circuit> subcircs);
    void splice(size_t index, const Circuit& subcirc=Circuit());  

    size_t length() const; 
    size_t qubits() const; 
    std::set<size_t> support(
        std::optional<size_t> left_index=std::nullopt,
        std::optional<size_t> right_index=std::nullopt
    ) const; 
    void extract_measures(size_t index); 
    void extract_measures(); 
    void add_resets(); 
    void add_initial_resets(); 
    size_t pull_resets_first(); 
    size_t push_merrors_last(); 
    void pull_errors_through_gates(int start, int end); 
    void reorder(); 
    void add_reset_errors(); 
    void add_measure_errors(); 
    
    size_t measurements() const; 
} ; 

std::ostream& operator<<(std::ostream& os, const Circuit& circ) ; 
Circuit combine(const Circuit& C1, const Circuit& C2); 
std::vector<Circuit> parse(const Circuit& circ); 

#endif
</file>

<file path="Test_Pauli/CMakeLists.txt">
cmake_minimum_required(VERSION 3.10)

if(NOT CMAKE_C_COMPILER)
    set(CMAKE_C_COMPILER gcc)
endif()

if(NOT CMAKE_CXX_COMPILER)
    set(CMAKE_CXX_COMPILER "g++")
endif()

project(Stim)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_compile_options(-Wall -Wextra -O3 -mavx2 -g)

set(SOURCES
    Stim_Pauli.cc
    main.cc
    ../Pauli.cc 
    ../Permutation.cc
    Operator.cc
    Circuit.cc
    tests.cc
    Loop.cc
    SampleLoop.cc
    main.cc
)

add_executable(test ${SOURCES})
</file>

<file path="Test_Pauli/Loop.cc">
#include "Loop.h"

Loop::Loop(const Circuit& C, int r, bool am) {
    circ = Circuit(C); 
    repeat = r; 
    ancilla_measures = am; 
    reduced_circ = standardize(C, ancilla_measures); 
} 

Loop::Loop(const std::initializer_list<Operator>& ops, int r, bool am) {
    circ = Circuit(ops);
    repeat = r; 
    ancilla_measures = am; 
    reduced_circ = standardize(circ, ancilla_measures);  
}

void Loop::insert(const Operator& op, size_t index) {
    circ.operators.insert(circ.operators.begin() + index, op); 
    reduced_circ = standardize(circ, ancilla_measures); 
}

void Loop::push_first(const Operator& op) {
    circ.push_first(op);
    reduced_circ = standardize(circ, ancilla_measures); 
}

void Loop::push(const Operator& op) {
    circ.push(op); 
    reduced_circ = standardize(circ, ancilla_measures); 
}

void Loop::append(const std::initializer_list<Operator>& ops) {
    circ.append(ops); 
    reduced_circ = standardize(circ, ancilla_measures); 
}

Circuit standardize(const Circuit& new_circ, bool am) {
    Circuit modified = new_circ; 
    if (am) modified.extract_measures(); 
    if (!am) modified.add_measure_errors();     
    modified.reorder(); 
    modified.add_reset_errors(); 

    // put this modified circuit into the format: 
    //      RESETS - ERRORS - GATES - MEASURES - MEASURE ERRORS
    size_t start = modified.pull_resets_first(); // index of first gate in circuit
    size_t end = modified.push_merrors_last() - 1; // index of last error
    modified.pull_errors_through_gates(start, end); 

    return modified; 
}

Loop combine(const Loop& L1, const Loop& L2) {
    Loop res; 
    Circuit extracted = L1.circ;
    extracted.extract_measures(); 
    res.circ = combine(extracted, L2.circ);
    res.reduced_circ = res.circ;  
    res.reduced_circ.extract_measures(); 
    res.reduced_circ.reorder(); 
    res.reduced_circ.add_reset_errors(); 
    res.reduced_circ.add_measure_errors(); 

    size_t start = res.reduced_circ.pull_resets_first(); // start of all possible errors to pull
    size_t end = res.reduced_circ.push_merrors_last() - 1; // end of all gates to be pulled through
    res.reduced_circ.pull_errors_through_gates(start, end); 

    return res; 
}

std::ostream& operator<<(std::ostream& os, const Loop& loop) {
    os << "REPEAT FOR: " << loop.repeat << " TIMES \n"; 
    os << "THE REPEAT BLOCK: \n"; 
    os << loop.circ; 
    os << "THE SIMPLIFIED BLOCK: \n"; 
    os << loop.reduced_circ; 
    return os; 
}
</file>

<file path="Test_Pauli/Loop.h">
#ifndef _STIM_LOOP
#define _STIM_LOOP

#include "Circuit.h"
#include <map>

struct Loop {
    bool ancilla_measures; 
    Circuit circ; 
    Circuit reduced_circ; 
    int repeat; 

    Loop() = default; 
    Loop(const Loop&) = default; 
    Loop& operator=(const Loop&) = default; 
    Loop(const Circuit& C, int r, bool am=true); 
    Loop(const std::initializer_list<Operator>& ops, int r, bool am=true); 

    void set_repeat(int r) {repeat = r;} 

    void insert(const Operator& op, size_t index); 
    void push_first(const Operator& op);
    void push(const Operator& op); 
    void append(const std::initializer_list<Operator>& ops);  
    
} ; 

// reproduces an equivalent circuit that is in the block format: (Resets), Errors, Gates, Measures, (Errors)
// given circ, gives reduced_circ
Circuit standardize(const Circuit& new_circ, bool am); 
Loop combine(const Loop& L1, const Loop& L2); 
std::ostream& operator<<(std::ostream& os, const Loop& loop); 

#endif
</file>

<file path="Test_Pauli/main.cc">
#include "Stim_Pauli.h" 
#include "../Pauli.h"
#include "SampleLoop.h"
#include "tests.h"
#include <cassert>
#include <chrono>

using Clock = std::chrono::high_resolution_clock;

void benchmark_pauli_vs_vectorized(size_t trials, size_t qubits) {
    std::vector<Pauli> paulis;
    for (size_t i = 0; i < trials; ++i) {
        paulis.push_back(random_Pauli(qubits));
    }
    std::cout << "here\n"; 

    // Convert to vectorized format (not timed)
    std::vector<Vectorized_Pauli> vec_paulis;
    for (size_t i = 0; i < trials; ++i) {
        vec_paulis.emplace_back(vectorize(paulis[i]));
    }
    std::cout << "here\n"; 

    // Time scalar Pauli multiplication
    auto start_scalar = Clock::now();
    for (size_t i = 0; i < trials; ++i) {
        paulis[i] *= paulis[(i + 1) % trials];
    }
    auto end_scalar = Clock::now();
    std::cout << "here\n"; 

    // Time vectorized Pauli multiplication
    auto start_vectorized = Clock::now();
    for (size_t i = 0; i < trials; ++i) {
        vec_paulis[i] *= vec_paulis[(i + 1) % trials];
    }
    auto end_vectorized = Clock::now();

    for (size_t i = 0; i < trials; ++i) {
        // std::cout << i; 
        if (! (vectorize(paulis[i]) == vec_paulis[i]))
            std::cout << "Inconsistent multiplication for trial " << i << "\n\n\n"; 
    }

    auto scalar_time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end_scalar - start_scalar).count();
    auto vector_time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end_vectorized - start_vectorized).count();

    std::cout << "Scalar Pauli *= took: " << scalar_time_ms << " ms\n";
    std::cout << "Vectorized Pauli *= took: " << vector_time_ms << " ms\n";
}


int main() {

    int shots = 1000000; 
    std::vector<std::pair<BitString, int64_t>> results; 
    SampleLoop l1 = SampleLoop(Loop(test2(), 1, false)); 
    SampleLoop l2 = SampleLoop(looptest2()); 
    // std::cout << test2(); 
    // std::cout << looptest2(); 
    auto start = Clock::now(); 
    results = bulk_measure(shots, {l1, l2}); 
    auto end = Clock::now(); 
    std::cout << "It took: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << " ms \n"; 
    // SampleLoop sample_loop = SampleLoop(looptest2()); 
    // for (int i : sample_loop.rqubits) std::cout << i <<"\n"; 
    // for (Error E: sample_loop.errors) std::cout << "Actual Error: " << E << "\n"; 
    // for (Error E: sample_loop.merrors) std::cout << "Measurement Error: " << E << "\n"; 
    // for (std::pair<Pauli, std::pair<Pauli, BitString>> map : sample_loop.map) {
    //     std::cout << map.first << " maps to \n"; 
    //     std::cout << map.second.first << "\n"; 
    //     std::cout << map.second.second << "\n"; 
    // }
    // results = sample_loop.measure(shots, test2(), Circuit()); 
    for (std::pair<BitString, int64_t> pr : results) {
        std::cout << pr.first << " " << pr.second << "\n"; 
    }

    // benchmark_pauli_vs_vectorized(30000, 1000); 

    // // basic tests
    // Vectorized_Pauli P1 = Vectorized_Pauli({1, 2, 3, 4, 10}, {2, 6, 9}); 
    // std::cout << "The first Pauli is: " << P1 << "\n"; 
    // Vectorized_Pauli P2 = Vectorized_Pauli({1, 3, 5, 6, 7, 10}, {1, 2, 3, 4, 7, 9, 12}); 
    // std::cout << "The second Pauli is: " << P2 << "\n"; 
    // Vectorized_Pauli empty = Vectorized_Pauli({}, {});
    // std::cout << "The empty Pauli is: " << empty << "\n"; 

    // std::cout << "Pauli multiplication using * gives: " << P1 * P2 << "\n"; 
    // std::cout << "Pauli mulitplication using * the other way: " << P2 * P1 << "\n"; 
    // std::cout << "Pauli multiplication by idenity for P1: " << P1 * empty << "\n"; 
    // std::cout << "Pauli multiplication by idenity for P1 the other way: " << empty * P1 << "\n"; 
    // P1 *= P2; 
    // std::cout << "Pauli multiplication using *= for first smaller than second gives: " << P1 << "\n";  
    // P1 = Vectorized_Pauli({1, 2, 3, 4, 10}, {2, 6, 9});
    // P2 *= P1; 
    // std::cout << "Pauli multiplication using *= for second smaller than first gives: " << P2 << "\n";
    // P2 = Vectorized_Pauli({1, 3, 5, 6, 7, 10}, {1, 2, 3, 4, 7, 9, 12}); 
    // P1 *= empty; 
    // empty *= P2; 
    // std::cout << "Pauli multiplication using *= for identity gives: " << P1 << "\n"; 
    // std::cout << "Pauli multiplication using *= for identity gives: " << empty << "\n"; 

    // std::cout << P1[1] << " " << P1[3] << " " << P1[6] << "\n"; 
    // for (size_t i : P1.support()) {
    //     std::cout << i << " "; 
    // }
    // std::cout << "\n";
    // for (size_t i : P2.support()) {
    //     std::cout << i << " "; 
    // }
    // std::cout << "\n";
    // std::cout << P1.weight() << " " << P2.weight() << "\n"; 
    // std::cout << P1.qubits() << " " << P2.qubits() << "\n"; 
    // std::cout << (P1 ^ 0) << "\n"; 
    // std::cout << (P1 ^ 1) << "\n"; 
}
</file>

<file path="Test_Pauli/Operator.cc">
#include "Operator.h"

// Cliffords 

Clifford::Clifford(const Clifford& C) {
    pauli = C.pauli.copy(); 
}

Clifford& Clifford::operator=(const Clifford& C) {
    pauli = C.pauli.copy(); 
    return *this; 
}


std::set<size_t> Clifford::support() const {
    return pauli.support(); 
}

size_t Clifford::weight() const {
    return pauli.weight(); 
}

size_t Clifford::qubits() const {
    return pauli.qubits(); 
}
bool operator<(const Clifford& C1, const Clifford& C2) {
    return C1.pauli < C2.pauli; 
}

std::ostream& operator<<(std::ostream& os, const Clifford& C) {
    os << " C |" << C.pauli; 
    return os; 
}

std::string fixed_length_string(const Clifford& C, size_t qubits) {
    std::string str = " C | "; 
    str += fixed_length_string(C.pauli, qubits); 
    return str; 
}

Clifford commute(const Clifford& C, const Reset& R) {
    Vectorized_Pauli P = C.pauli.copy(); 
    P.delete_term(R.qubits());
    return Clifford(P); 
}

void commute_inplace(Clifford& C, const Reset& R) {
    C.pauli.delete_term(R.qubits()); 
}

// Resets 
Reset::Reset(const Reset& R) {
    pauli = R.pauli.copy(); 
}
    
Reset& Reset::operator=(const Reset& R) {
    pauli = R.pauli.copy();
    return *this; 
}

Reset::Reset(size_t index) 
    : Reset("Z" + std::to_string(index)) {}


Reset::Reset(const std::string& pauli_string) 
    : Reset(Vectorized_Pauli(pauli_string)) {}


std::set<size_t> Reset::support() const {
    return pauli.support(); 
}

size_t Reset::weight() const {
    return pauli.weight(); 
}

size_t Reset::qubits() const {
    return pauli.qubits(); 
}

bool operator<(const Reset& R1, const Reset& R2) {
    return R1.pauli < R2.pauli; 
}

std::ostream& operator<<(std::ostream& os, const Reset& R) {
    os << " R | " << R.pauli; 
    return os; 
}

std::string fixed_length_string(const Reset& R, size_t qubits) {
    std::string str = " R | "; 
    str += fixed_length_string(R.pauli, qubits); 
    return str;     
}

Reset commute(const Reset& R1, const Reset& R) {
    return R1; 
}

void commute_inplace(Reset& R1, const Reset& R2) {
    return; 
}

Vectorized_Pauli commute(const Vectorized_Pauli& P, const Reset& R) {
    Vectorized_Pauli P1 = P.copy(); 
    P1.delete_term(R.qubits());
    return P1; 
}

void commute_inplace(Vectorized_Pauli& P, const Reset& R) {
    P.delete_term(R.qubits()); 
}

// Measures

Measure::Measure(const Measure& M) {
    pauli = M.pauli.copy(); 
    sign = M.sign; 
    probability = M.probability; 
}
    
Measure& Measure::operator=(const Measure& M) {
    pauli = M.pauli.copy(); 
    sign = M.sign; 
    probability = M.probability; 
    return *this; 
}

std::set<size_t> Measure::support() const {
    return pauli.support(); 
}

size_t Measure::weight() const {
    return pauli.weight(); 
}

size_t Measure::qubits() const {
    return pauli.qubits(); 
}

bool operator<(const Measure& M1, const Measure& M2) {
    return M1.pauli < M2.pauli; 
}

std::ostream& operator<<(std::ostream& os, const Measure& M) {
    os << (M.sign ? "-" : "+") << "M | " << M.pauli << " | " << M.probability; 
    return os; 
}

std::string fixed_length_string(const Measure& M, size_t qubits) {
    std::string str = (M.sign ? "-" : "+"); 
    str += "M | "; 
    str += fixed_length_string(M.pauli, qubits); 
    str += " | "; 
    str += std::to_string(M.probability); 
    return str;     
}

Measure commute(const Measure& M, const Reset& op) {
    throw std::invalid_argument("Cannot commute a measure forward through a reset"); 
} 

void commute_inplace(Measure& M, const Reset& R) {
    throw std::invalid_argument("Cannot commute a measure forward through a reset"); 
}

// Errors

Error::Error(const Error& E) {
    std::vector<Vectorized_Pauli> ps; 
    for (const Vectorized_Pauli& e: E.paulis) {
        ps.push_back(e.copy()); 
    }
    paulis = std::move(ps); 
    weights = E.weights; 
}

Error& Error::operator=(const Error& E) {
    if (this == &E) return *this; 
    std::vector<Vectorized_Pauli> ps; 
    for (const Vectorized_Pauli& P: E.paulis) {
        ps.push_back(P.copy()); 
    }
    paulis = std::move(ps); 
    weights = E.weights; 
    return *this; 
}

 Error::Error(const std::vector<Vectorized_Pauli>& Ps, const Weights& w) {
    if (Ps.size() != w.size()) throw std::invalid_argument("unmatched length"); 
    std::vector<Vectorized_Pauli> ps; 
    for (const Vectorized_Pauli& P: Ps) {
        ps.push_back(P.copy()); 
    }
    paulis = std::move(ps); 
    weights = w;
}

Error::Error(const Vectorized_Pauli& P) {
    paulis.push_back(Vectorized_Pauli()); 
    paulis.push_back(P.copy()); 
    weights = Weights({0.5, 0.5});
} 

Error::Error(const Reset& R) 
    : Error(R.pauli) {}


Error::Error(const Measure& M) 
    : Error(M.pauli) {}

// simplified model where every non-identity Vectorized Pauli errors occur with the same probability 
Error::Error(
    double probability, // probability that an error will occur (i.e. not just identity)
    const std::set<size_t>& support, 
    std::vector<char> pauli_terms
) {
    // Ensure 'I' is the first in the pauli terms 
    if (std::find(pauli_terms.begin(), pauli_terms.end(), 'I') != pauli_terms.begin()) {
        if (std::find(pauli_terms.begin(), pauli_terms.end(), 'I') != pauli_terms.end()) 
            pauli_terms.erase(std::find(pauli_terms.begin(), pauli_terms.end(), 'I')); 
        pauli_terms.insert(pauli_terms.begin(), 'I'); 
    }

    std::vector<Vectorized_Pauli> _paulis;
    std::vector<double> _weights;
    size_t w = static_cast<size_t>(std::pow(pauli_terms.size(), support.size())) - 1;

    _weights.push_back(1.0 - probability);
    for (size_t i = 0; i < w; ++i) {
        _weights.push_back(probability / w);
    }

    std::vector<std::vector<char>> combined_terms;
    cartesian_product(pauli_terms, support.size(), combined_terms);
        
    for (const std::vector<char>& term_seq : combined_terms) {
        std::vector<std::pair<char, size_t>> zipped;
        for (size_t i = 0; i < support.size(); ++i) {
            size_t index = *std::next(support.begin(), i); 
            std::pair<char, size_t> zip(term_seq[i], index); 
            zipped.push_back(zip);
        }
        _paulis.push_back(Vectorized_Pauli(zipped));
    }

    paulis = std::move(_paulis);
    weights = _weights; 
}

std::set<size_t> Error::support() const {
    std::set<size_t> res; 
    for (const Vectorized_Pauli& P : paulis) {
        std::set<size_t> supp = P.support(); 
        res.insert(supp.begin(), supp.end()); 
    }
    return res; 
}   

size_t Error::weight() const {
    return support().size(); 
}

size_t Error::qubits() const {
    const std::set<size_t>& supp = support(); 
    return supp.empty() ? 0 : *supp.rbegin(); // reverse begin posize_ts to the last and hence largest element
}

Error commute(const Error& E, const Clifford& C) {
    std::vector<Vectorized_Pauli> new_paulis;
    for (const Vectorized_Pauli& P : E.paulis) {
        new_paulis.push_back(commute(P, C.pauli)); 
    }
    return Error(new_paulis, E.weights);  
}

void commute_inplace(Error& E, const Clifford& C) {
    for (Vectorized_Pauli& P : E.paulis) {
        commute_inplace(P, C.pauli); 
    }
}

Vectorized_Pauli commute(const Vectorized_Pauli& P, const Clifford& C) {
    return commute(P, C.pauli); 
}

void commute_inplace(Vectorized_Pauli& P, const Clifford& C) {
    commute_inplace(P, C.pauli); 
}

Error commute(const Error& E1, const Error& E2) {
    return E1; 
}

void commute_inplace(Error& E1, const Error& E2) {
    return; 
}

Error commute(const Error& E, const Measure& M) {
    return E; 
}

void commute_inplace(Error& E, const Measure& M) {
    return; 
}

Error commute(const Error& E, const Reset& R) {
    std::vector<Vectorized_Pauli> new_paulis; 
    size_t q = R.qubits(); 
    for (const Vectorized_Pauli& P : E.paulis) {
        Vectorized_Pauli newP = P.copy(); 
        newP.delete_term(q);
        new_paulis.push_back(std::move(newP));
    }
    return Error(new_paulis, E.weights); 
}

void commute_inplace(Error& E, const Reset& R) {
    const size_t q = R.qubits(); 
    for (Vectorized_Pauli& P: E.paulis) {
        P.delete_term(q); 
    }
}

Error commute_back(const Error& E, const Clifford& C) {
    std::vector<Vectorized_Pauli> new_paulis;
    for (const Vectorized_Pauli& P : E.paulis) {
        new_paulis.push_back(commute(P, C.pauli)); 
    }
    return Error(new_paulis, E.weights);  
}

void commute_back_inplace(Error& E, const Clifford& C) {
    for (Vectorized_Pauli& P : E.paulis) {
        commute_back_inplace(P, C.pauli); 
    }
}

Error commute_back(const Error& E1, const Error& E2) {
    return E1; 
}

void commute_back_inplace(Error& E1, const Error& E2) {
    return; 
}

// an Error will only commute backwards with a measurement if the measurement does not measure the 
Error commute_back(const Error& E, const Measure& M) {
    throw std::invalid_argument("Cannot generally commute an error back through a measure"); 
}

void commute_back_inplace(Error& E, const Measure& M) {
    throw std::invalid_argument("Cannot generally commute an error back through a measure"); 
}

Error commute_back(const Error& E, const Reset& R) {
    throw std::invalid_argument("Cannot generally commute an error back through a reset"); 
}

void commute_back_inplace(Error& E, const Reset& R) {
    throw std::invalid_argument("Cannot generally commute an error back through a reset"); 
}

std::ostream& operator<<(std::ostream& os, const Error& E) {
    size_t q = E.qubits(); 
    for (size_t i = 0; i < E.paulis.size(); ++i) {
        os << " E | " << E.paulis[i] << " | " << std::to_string(E.weights.get(i));
        if (i != E.paulis.size() - 1) {
            os << "\n";
        }
    }
    return os; 
}

std::string fixed_length_string(const Error& E, size_t qubits) {
    std::string str = " E | "; 
    std::set<size_t> supp = E.support(); 
    size_t index = 1; 
    while (index <= qubits) {
        if (supp.find(index) != supp.end()) str += "E"; 
        else str += "."; 
        ++index; 
    }
    str += " | " + std::to_string(1 - E.weights.get(0)); 
    return str; 
}

bool operator<(const Operator& op1, const Operator& op2) {
    if (std::holds_alternative<Reset>(op1) && std::holds_alternative<Reset>(op2)) {
        return std::get<Reset>(op1) < std::get<Reset> (op2); 
    }
    else if (std::holds_alternative<Measure>(op1) && std::holds_alternative<Measure>(op2))
        return std::get<Measure>(op1) < std::get<Measure>(op2);
    else if (std::holds_alternative<Clifford>(op1) && std::holds_alternative<Clifford>(op2))
        return std::get<Clifford>(op1) < std::get<Clifford>(op2);
    else if (std::holds_alternative<Error>(op1) && std::holds_alternative<Error>(op2)) 
        throw::std::invalid_argument("Cannot compare two errors"); 
    else
        throw std::invalid_argument("Must compare two operators of the same type"); 
}

std::ostream& operator<<(std::ostream& os, const Operator& op) {
    if (std::holds_alternative<Reset>(op)) 
        os << std::get<Reset> (op); 
    else if (std::holds_alternative<Measure>(op))
        os << std::get<Measure>(op);
    else if (std::holds_alternative<Clifford>(op))
        os << std::get<Clifford>(op);
    else if (std::holds_alternative<Error>(op)) 
        os << std::get<Error>(op);
    return os; 
}

std::string fixed_length_string(const Operator& op, size_t qubits) {
    if (std::holds_alternative<Reset>(op)) 
        return fixed_length_string(std::get<Reset>(op), qubits); 
    else if (std::holds_alternative<Measure>(op))
        return fixed_length_string(std::get<Measure>(op), qubits);
    else if (std::holds_alternative<Clifford>(op)) {
        return fixed_length_string(std::get<Clifford>(op), qubits);
    }
    else if (std::holds_alternative<Error>(op)) 
        return fixed_length_string(std::get<Error>(op), qubits);
    throw std::logic_error("The Operator must be one of: Reset, Measure, Clifford, or Error"); 
}

// helper functions

// outputs the cartesian product of length lists
void cartesian_product(
    const std::vector<char>& lst,
    size_t n,
    std::vector<std::vector<char>>& result
) {
    size_t choices = lst.size();
    std::vector<size_t> indices(n, 0);
    std::vector<char> current(n, 'I');
    size_t pos = 0; 
    while (true) {
        while (indices[pos] <= choices - 1) {
            current[pos] = lst[indices[pos]]; 
            result.push_back(current);
            ++indices[pos];
        }
        --indices[pos]; // make it go back to choices - 1
        while (pos < n && indices[pos] == choices - 1) ++pos; 
        if (pos == n) break; 
        else {
            ++indices[pos]; 
            for (size_t i = 0; i < pos; ++i) {
                indices[i] = 0; 
                current[i] = 'I'; 
            }
            current[pos] = lst[indices[pos]]; 
            pos = 0; 
        }
    }
}
</file>

<file path="Test_Pauli/Operator.h">
#ifndef _STIM_OPERATOR
#define _STIM_OPERATOR

#include "Stim_Pauli.h"
#include "Weights.h"
#include <variant>

struct Clifford {
    Vectorized_Pauli pauli; 

    explicit Clifford(const Vectorized_Pauli& P) : pauli(P.copy()) {}
    Clifford(const Clifford&);
    Clifford& operator=(const Clifford&);
    Clifford& operator=(Clifford&&) = default; 
    Clifford() = default; 
    template <typename T>
    Clifford(T any)
        : Clifford(Vectorized_Pauli(any)) {}

    std::set<size_t> support() const; 
    size_t weight() const; 
    size_t qubits() const; 
    void permute(const Permutation& perm); 
} ; 

bool operator<(const Clifford& C1, const Clifford& C2); 

struct Reset {
    Vectorized_Pauli pauli; 

    explicit Reset(const Vectorized_Pauli& P) {
        if (P.weight() == 1) pauli = P.copy(); 
        else throw std::invalid_argument("Reset only valid for single-qubit Vectorized Pauli"); 
    }
    Reset(const Reset&);
    Reset& operator=(const Reset&);
    Reset& operator=(Reset&&) = default; 
    Reset() = default; 
    Reset(size_t index);
    Reset(const std::string& pauli_string); 

    std::set<size_t> support() const;
    size_t weight() const; 
    size_t qubits() const; 
    void permute(const Permutation& perm); 
} ;

bool operator<(const Reset& R1, const Reset& R2); 

struct Measure {
    Vectorized_Pauli pauli; 
    bool sign; 
    double probability; 

    Measure() = default; 
    Measure(const Measure&);
    Measure& operator=(const Measure&);
    Measure& operator=(Measure&&) = default; 
    explicit Measure(const Vectorized_Pauli& P, bool sgn=false, double prob=0) : 
            pauli(P.copy()), sign(sgn), probability((0 <= prob && prob <= 1) ? prob : throw std::invalid_argument("Probability must be between 0 and 1")) {}
    template <typename T>
    Measure(T any, bool sign=false, double probability=0) 
        : Measure(Vectorized_Pauli(any), sign, probability) {}
    

    std::set<size_t> support() const;
    size_t weight() const; 
    size_t qubits() const;  
    void permute(const Permutation& perm);
} ;

bool operator<(const Measure& M1, const Measure& M2); 

struct Error {
    std::vector<Vectorized_Pauli> paulis;
    Weights weights;  

    Error() = default; 
    Error(const Error& E);
    Error& operator=(const Error& E); 
    Error& operator=(Error&&) = default; 
    explicit Error(const std::vector<Vectorized_Pauli>& Ps, const Weights& w); 
    explicit Error(const Vectorized_Pauli& P);
    explicit Error(const Reset& R);
    explicit Error(const Measure& M);
    template <typename T>
    Error(T any) 
        : Error(Vectorized_Pauli(any)) {}
    

    // simplified model where every non-identity Pauli errors occur with the same probability 
    Error(
        double probability, // probability that an error will occur (i.e. not just identity)
        const std::set<size_t>& support, 
        std::vector<char> pauli_terms = {'I', 'X', 'Y', 'Z'}
    );

    std::set<size_t> support() const;
    size_t weight() const; 
    size_t qubits() const; 
    void permute(const Permutation& perm); 
} ;

// define Operator which is composed of Clifford, Reset, Measure, and Error
using Operator = std::variant<Clifford, Reset, Measure, Error>; 

Clifford commute(const Clifford& C, const Reset& R);
void commute_inplace(Clifford& C, const Reset& R); 
Vectorized_Pauli commute(const Vectorized_Pauli& P, const Clifford& C); 
void commute_inplace(Vectorized_Pauli& P, const Clifford& C); 
std::ostream& operator<<(std::ostream& os, const Clifford& C); 
std::string fixed_length_string(const Clifford& C, size_t qubits);

std::ostream& operator<<(std::ostream& os, const Reset& R); 
std::string fixed_length_string(const Reset& R, size_t qubits);
Reset commute(const Reset& R1, const Reset& R2); 
void commute_inplace(Reset& R1, const Reset& R2); 
Vectorized_Pauli commute(const Vectorized_Pauli& P, const Reset& R); 
void commute_inplace(Vectorized_Pauli& P, const Reset& R); 

Measure commute(const Measure& M, const Reset& op);
void commute_inplace(Measure& M, const Reset& R); 

std::ostream& operator<<(std::ostream& os, const Measure& M); 
std::string fixed_length_string(const Measure& M, size_t qubits);

Error commute(const Error& E, const Clifford& C);
void commute_inplace(Error& E, const Clifford& C); 
Error commute(const Error& E1, const Error& E2); 
void commute_inplace(Error& E1, const Error& E2); 
Error commute(const Error& E, const Measure& M); 
void commute_inplace(Error& E, const Measure& M); 
Error commute(const Error& E, const Reset& R); 
void commute_inplace(Error& E, const Reset& R); 
Error commute_back(const Error& E, const Clifford& C); 
void commute_back_inplace(Error& E, const Clifford& C); 
Error commute_back(const Error& E1, const Error& E2); 
void commute_back_inplace(Error& E1, const Error& E2); 
Error commute_back(const Error& E, const Measure& M); 
void commute_back_inplace(Error& E, const Measure& M); 
Error commute_back(const Error& E, const Reset& R); 
void commute_back_inplace(Error& E, const Reset& R); 
std::ostream& operator<<(std::ostream& os, const Error& E); 
std::string fixed_length_string(const Error& E, size_t qubits);  

bool operator<(const Operator& op1, const Operator& op2); 
std::ostream& operator<<(std::ostream& os, const Operator& op);
std::string fixed_length_string(const Operator& op, size_t qubits);  

// helper function 

void cartesian_product(
    const std::vector<char>& lst,
    size_t n,
    std::vector<std::vector<char>>& result
); 

#endif
</file>

<file path="Test_Pauli/SampleLoop.cc">
#include "SampleLoop.h"
#include <chrono>

BitString BitString::operator^(const BitString& other) const {
    if (bs.size() != other.bs.size()) [[unlikely]] {
        throw std::runtime_error("Vectors must have the same size");
    }
    BitString result; 
    result.num_bits = num_bits; 
    result.bs.resize(bs.size()); 
    
    const uint64_t* lhs = bs.data();
    const uint64_t* rhs = other.bs.data();
    uint64_t* res = result.bs.data();

    for (size_t i = 0; i < bs.size(); ++i) {
        res[i] = lhs[i] ^ rhs[i];
    }

    return result;
}

BitString& BitString::operator^=(const BitString& other) {
    size_t max_words = std::max(bs.size(), other.bs.size());
    if (max_words > 100000) std::cout << max_words << " " << bs.size() << "\n"; 
    bs.resize(max_words, 0);  // pad with 0s if *this is shorter

    const uint64_t* rhs = other.bs.data();
    uint64_t* lhs = bs.data();

    size_t min_words = std::min(bs.size(), other.bs.size());
    for (size_t i = 0; i < min_words; ++i) {
        lhs[i] ^= rhs[i];
    }

    num_bits = std::max(num_bits, other.num_bits);
    return *this;
}

std::ostream& operator<<(std::ostream& os, const BitString& bs) {
    for (size_t i = 0; i < bs.num_bits; ++i) {
        os << (bs[i] ? '1' : '0'); 
    }
    return os;
}

bool BitString::operator[](size_t i) const {
    size_t w = i / BITS_PER_INT;
    size_t b = i % BITS_PER_INT;
    return (bs[w] >> b) & 1ULL; // (unsigned long long) 1
}

void BitString::set(size_t i, bool value) {
    size_t w = i / BITS_PER_INT;
    size_t b = i % BITS_PER_INT; 
    if (w >= bs.size()) {
        std::cerr << "ERROR: BitString::set index out of bounds. i=" << i
              << ", w=" << w << ", bs.size()=" << bs.size() << std::endl;
        std::exit(1);
    }
    if (value) {
        bs[w] |= (1ULL << b);
    }
    else {
        bs[w] &= ~(1ULL << b);
    }
}

BitString BitString::operator+(const BitString& other) const {
    BitString result(num_bits + other.num_bits);

    const size_t w = num_bits / BITS_PER_INT;
    const size_t b = num_bits % BITS_PER_INT;

    std::copy(bs.begin(), bs.end(), result.bs.begin());

    if (b == 0) {
        std::copy(other.bs.begin(), other.bs.end(), result.bs.begin() + w);
    } else {
        const size_t shift = BITS_PER_INT - b;;
        uint64_t carry = 0;

        for (size_t i = 0; i < other.bs.size(); ++i) {
            uint64_t current = other.bs[i];
            result.bs[w + i]     |= current << b;
            carry = current >> shift;
            result.bs[w + i + 1] |= carry;
        }
    }
    return result;
}

BitString& BitString::operator+=(const BitString& other) {
    const size_t old_num_bits = num_bits;
    const size_t new_num_bits = num_bits + other.num_bits;

    bs.resize((new_num_bits + BITS_PER_INT - 1) / BITS_PER_INT, 0);  
    num_bits = new_num_bits;

    const size_t w = old_num_bits / BITS_PER_INT;
    const size_t b = old_num_bits % BITS_PER_INT;

    if (b == 0) {
        std::copy(other.bs.begin(), other.bs.end(), bs.begin() + w);
    } else {
        const size_t shift = BITS_PER_INT - b;
        uint64_t carry = 0;

        for (size_t i = 0; i < other.bs.size(); ++i) {
            uint64_t current = other.bs[i];
            bs[w + i]     |= current << b;
            carry = current >> shift;
            bs[w + i + 1] |= carry;
        }
    }

    return *this;
}


bool BitString::operator==(const BitString& other) const {
    return num_bits == other.num_bits && bs == other.bs;
}

SampleLoop::SampleLoop(const Loop& L) {
    repeat = L.repeat;
    size_t index = 0; 
    const std::vector<Operator>& ops = L.reduced_circ.operators;
    while (index < ops.size() && std::holds_alternative<Reset>(ops[index])) {
        ++index; 
    }
    rqubits = resets_list(L.reduced_circ, 0, index); 
    while (index < ops.size() && std::holds_alternative<Error>(ops[index])) {
        errors.push_back(std::get<Error>(ops[index])); 
        ++index; 
    }
    size_t start = index; 
    while (index < ops.size() && std::holds_alternative<Clifford>(ops[index])) {
        ++index; 
    }
    map = gates_block(L.reduced_circ, start, index - 1); 
    while (index < ops.size() && std::holds_alternative<Measure>(ops[index])) {
        const Measure& M = std::get<Measure>(ops[index]); 
        measures.push_back(M); 
        mflips.push_back(M.probability); 
        ++index; 
    }
    while (index < ops.size()) {
        merrors.push_back(std::get<Error>(ops[index])); 
        ++index; 
    }
}

SampleLoop::SampleLoop(const SampleLoop& sl) {
    repeat = sl.repeat; 
    errors = sl.errors; 
    rqubits = sl.rqubits; 
    measures = sl.measures; 
    merrors = sl.merrors; 
    mflips = sl.mflips; 
    for (const auto& pr: sl.map) {
        map.push_back({pr.first.copy(), pr.second}); 
    }
}

SampleLoop& SampleLoop::operator=(const SampleLoop& sl) {
    repeat = sl.repeat; 
    errors = sl.errors; 
    rqubits = sl.rqubits; 
    measures = sl.measures; 
    merrors = sl.merrors; 
    mflips = sl.mflips; 
    for (auto& pr: map) {
        pr.first.free(); 
    }
    map.clear(); 
    for (const auto& pr: sl.map) {
        map.push_back({pr.first.copy(), pr.second}); 
    }
    return *this; 
}

void map_sampled_error_resets(const std::set<size_t>& rqubits, Vectorized_Pauli& P) {
    for (size_t i : rqubits) {
        P.delete_term(i); 
    }
}

void map_sampled_error_gates(
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& map, 
    const std::vector<double>& mflips, 
    Vectorized_Pauli& P, BitString& bs
) {
    static std::mt19937 gen(std::random_device{}()); 
    static std::uniform_real_distribution<double> dist(0, 1);
    BitString flips = BitString(map[0].second.num_bits); 
    // this require you knowing in advance the maximum qubit
    static Vectorized_Pauli _P; 
    // Vectorized_Pauli _P; 
    const int bits = bs.BITS_PER_INT; 
    // for (size_t basis: P.basis_rep()) {
    //     const std::pair<Vectorized_Pauli, BitString>& transformed = map[basis]; 
    //     _P *= transformed.first; 
    //     flips ^= transformed.second;
    // }
    uint64_t* xptr = reinterpret_cast<uint64_t*>(P.xs); 
    uint64_t* zptr = reinterpret_cast<uint64_t*>(P.zs); 
    for (size_t i = 0; i < P.num_words * 4; ++i) {
        uint64_t* xword = xptr + i;
        uint64_t* zword = zptr + i;  
        while (*xword) {
            int bit = __builtin_ctzll(*xword); 
            const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit]; 
            _P *= transformed.first; 
            flips ^= transformed.second;
            *xword &= *xword - 1; 
        }
        while (*zword) {
            int bit = __builtin_ctzll(*zword); 
            const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit + 1]; 
            _P *= transformed.first;  
            flips ^= transformed.second;
            *zword &= *zword - 1;
        }
    }
//     uint64_t* xptr = reinterpret_cast<uint64_t*>(P.xs); 
//     uint64_t* zptr = reinterpret_cast<uint64_t*>(P.zs); 
//     for (size_t i = 0; i < P.num_words * 4; ++i) {
//         uint64_t xword = xptr[i];
//         uint64_t zword = zptr[i]; 
//         while (xword) {
//             int bit = __builtin_ctzll(xword); 
//             const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit]; 
//             _P *= transformed.first; 
//             flips ^= transformed.second;
//             xword &= xword - 1; 
//         }
//         while (zword) {
//             int bit = __builtin_ctzll(zword); 
//             const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit + 1]; 
//             _P *= transformed.first; 
//             flips ^= transformed.second;
//             zword &= zword - 1;
//         }
//     }
    for (size_t i = 0; i < mflips.size(); ++i) {
        if (dist(gen) < mflips[i]) {
            flips.bs[i / bits] ^= (1ULL << (i % bits));
        }
    } 
    std::swap(_P, P); 
    // P = std::move(_P); 
    bs += flips; 
}

// returns the list of qubits to set to zero give [start, end) are all resets 
std::set<size_t> resets_list(
    const Circuit& circ, 
    std::optional<size_t> start,
    std::optional<size_t> end
) {
    size_t first = circ.operators.size();
    size_t last = 0; 
    std::set<size_t> resets; 
    if (start) first = std::max((size_t)0, *start); 
    else {
        for (size_t i = 0; i < circ.operators.size(); ++i) {
            if (std::holds_alternative<Reset>(circ.operators[i])) {
                first = i; 
                break; 
            }
        }
    }
    if (end) last = std::max((size_t)0, *end); 
    else {
        for (size_t i = circ.operators.size(); i > 0; --i) {
            if (std::holds_alternative<Reset>(circ.operators[i - 1])) {
                last = i; 
                break; 
            }
        }
    }
    for (size_t i = first; i < last; ++i) {
        resets.insert(std::get<Reset>(circ[i]).qubits()); 
    }
    return resets; 
}

std::vector<std::pair<Vectorized_Pauli, BitString>> gates_block(
    const Circuit& circ, 
    std::optional<size_t> start, 
    std::optional<size_t> end
) {
    const size_t n = circ.operators.size();
    size_t cfirst = n;
    size_t clast = n; 
    size_t mlast = n; 
    std::vector<std::pair<Vectorized_Pauli, BitString>> gates; 
    if (start) cfirst = *start; 
    else {
        for (size_t i = 0; i < n; ++i) {
            if (std::holds_alternative<Clifford>(circ.operators[i])) {
                cfirst = i; 
                break; 
            }
        }
    }
    if (end) clast = *end; 
    else {
        for (size_t i = n; i > 0; --i) {
            if (std::holds_alternative<Clifford>(circ.operators[i - 1])) {
                clast = i - 1; 
                break; 
            }
        }
    }
    for (size_t i = n; i > 0; --i) {
        if (std::holds_alternative<Measure>(circ.operators[i - 1])) {
            mlast = i - 1; 
            break; 
        }
    }
    if (mlast == n) mlast = clast; 
    const size_t qubits = circ.qubits(); 
    for (size_t q = 1; q <= qubits; ++q) {
        Vectorized_Pauli X = Vectorized_Pauli("X" + std::to_string(q));
        Vectorized_Pauli Z = Vectorized_Pauli("Z" + std::to_string(q));
        for (size_t i = cfirst; i <= clast; ++i) {
            commute_inplace(X, std::get<Clifford>(circ.operators[i])); 
            commute_inplace(Z, std::get<Clifford>(circ.operators[i])); 
        }
        BitString Xflip = BitString(mlast - clast); 
        BitString Zflip = BitString(mlast - clast); 
        // goes through all the measures 
        // the flips correspond to the measurement outputs AFTER the basis pauli has gone through all the gates 
        for (size_t i = clast + 1; i <= mlast; ++i) {
            const Measure& M = std::get<Measure>(circ[i]);
            Xflip.set(i - clast - 1, ((X % M.pauli) != M.sign)); 
            Zflip.set(i - clast - 1, ((Z % M.pauli) != M.sign));
        }
        gates.push_back(std::pair{std::move(X), Xflip}); 
        gates.push_back(std::pair{std::move(Z), Zflip}); 
    }
    return gates;
}

void sample(const std::vector<Error>& errors, Vectorized_Pauli& P) {
    static std::mt19937 gen(std::random_device{}()); 
    for (const Error& E: errors) {
        std::discrete_distribution<> dist(E.weights.begin(), E.weights.end()); 
        const Vectorized_Pauli& choice = E.paulis[dist(gen)]; 
        P *= choice; 
    }
}

std::vector<std::pair<BitString, int64_t>> measure(int shots, const std::vector<SampleLoop>& lst) {
    std::unordered_map<BitString, int64_t> samples; 
    std::vector<Error> first_reset_errors; 
    for (size_t q = 1; q <= lst.begin()->map.size() / 2; ++q) {
        if (lst.begin()->rqubits.find(q) == lst.begin()->rqubits.end())
            first_reset_errors.emplace_back(Vectorized_Pauli("Z" + std::to_string(q)));
    } 
    for (int i = 0; i < shots; ++i) {
        if (i % 1000 == 0) std::cout << i << "\n"; 
        Vectorized_Pauli P; 
        sample(first_reset_errors, P); 
        BitString res = BitString(0); 
        for (const SampleLoop& sloop : lst) {
            for (int r = 0; r < sloop.repeat; ++r) {
                map_sampled_error_resets(sloop.rqubits, P); 
                sample(sloop.errors, P); 
                map_sampled_error_gates(sloop.map, sloop.mflips, P, res); 
                sample(sloop.merrors, P); 
            }
        } 
        ++(samples[res]); 
    }
    std::vector<std::pair<BitString, int64_t>> sorted(samples.begin(), samples.end()); 
    std::sort(sorted.begin(), sorted.end(), 
        [](const std::pair<BitString, int64_t>& a, const std::pair<BitString, int64_t>& b) { return a.second < b.second; }); 
    return sorted; 
}

void bulk_reset_map(const std::set<size_t>& rqubits, std::vector<Vectorized_Pauli>& paulis) {
    for (size_t i : rqubits) {
        for (Vectorized_Pauli& P: paulis)
            P.delete_term(i); 
    }
}

void bulk_gate_map(
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& map, 
    const std::vector<double>& mflips, 
    std::vector<Vectorized_Pauli>& paulis,
    std::vector<BitString>& bs
) {
    static std::mt19937 gen(std::random_device{}()); 
    static std::uniform_real_distribution<double> dist(0.0, 1.0);
    static Vectorized_Pauli _P; 
    const int bits = bs[0].BITS_PER_INT; 
    for (size_t j = 0; j < paulis.size(); ++j) {
        Vectorized_Pauli& P = paulis[j]; 
        BitString flips = BitString(map[0].second.num_bits); 
        uint64_t* xptr = reinterpret_cast<uint64_t*>(P.xs); 
        uint64_t* zptr = reinterpret_cast<uint64_t*>(P.zs); 
        uint64_t* end = xptr + P.num_words * 4; 
        size_t index = 0; 
        while (xptr < end) {
            while (*xptr) {
                int bit = __builtin_ctzll(*xptr); 
                const std::pair<Vectorized_Pauli, BitString>& transformed = map[index + 2 * bit]; 
                // std::cout << transformed.first << std::endl; 
                // std::cout << transformed.second << std::endl; 
                _P *= transformed.first; 
                flips ^= transformed.second;
                *xptr &= *xptr - 1; 
            }
            while (*zptr) {
                int bit = __builtin_ctzll(*zptr); 
                const std::pair<Vectorized_Pauli, BitString>& transformed = map[index + 2 * bit + 1];
                // std::cout << transformed.first << std::endl; 
                // std::cout << transformed.second << std::endl;  
                _P *= transformed.first;  
                flips ^= transformed.second;
                *zptr &= *zptr - 1;
            }
            ++xptr; 
            ++zptr;
            index += 128; 
        }
        // for (size_t i = 0; i < P.num_words * 4; ++i) {
        //     uint64_t* xword = xptr + i;
        //     uint64_t* zword = zptr + i;  
        //     while (*xword) {
        //         int bit = __builtin_ctzll(*xword); 
        //         const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit]; 
        //         _P *= transformed.first; 
        //         flips ^= transformed.second;
        //         *xword &= *xword - 1; 
        //     }
        //     while (*zword) {
        //         int bit = __builtin_ctzll(*zword); 
        //         const std::pair<Vectorized_Pauli, BitString>& transformed = map[128 * i + 2 * bit + 1]; 
        //         _P *= transformed.first;  
        //         flips ^= transformed.second;
        //         *zword &= *zword - 1;
        //     }
        // }
        for (size_t i = 0; i < mflips.size(); ++i) {
            if (dist(gen) < mflips[i]) {
                flips.bs[i / bits] ^= (1ULL << (i % bits));
            }
        } 
        swap(_P, P); 
        bs[j] += flips; 
    }
}

void bulk_sample(const std::vector<Error>& errors, std::vector<Vectorized_Pauli>& P) {
    static std::mt19937_64 rng(std::random_device{}()); 
    size_t index; 
    float prob; 
    for (const Error& E: errors) {
        index = 0; 
        prob = 1 - E.weights.get(0); 
        std::geometric_distribution<size_t> dist(prob); 
        while (true) {
            index = index + dist(rng); 
            if (index >= P.size()) break; 
            else {
                size_t p; 
                if (E.paulis.size() <= 2) p = 1; 
                else p = 1 + (rng() % (E.paulis.size() - 2)); 
                P[index] *= E.paulis[p]; 
            }
        }
    }
}

std::vector<std::pair<BitString, int64_t>> bulk_measure(int shots, const std::vector<SampleLoop>& lst) {
    std::unordered_map<BitString, int64_t> samples; 
    std::vector<Error> first_reset_errors; 
    for (size_t q = 1; q <= lst.begin()->map.size() / 2; ++q) {
        if (lst.begin()->rqubits.find(q) == lst.begin()->rqubits.end())
            first_reset_errors.emplace_back(Vectorized_Pauli("Z" + std::to_string(q)));
    } 
    for (int i = 0; i < shots/1000; ++i) {
        std::cout << i + 1 << "th 1000 samples \n"; 
        std::vector<Vectorized_Pauli> P;
        for (int j = 0; j < 1000; ++j) P.emplace_back(Vectorized_Pauli());  
        bulk_sample(first_reset_errors, P); 
        std::vector<BitString> res(1000, BitString(0)); 
        for (const SampleLoop& sloop : lst) {
            for (int r = 0; r < sloop.repeat; ++r) {
                bulk_reset_map(sloop.rqubits, P); 
                bulk_sample(sloop.errors, P);  
                bulk_gate_map(sloop.map, sloop.mflips, P, res); 
                bulk_sample(sloop.merrors, P); 
            }
        } 
        for (int j = 0; j < 1000; ++j) ++samples[res[j]]; 
    }
    std::vector<std::pair<BitString, int64_t>> sorted(samples.begin(), samples.end()); 
    std::sort(sorted.begin(), sorted.end(), 
        [](const std::pair<BitString, int64_t>& a, const std::pair<BitString, int64_t>& b) { return a.second < b.second; }); 
    return sorted; 
}
</file>

<file path="Test_Pauli/SampleLoop.h">
#ifndef _STIM_SAMPLELOOP
#define _STIM_SAMPLELOOP

#include "Loop.h"
#include "Circuit.h"
#include <unordered_map>

struct BitString {
    std::vector<uint64_t> bs; 
    size_t num_bits; 

    static constexpr size_t BITS_PER_INT = 64;

    BitString(size_t n) : num_bits(n) {
        bs.resize((n + BITS_PER_INT - 1) / BITS_PER_INT, 0);
    }

    BitString() = default;
    BitString(const BitString&) = default; 
    BitString& operator=(const BitString&) = default; 
    BitString(const std::vector<uint64_t>& _bs) : bs(_bs) {} 

    BitString operator^(const BitString& BS) const; 
    BitString& operator^=(const BitString& other); 
    bool operator[](size_t i) const; 
    BitString operator+(const BitString& b) const; 
    BitString& operator+=(const BitString& other); 
    bool operator==(const BitString& other) const; 
    void set(size_t i, bool value); 
}; 

std::ostream& operator<<(std::ostream& os, const BitString& loop); 

namespace std {
    template<>
    struct hash<BitString> {
        std::size_t operator()(const BitString& b) const {
            std::size_t h = std::hash<size_t>{}(b.num_bits);
            for (uint64_t word : b.bs) {
                h ^= std::hash<uint64_t>{}(word) + 0x9e3779b9 + (h << 6) + (h >> 2);
            }
            return h;
        }
    };
}

struct SampleLoop {
    int repeat; 
    std::set<size_t> rqubits; 
    std::vector<Error> errors; 
    std::vector<std::pair<Vectorized_Pauli, BitString>> map; 
    std::vector<Measure> measures; 
    std::vector<Error> merrors; 
    std::vector<double> mflips; 

    SampleLoop() = default; 
    SampleLoop(const SampleLoop& sl); 
    SampleLoop& operator=(const SampleLoop& sl); 
    SampleLoop(const Loop& L); 
}; 

std::set<size_t> resets_list(
    const Circuit& circ, 
    std::optional<size_t> start,
    std::optional<size_t> end
); 
std::vector<std::pair<Vectorized_Pauli, BitString>> gates_block(
    const Circuit& circ, 
    std::optional<size_t> start=std::nullopt, 
    std::optional<size_t> end=std::nullopt
); 
void sample(const std::vector<Error>& errors, Vectorized_Pauli& P); 
void map_sampled_error_resets(const std::set<size_t>& rqubits, Vectorized_Pauli& P); 
void map_sampled_error_gates(
    const std::vector<std::pair<Vectorized_Pauli, BitString>>& map, 
    const std::vector<double>& mflips,
    Vectorized_Pauli& P, 
    BitString& bs
); 
std::vector<std::pair<BitString, int64_t>> measure(int shots, const std::vector<SampleLoop>& lst); 
std::vector<std::pair<BitString, int64_t>> bulk_measure(int shots, const std::vector<SampleLoop>& lst);
void printSampledLoop(const Loop& loop);
void printCircuitwithLoop(const Circuit& circ1, const Loop& loop, const Circuit& circ2); 

#endif
</file>

<file path="Test_Pauli/Stim_Pauli.cc">
#include "Stim_Pauli.h"


Vectorized_Pauli::Vectorized_Pauli(size_t n) {
    num_words = (n + 255) / 256;
    if (num_words == 0) {
        xs = nullptr;
        zs = nullptr;
        return;
    }
    size_t byte = num_words * sizeof(__m256i);
    xs = static_cast<__m256i*>(_mm_malloc(byte, alignment));
    zs = static_cast<__m256i*>(_mm_malloc(byte, alignment));

    if (!xs || !zs) throw std::bad_alloc();
    std::memset(xs, 0, byte);
    std::memset(zs, 0, byte);
}

Vectorized_Pauli::Vectorized_Pauli(Vectorized_Pauli&& other) noexcept
    : num_words(other.num_words), xs(other.xs), zs(other.zs) {
    other.num_words = 0;
    other.xs = nullptr;
    other.zs = nullptr;
}

Vectorized_Pauli::Vectorized_Pauli(const std::set<size_t> &xval, const std::set<size_t> &zval) {
    int max; // maximum qubit
    if (xval.empty() && zval.empty()) max = 0; 
    else if (xval.empty()) max = *zval.rbegin();
    else if (zval.empty()) max = *xval.rbegin(); 
    else max = std::max(*xval.rbegin(), *zval.rbegin()); 
    num_words = (max + 255) / 256; 
    if (max == 0) {
        xs = nullptr; 
        zs = nullptr; 
        return; 
    }
    xs = malloc_aligned_padded_zeroed(max); 
    zs = malloc_aligned_padded_zeroed(max); 
    // the qubits are 1 indexed but the pauli strings are 0 indexed 
    // so it is necessary to decrement the number passed in to match the indexing   
    for (size_t x: xval) {
        --x; 
        size_t index = x / 256; 
        size_t bit = x % 256; 
        size_t lane = bit / 64; // each __m256i is like a "vector" with 4 64-bit ULL 
        size_t bit_in_lane = bit % 64; 

        uint64_t* ptr = reinterpret_cast<uint64_t*>(&xs[index]); 
        ptr[lane] |= 1ULL << bit_in_lane; 
    }
    for (size_t z: zval) {
        --z; 
        size_t index = z / 256; 
        size_t bit = z % 256; 
        int lane = bit / 64; 
        int bit_in_lane = bit % 64; 

        uint64_t* ptr = reinterpret_cast<uint64_t*>(&zs[index]); 
        ptr[lane] |= 1ULL << bit_in_lane; 
    }
}

Vectorized_Pauli::Vectorized_Pauli(const std::string& vectorized_pauli_string) {
    std::set<size_t> x, z; 
    std::vector<std::string> terms = split_terms(vectorized_pauli_string);
    for (const std::string& term : terms) {
        std::pair<std::string, size_t> pr = split_pauli_term(term);
        std::transform(pr.first.begin(), pr.first.end(), pr.first.begin(), ::toupper);
        if (pr.first == "X") {
            binary_XOR(x, pr.second); 
        } else if (pr.first == "Z") {
            binary_XOR(z, pr.second); 
        } else if (pr.first == "Y") {
            binary_XOR(x, pr.second); 
            binary_XOR(z, pr.second);
        }
    }
    int max; // maximum qubit
    if (x.empty() && z.empty()) max = 0; 
    else if (x.empty()) max = *z.rbegin();
    else if (z.empty()) max = *x.rbegin(); 
    else max = std::max(*x.rbegin(), *z.rbegin()); 
    num_words = (max + 255) / 256; 
    xs = malloc_aligned_padded_zeroed(max); 
    zs = malloc_aligned_padded_zeroed(max); 
    for (size_t _x: x) {
        --_x; 
        size_t index = _x / 256; 
        size_t bit = _x % 256; 
        size_t lane = bit / 64; // each __m256i is like a "vector" with 4 64-bit ULL 
        size_t bit_in_lane = bit % 64; 

        uint64_t* ptr = reinterpret_cast<uint64_t*>(xs + index); 
        ptr[lane] |= 1ULL << bit_in_lane; 
    }
    for (size_t _z: z) {
        --_z; 
        size_t index = _z / 256; 
        size_t bit = _z % 256; 
        int lane = bit / 64; 
        int bit_in_lane = bit % 64; 

        uint64_t* ptr = reinterpret_cast<uint64_t*>(zs + index); 
        ptr[lane] |= 1ULL << bit_in_lane; 
    }
}

Vectorized_Pauli::Vectorized_Pauli(const std::vector<std::pair<char, size_t>>& vec) {
    std::set<size_t> x, z;
    for (std::pair<char, size_t> pr : vec) {
        if (std::toupper(pr.first) == 'X') {
            binary_XOR(x, pr.second); 
        } else if (std::toupper(pr.first) == 'Z') {
            binary_XOR(z, pr.second); 
        } else if (std::toupper(pr.first) == 'Y') {
            binary_XOR(x, pr.second);
            binary_XOR(z, pr.second); 
        }
    }
    int max; // maximum qubit
    if (x.empty() && z.empty()) max = 0; 
    else if (x.empty()) max = *z.rbegin();
    else if (z.empty()) max = *x.rbegin(); 
    else max = std::max(*x.rbegin(), *z.rbegin()); 
    num_words = (max + 255) / 256; 
    if (max == 0) {
        xs = nullptr; 
        zs = nullptr; 
        return; 
    }
    xs = malloc_aligned_padded_zeroed(max); 
    zs = malloc_aligned_padded_zeroed(max); 
    // the qubits are 1 indexed but the pauli strings are 0 indexed 
    // so it is necessary to decrement the number passed in to match the indexing
    for (size_t _x: x) {
        --_x; 
        size_t index = _x / 256; 
        size_t bit = _x % 256; 
        size_t lane = bit / 64; // each __m256i is like a "vector" with 4 64-bit ULL 
        size_t bit_in_lane = bit % 64; 

        uint64_t* ptr = reinterpret_cast<uint64_t*>(xs + index); 
        ptr[lane] |= 1ULL << bit_in_lane; 
    }
    for (size_t _z: z) {
        --_z; 
        size_t index = _z / 256; 
        size_t bit = _z % 256; 
        int lane = bit / 64; 
        int bit_in_lane = bit % 64; 

        uint64_t* ptr = reinterpret_cast<uint64_t*>(zs + index); 
        ptr[lane] |= 1ULL << bit_in_lane; 
    }
}

void Vectorized_Pauli::swap(Vectorized_Pauli& other) noexcept {
    std::swap(xs, other.xs);
    std::swap(zs, other.zs);
    std::swap(num_words, other.num_words);
}

Vectorized_Pauli& Vectorized_Pauli::operator=(Vectorized_Pauli&& other) noexcept {
    if (this != &other) {
        free();
        num_words = other.num_words;
        xs = other.xs;
        zs = other.zs;
        other.num_words = 0;
        other.xs = nullptr;
        other.zs = nullptr;
    }
    return *this;
}

bool Vectorized_Pauli::operator==(const Vectorized_Pauli& other) const {
    if (num_words != other.num_words) return false; 

    for (size_t i = 0; i < num_words; ++i) {
        __m256i cmp_xs = _mm256_xor_si256(xs[i], other.xs[i]);
        __m256i cmp_zs = _mm256_xor_si256(zs[i], other.zs[i]);

        if (!_mm256_testz_si256(cmp_xs, cmp_xs) || !_mm256_testz_si256(cmp_zs, cmp_zs)) return false;
    }
    return true;
}

Vectorized_Pauli operator*(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2) {
    const size_t max = std::max(P1.num_words, P2.num_words); // maximum num_words
    const size_t min = std::min(P1.num_words, P2.num_words); 
    if (max == 0) return Vectorized_Pauli(); 
    Vectorized_Pauli res = Vectorized_Pauli(max * 256); 
    for (size_t i = 0; i < min; ++i) {
        res.xs[i] = _mm256_xor_si256(P1.xs[i], P2.xs[i]);
        res.zs[i] = _mm256_xor_si256(P1.zs[i], P2.zs[i]);  
    }
    // copy the rest of pauli string from the larger one
    if (P1.num_words > P2.num_words) {
        // dest, src, how much to copy
        std::memcpy(res.xs + min, P1.xs + min, (max - min) * sizeof(__m256i)); 
        std::memcpy(res.zs + min, P1.zs + min, (max - min) * sizeof(__m256i)); 
    } 
    else if (P1.num_words < P2.num_words) {
        std::memcpy(res.xs + min, P2.xs + min, (max - min) * sizeof(__m256i)); 
        std::memcpy(res.zs + min, P2.zs + min, (max - min) * sizeof(__m256i)); 
    }
    return res; 
}

Vectorized_Pauli& Vectorized_Pauli::operator*=(const Vectorized_Pauli& P) {
    if (num_words < P.num_words) {
        if (P.num_words > 1000) {
            std::cout << P.num_words << std::endl; 
            std::cout << P << std::endl; 
        }
        // std::cout << *this << " and " << P << std::endl; 
        // std::cout << num_words << " and " << P.num_words << std::endl; 
        Vectorized_Pauli res = Vectorized_Pauli(P.num_words * 256); 
        for (size_t i = 0; i < num_words; ++i) {
            res.xs[i] = _mm256_xor_si256(xs[i], P.xs[i]); 
            res.zs[i] = _mm256_xor_si256(zs[i], P.zs[i]);
        } 
        std::memcpy(res.xs + num_words, P.xs + num_words, (P.num_words - num_words) * sizeof(__m256i)); 
        std::memcpy(res.zs + num_words, P.zs + num_words, (P.num_words - num_words) * sizeof(__m256i)); 
        *this = std::move(res); 
        return *this; 
    } else {
        for (size_t i = 0; i < P.num_words; ++i) {
            xs[i] = _mm256_xor_si256(xs[i], P.xs[i]);
            zs[i] = _mm256_xor_si256(zs[i], P.zs[i]);  
        }
        return *this; 
    } 
}

bool operator<(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2) {
    if (P2.isI()) return false; 
    else if (P1.isI()) return true; 
    size_t i1 = std::min(first_nonzero_bit(P1.xs, P1.num_words), first_nonzero_bit(P1.zs, P1.num_words)); 
    size_t i2 = std::min(first_nonzero_bit(P2.xs, P2.num_words), first_nonzero_bit(P2.zs, P2.num_words)); 
    return (i1 > i2) || ((i1 == i2) && (P1[i1] < P2[i1])); 
}

// the qubits are 1 indexed but the pauli strings are 0 indexed 
// so it is necessary to decrement the number passed in to match the indexing
char Vectorized_Pauli::operator[](size_t index) const {
    --index;
    size_t i = index / 256; 
    size_t bit = index % 256; 
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    uint64_t* xptr = reinterpret_cast<uint64_t*>(xs + i); 
    uint64_t* zptr = reinterpret_cast<uint64_t*>(zs + i); 
    if (xptr[lane] & (1ULL << bit_in_lane) && zptr[lane] & (1ULL << bit_in_lane)) return 'Y'; 
    else if (xptr[lane] & (1ULL << bit_in_lane)) return 'X'; 
    else if (zptr[lane] & (1ULL << bit_in_lane)) return 'Z'; 
    else return 'I'; 
}

// calculated by (x_1 * z_2 + x_2 * z_1) (mod 2)
bool operator%(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2) { // Symplectic inner product
    // you only need (can) go up to the smaller word because it is always going to be 0 afterwards
    size_t min = std::min(P1.num_words, P2.num_words); 
    int parity = 0; 
    for (size_t i = 0; i < min; ++i) {
        __m256i t1 = _mm256_and_si256(P1.xs[i], P2.zs[i]); 
        __m256i t2 = _mm256_and_si256(P2.xs[i], P1.zs[i]); 
        __m256i added = _mm256_xor_si256(t1, t2); 

        alignas(32) uint64_t vec[4]; 
        _mm256_store_si256(reinterpret_cast<__m256i*>(vec), added);
        parity += (__builtin_popcountll(vec[0]) + __builtin_popcountll(vec[1]) + __builtin_popcountll(vec[2]) + __builtin_popcountll(vec[3])) % 2; 
    }
    return parity;  
}

Vectorized_Pauli operator^(const Vectorized_Pauli& P, bool b) {
    return b ? P.copy() : Vectorized_Pauli(); 
}

void swap(Vectorized_Pauli& a, Vectorized_Pauli& b) noexcept {
    a.swap(b);
}

// the qubits are 1 indexed but the pauli strings are 0 indexed 
// so it is necessary to decrement the number passed in to match the indexing
void Vectorized_Pauli::set_index(char c, size_t index) {
    --index; 
    size_t i = index / 256; 
    size_t bit = index % 256; 
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    if (index > num_words) throw std::out_of_range("Index for pauli string to set is out of bounds"); 
    uint64_t* xptr = reinterpret_cast<uint64_t*>(xs + i); 
    uint64_t* zptr = reinterpret_cast<uint64_t*>(zs + i); 
    if (std::toupper(c) == 'X') {
        xptr[lane] |= (1ULL << bit_in_lane); 
        zptr[lane] &= ~(1ULL << bit_in_lane); 
    } else if (std::toupper(c) == 'Y') {
        xptr[lane] |= (1ULL << bit_in_lane); 
        zptr[lane] |= (1ULL << bit_in_lane); 
    } else if (std::toupper(c) == 'Z') {
        xptr[lane] &= ~(1ULL << bit_in_lane); 
        zptr[lane] |= (1ULL << bit_in_lane); 
    }
}

// the qubits are 1 indexed but the pauli strings are 0 indexed 
// so it is necessary to decrement the number passed in to match the indexing
void Vectorized_Pauli::delete_term(size_t index) {
    --index; 
    size_t i = index / 256; 
    size_t bit = index % 256; 
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    if (i >= num_words) return; 
    uint64_t* xptr = reinterpret_cast<uint64_t*>(xs + i); 
    uint64_t* zptr = reinterpret_cast<uint64_t*>(zs + i); 
    xptr[lane] &= ~(1ULL << bit_in_lane); 
    zptr[lane] &= ~(1ULL << bit_in_lane); 
}

// the qubits are 1 indexed but the pauli strings are 0 indexed 
// so it is necessary to decrement the number passed in to match the indexing
void Vectorized_Pauli::change_qubit(size_t oldq, size_t newq) {
    const size_t words_needed = (newq + 255) / 256;
    if (num_words < words_needed) {
        Vectorized_Pauli res = Vectorized_Pauli(newq); 
        std::memcpy(res.xs, xs, num_words * sizeof(__m256i)); 
        std::memcpy(res.zs, zs, num_words * sizeof(__m256i)); 
        *this = std::move(res); 
    } 
    if (oldq == 0 || newq == 0) std::cout << "should not be zero" << std::endl; 
    --oldq; 
    --newq; 
    size_t i = oldq / 256; 
    size_t bit = oldq % 256; 
    int lane = bit / 64; 
    int bit_in_lane = bit % 64; 
    size_t newi = newq / 256; 
    size_t newbit = newq % 256; 
    int newlane = newbit / 64; 
    int newbit_in_lane = newbit % 64; 
    uint64_t* xptr = reinterpret_cast<uint64_t*>(xs + i); 
    uint64_t* zptr = reinterpret_cast<uint64_t*>(zs + i); 
    if (xptr[lane] & (1ULL << bit_in_lane)) {
        uint64_t* newxptr = reinterpret_cast<uint64_t*>(xs + newi); 
        xptr[lane] &= ~(1ULL << bit_in_lane); 
        newxptr[newlane] |= (1ULL << newbit_in_lane); 
    } 
    if (zptr[lane] & (1ULL << bit_in_lane)) {
        uint64_t* newzptr = reinterpret_cast<uint64_t*>(zs + newi); 
        zptr[lane] &= ~(1ULL << bit_in_lane); 
        newzptr[newlane] |= (1ULL << newbit_in_lane); 
    }
}

bool Vectorized_Pauli::isI() const {
    for (size_t i = 0; i < num_words; ++i) {
        uint64_t* xptr = reinterpret_cast<uint64_t*>(xs + i); 
        uint64_t* zptr = reinterpret_cast<uint64_t*>(zs + i); 
        for (int j = 0; j < 4; ++j) {
            if (xptr[j] != 0) return false; 
            if (zptr[j] != 0) return false;  
        }
    }
    return true; 
}

// index of non-identity qubits 
// the set that is returned is 1-indexed 
std::set<size_t> Vectorized_Pauli::support() const {
    std::set<size_t> s; 
    for (size_t i = 0; i < num_words; ++i) {
        uint64_t* xptr = reinterpret_cast<uint64_t*>(xs + i); 
        uint64_t* zptr = reinterpret_cast<uint64_t*>(zs + i); 
        for (int j = 0; j < 4; ++j) {
            uint64_t xword = xptr[j];
            uint64_t zword = zptr[j];
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                s.insert(256 * i + 64 * j + bit + 1); 
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                s.insert(256 * i + 64 * j + bit + 1); 
                zword &= zword - 1;
            }
        }
    }
    return s; 
}

size_t Vectorized_Pauli::weight() const {
    size_t size = 0; 
    for (size_t i = 0; i < num_words; ++i) {
        uint64_t* xptr = reinterpret_cast<uint64_t*>(xs + i);
        uint64_t* zptr = reinterpret_cast<uint64_t*>(zs + i); 
        for (int j = 0; j < 4; ++j) {
            size += __builtin_popcountll(xptr[j] | zptr[j]); 
        }
    }
    return size; 
}

size_t Vectorized_Pauli::qubits() const {
    return std::max(last_nonzero_bit(xs, num_words), last_nonzero_bit(zs, num_words)); 
}

Vectorized_Pauli Vectorized_Pauli::copy() const {
    Vectorized_Pauli result;
    result.num_words = num_words;
    if (num_words == 0) {
        result.xs = nullptr; 
        result.zs = nullptr; 
        return result; 
    }
    result.xs = static_cast<__m256i*>(_mm_malloc(num_words * sizeof(__m256i), 32));
    result.zs = static_cast<__m256i*>(_mm_malloc(num_words * sizeof(__m256i), 32));
    std::memcpy(result.xs, xs, num_words * sizeof(__m256i));
    std::memcpy(result.zs, zs, num_words * sizeof(__m256i));

    return result;
}

std::set<size_t> Vectorized_Pauli::basis_rep() const {
    std::set<size_t> elements; 
    if (isI()) return elements; 
    const uint64_t* xptr = reinterpret_cast<uint64_t*>(xs); 
    const uint64_t* zptr = reinterpret_cast<uint64_t*>(zs); 
    for (size_t i = 0; i < num_words * 4; ++i) {
        uint64_t xword = xptr[i]; 
        uint64_t zword = zptr[i]; 
        while (xword) {
            int bit = __builtin_ctzll(xword); 
            elements.insert(128 * i + 2 * bit); 
            xword &= xword - 1; 
        }
        while (zword) {
            int bit = __builtin_ctzll(zword); 
            elements.insert(128 * i + 2 * bit + 1); 
            zword &= zword - 1;
        }
    }
    return elements; 
}

Vectorized_Pauli commute(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2) {
    return P1 * (P2 ^ (P1 % P2)); 
}

void commute_inplace(Vectorized_Pauli& P1, const Vectorized_Pauli& P2) {
    if (P1 % P2) P1 *= P2; 
}

Vectorized_Pauli commute_back(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2) {
    return P1 * (P2 ^ (P1 % P2)); 
}

void commute_back_inplace(Vectorized_Pauli& P1, const Vectorized_Pauli& P2) {
    if (P1 % P2) P1 *= P2; 
}

// rounds min_bits up to the nearest multiple of 256 and allocates that much memory 
__m256i* malloc_aligned_padded_zeroed(size_t min_bits) {
    size_t num_u8 = 32 * ((min_bits + 255) / 256);
    void* result = _mm_malloc(num_u8, sizeof(__m256i)); 
    memset(result, 0, num_u8);
    return (__m256i*)result;
}

std::ostream& operator<<(std::ostream& os, const Vectorized_Pauli& P) {
    if (P.isI()) {
        os << "I"; 
        return os; 
    }
    const uint64_t* xwords = reinterpret_cast<uint64_t*>(P.xs); 
    const uint64_t* zwords = reinterpret_cast<uint64_t*>(P.zs); 
    size_t total = P.num_words * 4; 
    for (size_t i = 0; i < total; ++i) {
        uint64_t xw = xwords[i]; 
        uint64_t zw = zwords[i]; 
        for (int bit = 0; bit < 64; ++bit) {
            if ((xw >> bit) & 1 && (zw >> bit) & 1) {
                os << "Y" << std::to_string(i * 64 + bit + 1) << " "; 
            } else if ((xw >> bit) & 1) {
                os << "X" << std::to_string(i * 64 + bit + 1) << " "; 
            } else if ((zw >> bit) & 1) {
                os << "Z" << std::to_string(i * 64 + bit + 1) << " "; 
            }
        }
    }
    return os; 
}

std::string fixed_length_string(const Vectorized_Pauli& P, size_t qubits) {
    std::string str = ""; 
    size_t q = 1; 
    const uint64_t* xwords = reinterpret_cast<uint64_t*>(P.xs); 
    const uint64_t* zwords = reinterpret_cast<uint64_t*> (P.zs); 
    for (size_t i = 0; q <= qubits && i < 4 * P.num_words; ++i) {
        uint64_t xw = xwords[i]; 
        uint64_t zw = zwords[i];
        for (int bit = 0; q <= qubits && bit < 64; ++bit) {
            if ((xw >> bit) & 1 && (zw >> bit) & 1)
                str += "Y"; 
            else if ((xw >> bit) & 1)
                str += "X"; 
            else if ((zw >> bit) & 1)
                str += "Z"; 
            else 
                str += "."; 
            ++q; 
        }
    }
    while (q <= qubits) {
        str += "."; 
        ++q;
    }
    return str; 
}

// data_offset is the number of data qubits and total_offset is the number of total qubits
std::pair<std::set<size_t>, std::set<size_t>> to_xz_sets(const Vectorized_Pauli& P, size_t data_offset, size_t total_offset) {
    std::set<size_t> data_s, ancilla_s; 
    const size_t ancilla_offset = total_offset - data_offset; 
    for (size_t i = 0; i <  P.num_words; ++i) {
        uint64_t* xptr = reinterpret_cast<uint64_t*>(P.xs + i); 
        uint64_t* zptr = reinterpret_cast<uint64_t*>(P.zs + i); 
        for (int j = 0; j < 4; ++j) {
            uint64_t xword = xptr[j]; 
            uint64_t zword = zptr[j]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                const size_t index = 256 * i + 64 * j + bit; 
                if (index < data_offset) data_s.insert(index);
                else ancilla_s.insert(index - data_offset);  
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                const size_t index = 256 * i + 64 * j + bit; 
                if (index < data_offset) data_s.insert(index + data_offset);
                else ancilla_s.insert(index- data_offset + ancilla_offset);  
                zword &= zword - 1; 
            }
        }
    }
    return std::pair{data_s, ancilla_s}; 
}

// data_offset is the number of data qubits and total_offset is the number of total qubits
std::pair<std::set<size_t>, std::set<size_t>> to_xz_sets_interleaved(const Vectorized_Pauli& P, size_t data_offset) {
    std::set<size_t> data_s, ancilla_s; 
    for (size_t i = 0; i <  P.num_words; ++i) {
        uint64_t* xptr = reinterpret_cast<uint64_t*>(P.xs + i); 
        uint64_t* zptr = reinterpret_cast<uint64_t*>(P.zs + i); 
        for (int j = 0; j < 4; ++j) {
            uint64_t xword = xptr[j]; 
            uint64_t zword = zptr[j]; 
            while (xword) {
                int bit = __builtin_ctzll(xword); 
                const size_t index = 256 * i + 64 * j + bit; 
                if (index < data_offset) data_s.insert(2 * index);
                else ancilla_s.insert(2 * (index - data_offset));  
                xword &= xword - 1; 
            }
            while (zword) {
                int bit = __builtin_ctzll(zword); 
                const size_t index = 256 * i + 64 * j + bit; 
                if (index < data_offset) data_s.insert(2 * index + 1);
                else ancilla_s.insert(2 * (index - data_offset) + 1);  
                zword &= zword - 1; 
            }
        }
    }
    return std::pair{data_s, ancilla_s}; 
}

Vectorized_Pauli vectorize(const Pauli& p) {
    auto xs_view = binary_XOR(p.y, p.z) | std::views::transform([](int x) { return static_cast<size_t>(x); }); 
    auto zs_view = binary_XOR(p.y, p.x) | std::views::transform([](int x) { return static_cast<size_t>(x); }); 
    std::set<size_t> xs(xs_view.begin(), xs_view.end()); 
    std::set<size_t> zs(zs_view.begin(), zs_view.end()); 
    Vectorized_Pauli vp(xs, zs); 
    return vp;
}

// indexed starting at 1 as with all the qubits 
size_t first_nonzero_bit(const __m256i* vec, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        const uint64_t* ptr = reinterpret_cast<const uint64_t*>(vec + i); 
        for (int j = 0; j < 4; ++j) {
            if (ptr[j]) 
                return i * 256 + j * 64 + __builtin_ctzll(ptr[j]) + 1; // count trailing zeros
        }
    }
    return 0; 
}

// index starting at 1 as with all the qubits 
size_t last_nonzero_bit(const __m256i* vec, size_t size) {
    for (size_t i = size; i > 0; --i) {
        const uint64_t* ptr = reinterpret_cast<const uint64_t*>(vec + i - 1); 
        for (int j = 3; j >= 0; --j) {
            if (ptr[j])
                return (i - 1) * 256 + j * 64 + 64 - __builtin_clzll(ptr[j]); // count leading zeros
        }
    }
    return 0; 
}

// the size of the whole bit is just the max of the two inputed sizes
__m256i* intersect(const __m256i* b1, size_t s1, const __m256i* b2, size_t s2) {
    const size_t max = std::max(s1, s2); 
    const size_t min = std::min(s1, s2); 
    __m256i* res = malloc_aligned_padded_zeroed(max * 256);
    for (size_t i = 0; i < min; ++i) {
        res[i] = _mm256_or_si256(b1[i], b2[i]); 
    } 
    if (s1 > s2) {
        std::memcpy(res + min, b1 + min, (max - min) * sizeof(__m256i));
    } else if (s2 > s1) {
        std::memcpy(res + min, b2 + min, (max - min) * sizeof(__m256i)); 
    }
    return res; 
}

std::set<size_t> set_union(const std::set<size_t>& s1, const std::set<size_t>& s2) {
    std::vector<size_t> s; 
    std::set_union(s1.cbegin(), s1.cend(),
                s2.cbegin(), s2.cend(),
                std::back_inserter(s));
    return std::set<size_t> (s.begin(), s.end()); 
}
</file>

<file path="Test_Pauli/Stim_Pauli.h">
#ifndef STIM_PAULI
#define STIM_PAULI

#include <immintrin.h>
#include <cstdint> 
#include <iostream>
#include <cstring>
#include <vector>
#include <set>
#include <ranges>
#include <malloc.h>

#include "../Pauli.h"

// this data is always padded  i.e. always has number of bits that is a multiple of 256
// only has move and not copy operators; manual copying is needed
struct Vectorized_Pauli {
    __m256i* xs = nullptr; 
    __m256i* zs = nullptr; 
    size_t num_words = 0; // number of 256 bits reserved for this pauli; 1-indexed

    // Alignment size required for AVX
    static constexpr size_t alignment = 32;

    Vectorized_Pauli() : xs(nullptr), zs(nullptr), num_words(0) {}
    Vectorized_Pauli(size_t num_blocks); 
    Vectorized_Pauli(const Vectorized_Pauli&) = delete;
    Vectorized_Pauli(Vectorized_Pauli&& other) noexcept;
    Vectorized_Pauli& operator=(const Vectorized_Pauli&) = delete; 
    Vectorized_Pauli& operator=(Vectorized_Pauli&& other) noexcept; 
    bool operator==(const Vectorized_Pauli& other) const; 
    Vectorized_Pauli(const std::set<size_t> &xval, const std::set<size_t> &zval);
    Vectorized_Pauli(const std::string& Vectorized_Pauli_string); 
    Vectorized_Pauli(const std::vector<std::pair<char, size_t>>& vec); 
    void swap(Vectorized_Pauli& other) noexcept; 

    void set_index(char c, size_t index); 
    void delete_term(size_t index); 
    void change_qubit(size_t oldq, size_t newq); 
    char operator[](size_t index) const; 
    Vectorized_Pauli& operator*=(const Vectorized_Pauli& P); 

    bool isI() const;
    std::set<size_t> support() const; 
    size_t weight() const; 
    size_t qubits() const; 
    Vectorized_Pauli copy() const; 
    std::set<size_t> basis_rep() const; 

    ~Vectorized_Pauli() {
        free(); 
    }

    void free() {
        if (xs) _mm_free(xs); // treats the memory as a big block so only need to free once 
        if (zs) _mm_free(zs);
        xs = nullptr;
        zs = nullptr;
        num_words = 0;
    }
} ; 

__m256i* malloc_aligned_padded_zeroed(size_t min_bits);
Vectorized_Pauli operator*(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2); 
bool operator<(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2); 
Vectorized_Pauli operator^(const Vectorized_Pauli& P, bool b); 
bool operator%(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2); // sym inner prod 
void swap(Vectorized_Pauli& a, Vectorized_Pauli& b) noexcept; 
std::pair<std::set<size_t>, std::set<size_t>> to_xz_sets(const Vectorized_Pauli& P, size_t data_offset, size_t total_offset); 
std::pair<std::set<size_t>, std::set<size_t>> to_xz_sets_interleaved(const Vectorized_Pauli& P, size_t data_offset); 
Vectorized_Pauli vectorize(const Pauli& p); 
Vectorized_Pauli commute(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2);
void commute_inplace(Vectorized_Pauli& P1, const Vectorized_Pauli& P2); 
Vectorized_Pauli commute_back(const Vectorized_Pauli& P1, const Vectorized_Pauli& P2); 
void commute_back_inplace(Vectorized_Pauli& P1, const Vectorized_Pauli& P2); 
std::ostream& operator<<(std::ostream& os, const Vectorized_Pauli& P); 
std::string fixed_length_string(const Vectorized_Pauli& P, size_t qubits); 

// helpers 
inline void binary_XOR(std::set<size_t>& s, int index) {
    if (s.erase(index) == 0) s.insert(index); 
}
std::set<size_t> set_union(const std::set<size_t>& s1, const std::set<size_t>& s2); 
size_t first_nonzero_bit(const __m256i* vec, size_t size);
size_t last_nonzero_bit(const __m256i* vec, size_t size); 
__m256i* intersect(const __m256i* b1, size_t s1, const __m256i* b2, size_t s2);

#endif
</file>

<file path="Test_Pauli/tests.cc">
#include "tests.h"

Circuit test1() {
    double error_prob = 0.000003; 
    double measure_prob = 0.000003; 
    int repeats = 5; 
    std::vector<Operator> operators; 
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Y3"));
    operators.push_back(Clifford("Y4"));
    operators.push_back(Clifford("Z3 X5"));
    operators.push_back(Clifford("Z3")); 
    operators.push_back(Clifford("X5")); 
    operators.push_back(Clifford("Z4 X2"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X2"));
    operators.push_back(Clifford("Y2"));
    operators.push_back(Clifford("Z4 X5"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X5"));
    operators.push_back(Clifford("Z2 X1"));
    operators.push_back(Clifford("Z2")); 
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Z3"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Z2"));
    operators.push_back(Clifford("Z5 X1"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Y5"));
    operators.push_back(Clifford("Z5 X2"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X2"));

    for (int r = 0; r < repeats; ++r) {
        if (error_prob > 0) {
            for (size_t i = 1; i <= 5; ++i) {
                operators.emplace_back(Error(error_prob, std::set<size_t>{i}));
            }
        }
        operators.emplace_back(Measure("X1 Z2 Z3 X4", false, measure_prob));
        operators.emplace_back(Measure("X2 Z3 Z4 X5", false, measure_prob));
        operators.emplace_back(Measure("X3 Z4 Z5 X1", false, measure_prob));
        operators.emplace_back(Measure("X4 Z5 Z1 X2", false, measure_prob));
    }

    return Circuit(operators); 
}

Circuit test2() {
    std::vector<Operator> operators; 
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Y3"));
    operators.push_back(Clifford("Y4"));
    operators.push_back(Clifford("Z3 X5"));
    operators.push_back(Clifford("Z3")); 
    operators.push_back(Clifford("X5")); 
    operators.push_back(Clifford("Z4 X2"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X2"));
    operators.push_back(Clifford("Y2"));
    operators.push_back(Clifford("Z4 X5"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X5"));
    operators.push_back(Clifford("Z2 X1"));
    operators.push_back(Clifford("Z2")); 
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Z3"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Z2"));
    operators.push_back(Clifford("Z5 X1"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Y5"));
    operators.push_back(Clifford("Z5 X2"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X2"));

    return Circuit(operators); 
}

Loop looptest2() {
    double error_prob = 0.000003; 
    double measure_prob = 0.000003; 
    int repeats = 5; 
    std::vector<Operator> operators;  
    if (error_prob > 0) {
        for (size_t i = 1; i <= 5; ++i) {
            operators.emplace_back(Error(error_prob, std::set<size_t>{i}));
        }
    }
    operators.emplace_back(Measure("X1 Z2 Z3 X4", false, measure_prob));
    operators.emplace_back(Measure("X2 Z3 Z4 X5", false, measure_prob));
    operators.emplace_back(Measure("X3 Z4 Z5 X1", false, measure_prob));
    operators.emplace_back(Measure("X4 Z5 Z1 X2", false, measure_prob));

    return Loop(Circuit(operators), repeats, false); 
}
</file>

<file path="Test_Pauli/tests.h">
#ifndef _STIM_TESTS
#define _STIM TESTS 

#include "Loop.h"
#include "SampleLoop.h"
#include "Circuit.h"

Circuit test1(); 
Circuit test2(); 
Loop looptest1(); 
Loop looptest2(); 

#endif
</file>

<file path="Test_Pauli/Weights.h">
#ifndef _QULIA_WEIGHT
#define _QULIA_WEIGHT

#include <array>
#include <complex>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <vector>
#include <numeric>

struct Weights {
    std::vector<double> values;

    Weights(const std::vector<double>& w) : values(w) {
    if (w.empty())
        throw std::invalid_argument("Weights cannot be empty");
    for (double v : w)
        if (v < 0.0)
            throw std::invalid_argument("Weights must be non-negative");
    }
    Weights() = default; 
    Weights(const Weights&) = default;
    Weights& operator=(const Weights&) = default;

    inline std::vector<double>::const_iterator begin() const {
        return values.begin(); 
    }

    inline std::vector<double>::const_iterator end() const {
        return values.end(); 
    }

    inline double get(int index) const {
        return values[index];
    }

    inline void set(int index, int val) {
        values[index] = val; 
    }

    inline double total() const {
        return std::accumulate(values.begin(), values.end(), 0.0);
    }

    inline double normalized(int i) const {
        return values[i] / total();
    }

    inline size_t size() const {
        return values.size();
    }
} ; 
    

#endif
</file>

<file path="Circuit.cc">
#include "Circuit.h"

Circuit::Circuit(const std::initializer_list<Operator>& ops) {
    operators = std::vector<Operator> (ops); 
}

const Operator& Circuit::operator[] (int index) const {
    return operators[index]; 
}

Operator& Circuit::operator[] (int index) {
    return operators[index]; 
}

void Circuit::push(const Operator& op) {
    operators.push_back(op); 
}

void Circuit::push_first(const Operator& op) {
    operators.insert(operators.begin(), op); 
}

void Circuit::append(std::initializer_list<Operator> ops) {
     for (const Operator& op: ops) {
        operators.push_back(op); 
     }
}

void Circuit::append(std::initializer_list<Circuit> subcircs) {
    for (const Circuit& subcirc : subcircs) {
        for (const Operator& op : subcirc.operators) {
            operators.push_back(op); 
        }
    }
}

void Circuit::splice(int index, const Circuit& subcirc) {
    if (index > (int) operators.size()) {
        throw std::out_of_range("Index out of range");
    } else {
        operators.erase(operators.begin() + index);
        operators.insert(operators.begin() + index, 
                         subcirc.operators.begin(), 
                         subcirc.operators.end());
    }
}

int Circuit::length() const {
    return operators.size(); 
}

int Circuit::qubits() const {
    int max_qubits = 0;
    for (const Operator& op : operators) {
        max_qubits = std::max(max_qubits, 
                            std::visit([](const auto& _op) -> int {
                                return _op.qubits();  
                            }, op));
    }
    return max_qubits;
}

std::set<int> Circuit::support(
    std::optional<int> left_index,
    std::optional<int> right_index
) const {
    int lindex = left_index ? *left_index : 0; // assumes c++ doesn't support custom indexing
    int rindex = right_index ? *right_index : operators.size() - 1; 
    std::set<int> supp; 
    for (int i = lindex; i <= rindex; ++i) 
        supp = set_union(supp, std::visit([](const auto& _op) -> std::set<int> {
                                return _op.support();
                                }, operators[i]));  
    return supp;
}

void Circuit::permute(
    Permutation perm, 
    std::optional<int> left_index,
    std::optional<int> right_index
) {
    int lindex = left_index ? *left_index : 0; // assumes c++ doesn't support custom indexing
    int rindex = right_index ? *right_index : operators.size() - 1; 
    for (int i = lindex; i <= rindex; ++i) {
        std::visit([&perm](auto& _op) {
            _op.permute(perm); 
        }, operators[i]);
    }
}

void Circuit::extract_measures(int index) { // the operator at index should be a measure
    Operator op = operators[index]; 
    if (!std::holds_alternative<Measure>(op)) return; 
    Measure& M = std::get<Measure>(op); 
    Circuit subcirc = Circuit(); 
    int q = qubits() + 1; 
    Pauli Xq = Pauli("X" + std::to_string(q)); 

    // ??? 
    subcirc.push(Reset("Z" + std::to_string(q)));
    subcirc.push(Clifford(M.pauli * Xq)); 
    subcirc.push(Clifford(M.pauli)); 
    subcirc.push(Clifford(Xq)); 
    subcirc.push(Error(M.pauli)); 
    subcirc.push(Measure("Z" + std::to_string(q), M.sign, M.probability)); 
    splice(index, subcirc); 
}

void Circuit::extract_measures() {
    int index = 0; 
    Operator op; 
    while (index < length()) {
        op = operators[index]; 
        if (std::holds_alternative<Measure>(op)) {
            // checks if this operation involves more than one qubit 
            if (std::visit([](const auto& _op) {return _op.weight(); }, op) > 1) {
                extract_measures(index); 
            }
            else 
            {
                // index of the first (and only) qubit in the operation
                int q = std::visit([](const auto& _op) {return *(_op.support().begin()); }, op); 
                // else, the operation involves a single qubit and you check whether there are more operations 
                // on this qubit after the measurement
                std::set<int> supp = support(index + 1); 
                if (supp.find(q) != supp.end()) {
                    extract_measures(index); 
                }
            }
        }
        ++index; 
    }
}

// doesn't add errors 
void Circuit::add_resets() {
    for (int q = 1; q <= qubits(); ++q) {
        Operator first_op = Operator(); // in case there is no operator acting on the qubit at index 
        // finds the first operator that acts on the qubit at index
        for (const Operator& op : operators) {
            std::set<int> supp = std::visit([](const auto& _op) {
                return _op.support();
            }, op);
            if (supp.find(q) != supp.end()) {
                first_op = op; 
                break; 
            }
        }
        if (!std::holds_alternative<Reset>(first_op)) 
            push_first(Reset(q)); 
    }
}

// for loops; also adds all the errors 
void Circuit::add_initial_resets() {
    for (int q = qubits(); q >= 1; --q) {
        Operator first_op = Operator(); // in case there is no operator acting on the qubit at index 
        // finds the first operator that acts on the qubit at index
        for (const Operator& op : operators) {
            std::set<int> supp = std::visit([](const auto& _op) {
                return _op.support();
            }, op);
            if (supp.find(q) != supp.end()) {
                first_op = op; 
                break; 
            }
        }
        if (!std::holds_alternative<Reset>(first_op)) {
            push_first(Error(Reset(q))); 
            push_first(Reset(q)); 
        }
    }
}

// returns the index of the last reset after this sort 
int Circuit::pull_resets_first() {
    int last_reset = -1; 
    for (int index = operators.size() - 1; index >= 0; --index) {
        if (std::holds_alternative<Reset>(operators[index])) {
            last_reset = index;
            break;
        }
    }
    if (last_reset != -1) {
        int index = last_reset - 1; 
        while (index >= 0) {
            Operator op = operators[index]; 
            // commutes every non-reset forwards to past the last reset
            // only resets should occur between index (non-inclusive) and last_reset (inclusive)
            if (!std::holds_alternative<Reset>(op)) {
                for (int i = index + 1; i <= last_reset; ++i) {
                    const Reset& R = std::get<Reset>(operators[i]); 
                    op = std::visit([R](const auto& _op) -> Operator {return commute(_op, R);}, op); 
                }
                operators.insert(operators.begin() + last_reset + 1, op); 
                operators.erase(operators.begin() + index); 
                --last_reset; 
            }
            --index; 
        }
    }
    return last_reset; 
}

// this part of the circuit should only contain errors added for measurements
// and the measurements for the loop
// returns the index of the first measure after this sort 
int Circuit::push_merrors_last() {
    size_t first_measure = operators.size(); 
    for (size_t index = 0; index < operators.size(); ++index) {
        if (std::holds_alternative<Measure>(operators[index])) {
            first_measure = index; 
            break; 
        }
    }
    if (first_measure != operators.size()) {
        size_t index = operators.size() - 1; 
        while (index > first_measure) {
            Operator op = operators[index]; 
            // commutes every error in the last part past the measurements 
            if (std::holds_alternative<Error>(op)) {
                // Error E = std::get<Error>(op);  
                // for (int i = index + 1; i <= first_measure; ++i) {
                //     const Operator& op2 = operators[i]; 
                //     op = std::visit([E](const auto& _op) {return commute(_op, R);}, op); 
                // }
                // The Error does not change when you commute it through with only errors and measurements 
                operators.insert(operators.end(), op); 
                operators.erase(operators.begin() + index);
            }
            --index; 
        }
    }
    return first_measure; 
}

void Circuit::pull_errors_through_gates(int start, int end) {
    // number of errors 
    int errors = 0; 
    for (int index = start; index <= end; ++index) {
        if (std::holds_alternative<Error>(operators[index])) {
            Error E = std::get<Error>(operators[index]); 
            for (int i = index - 1; i >= start + errors; --i) {
                const Operator& op2 = operators[i];
                E = std::visit([E](const auto& _op2) {return commute_back(E, _op2); }, op2);
            }
            operators.erase(operators.begin() + index); 
            // since errors always commute with each other, we can always insert errors to the very beginning
            // and skip the commuting across the errors part 
            operators.insert(operators.begin() + start, E); 
            ++errors; 
        }
    }
}

void Circuit::reorder() {
    int index = 0; 
    while(index < length()) {
        const Operator& op = operators[index]; 
        if (std::holds_alternative<Reset>(op)) {
            push_first(op);
            operators.erase(operators.begin() + index + 1); 
        } else {
            // moves all the measures to the end 
            if (std::holds_alternative<Measure>(op)) {
                // checks if anything after this operator is not a Measure 
                bool none_measure = false;
                for (std::vector<Operator>::const_iterator i = operators.begin() + index; i < operators.end(); ++i) {
                    if (!std::holds_alternative<Measure>(*i)) {
                        none_measure = true; 
                        break; 
                    }
                }
                if (none_measure) {
                    push(op); 
                    operators.erase(operators.begin() + index) + 1; 
                    --index; 
                }
            }
        }
        ++index; 
    }
    // std::vector<Operator>::iterator last_reset = operators.begin(); 
    // for (std::vector<Operator>::iterator it = operators.end() - 1; it >= operators.begin(); --it) {
    //     if (std::holds_alternative<Reset>(*it)) {
    //         last_reset = it;
    //         break;
    //     }
    // }
    // std::vector<Operator>::iterator first_measure = operators.end(); 
    // for (std::vector<Operator>::iterator it = operators.begin(); it < operators.end(); ++it) {
    //     if (std::holds_alternative<Measure>(*it)) {
    //         first_measure = it; 
    //         break; 
    //     }
    // } 
    // if (last_reset > operators.begin()) std::sort(operators.begin(), last_reset + 1); 
    // if (operators.end() > first_measure)
    //     std::sort(first_measure, operators.end(), [](const Operator& op1, const Operator& op2 ) {
    //                                                     return !(op1 < op2); 
    //                                                 }); 
}

void Circuit::add_reset_errors() {
    int index = 0; 
    while (index < length()) {
        if (std::holds_alternative<Reset>(operators[index])) {
            operators.insert(operators.begin() + index + 1, Error(std::get<Reset>((*this)[index])));
            ++index;  
        }
        ++index; 
    }
}

void Circuit::add_measure_errors() {
    int index = 0; 
    while (index < length()) {
        if (std::holds_alternative<Measure>((operators[index]))) {
            operators.insert(operators.begin() + index + 1, Error(std::get<Measure>((*this)[index])));
            ++index; 
        }
        ++index; 
    }
}

int Circuit::measurements() const {
    int count = 0; 
    for (const Operator& op : operators) {
        if (std::holds_alternative<Measure>(op)) ++count; 
    }
    return count; 
}

std::ostream& operator<<(std::ostream& os, const Circuit& circ) {
    int q = circ.qubits();  
    for (const Operator& op : circ.operators) 
        os << fixed_length_string(op, q) << "\n"; 
    return os; 
}
</file>

<file path="Circuit.h">
#ifndef _QULIA_CIRCUIT
#define _QULIA_CIRCUIT      

#include "Pauli.h"
#include "Operator.h"

struct Circuit {
    std::vector<Operator> operators; 
    Circuit() = default; 
    Circuit(const Circuit&) = default; 
    Circuit(const std::vector<Operator>& ops) : operators(ops) {}
    Circuit& operator=(const Circuit&) = default;
    Circuit(const std::initializer_list<Operator>& ops);

    const Operator& operator[] (int index) const; 
    Operator& operator[] (int index); 
    // set index
    void push(const Operator& op); 
    void push_first(const Operator& op); 
    void append(std::initializer_list<Operator> ops); 
    void append(std::initializer_list<Circuit> subcircs);
    void splice(int index, const Circuit& subcirc=Circuit());  

    int length() const; 
    int qubits() const; 
    std::set<int> support(
        std::optional<int> left_index=std::nullopt,
        std::optional<int> right_index=std::nullopt
    ) const; 
    void permute(
        Permutation perm, 
        std::optional<int> left_index=std::nullopt,
        std::optional<int> right_index=std::nullopt
    ); 
    void extract_measures(int index); 
    void extract_measures(); 
    void add_resets(); 
    void add_initial_resets(); 
    int pull_resets_first(); 
    int push_merrors_last(); 
    void pull_errors_through_gates(int start, int end); 
    void reorder(); 
    void add_reset_errors(); 
    void add_measure_errors(); 
    
    int measurements() const; 
} ; 

std::ostream& operator<<(std::ostream& os, const Circuit& circ) ; 

#endif
</file>

<file path="CMakeLists.txt">
cmake_minimum_required(VERSION 3.10)

if(NOT CMAKE_C_COMPILER)
    set(CMAKE_C_COMPILER gcc)
endif()

if(NOT CMAKE_CXX_COMPILER)
    set(CMAKE_CXX_COMPILER g++)
endif()

project(Stim)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_compile_options(-Wall -Wextra -O3 -g)

set(SOURCES
    Operator.cc
    Pauli.cc
    Circuit.cc
    Permutation.cc
    SampleCircuit.cc
    tests.cc
    Loop.cc
    SampleLoop.cc
    main.cc
)

add_executable(test ${SOURCES})

target_include_directories(test PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
</file>

<file path="Loop.cc">
#include "Loop.h"

Loop::Loop(const Circuit& C, int r, bool am) {
    circ = Circuit(C); 
    repeat = r; 
    ancilla_measures = am; 
    reduced_circ = standardize(C, ancilla_measures); 
} 

Loop::Loop(const std::initializer_list<Operator>& ops, int r, bool am) {
    circ = Circuit(ops);
    repeat = r; 
    ancilla_measures = am; 
    reduced_circ = standardize(circ, ancilla_measures);  
}

void Loop::insert(const Operator& op, int index) {
    circ.operators.insert(circ.operators.begin() + index, op); 
    reduced_circ = standardize(circ, ancilla_measures); 
}

void Loop::push_first(const Operator& op) {
    circ.push_first(op);
    reduced_circ = standardize(circ, ancilla_measures); 
}

void Loop::push(const Operator& op) {
    circ.push(op); 
    reduced_circ = standardize(circ, ancilla_measures); 
}

void Loop::append(const std::initializer_list<Operator>& ops) {
    circ.append(ops); 
    reduced_circ = standardize(circ, ancilla_measures); 
}

Circuit standardize(const Circuit& new_circ, bool am) {
    Circuit modified = new_circ; 
    if (am) modified.extract_measures(); 
    if (!am) modified.add_measure_errors(); 
    modified.reorder(); 
    modified.add_reset_errors(); 

    // put this modified circuit into the format: 
    //      RESETS - ERRORS - GATES - MEASURES - MEASURE ERRORS
    int start = modified.pull_resets_first() + 1; 
    int end = modified.push_merrors_last() - 1; 
    modified.pull_errors_through_gates(start, end); 

    std::cout << "The modified loop body is: \n " << modified << "\n"; 
    return modified; 
}

std::ostream& operator<<(std::ostream& os, const Loop& loop) {
    os << "REPEAT FOR: " << loop.repeat << " TIMES \n"; 
    os << "THE REPEAT BLOCK: \n"; 
    os << loop.circ; 
    os << "THE SIMPLIFIED BLOCK: \n"; 
    os << loop.reduced_circ; 
    return os; 
}
</file>

<file path="Loop.h">
#ifndef _QULIA_LOOP
#define _QULIA_LOOP

#include "Circuit.h"
#include <map>

struct Loop {
    bool ancilla_measures; 
    Circuit circ; 
    Circuit reduced_circ; 
    int repeat; 

    Loop() = default; 
    Loop(const Loop&) = default; 
    Loop& operator=(const Loop&) = default; 
    Loop(const Circuit& C, int r, bool am=true); 
    Loop(const std::initializer_list<Operator>& ops, int r, bool am=true); 

    void set_repeat(int r) {repeat = r;} 

    // for all of these methods, whenever any new operator is added, reduced circ will need to be 
    // recalculated - is efficiency an issue here? 
    void insert(const Operator& op, int index); 
    void push_first(const Operator& op);
    void push(const Operator& op); 
    void append(const std::initializer_list<Operator>& ops);  
    
} ; 

// reproduces an equivalent circuit that is in the block format: (Resets), Errors, Gates, Measures, (Errors)
// given circ, gives reduced_circ
Circuit standardize(const Circuit& new_circ, bool am); 
std::ostream& operator<<(std::ostream& os, const Loop& loop); 

#endif
</file>

<file path="main.cc">
#include "tests.h"
#include <chrono>

using Clock = std::chrono::high_resolution_clock;

int main() {

    // printCircuitwithLoop(test2(), looptest2(), Circuit()); 
    int shots = 100000; 
    std::vector<std::pair<BitString, int64_t>> results; 
    SampleLoop l1 = SampleLoop(Loop(test2(), 1, false)); 
    SampleLoop l2 = SampleLoop(looptest2()); 
    auto start = Clock::now(); 
    results = measure(shots, {l1, l2}); 
    auto end = Clock::now(); 
    std::cout << "It took: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << " ms \n"; 
    // SampleLoop sample_loop = SampleLoop(looptest2()); 
    // for (int i : sample_loop.rqubits) std::cout << i <<"\n"; 
    // for (Error E: sample_loop.errors) std::cout << "Actual Error: " << E << "\n"; 
    // for (Error E: sample_loop.merrors) std::cout << "Measurement Error: " << E << "\n"; 
    // for (std::pair<Pauli, std::pair<Pauli, BitString>> map : sample_loop.map) {
    //     std::cout << map.first << " maps to \n"; 
    //     std::cout << map.second.first << "\n"; 
    //     std::cout << map.second.second << "\n"; 
    // }
    // results = sample_loop.measure(shots, test2(), Circuit()); 
    for (std::pair<BitString, int64_t> pr : results) {
        std::cout << pr.first << " " << pr.second << "\n"; 
    }

    //Circuit circ = test1();
    // Circuit reduced = looptest1().reduced_circ;  
    //SampleCircuit sample_circ = SampleCircuit(circ); 
    // SampleCircuit sample_reduced = SampleCircuit(reduced); 
    // std::cout << "printing sample circuit for the normal circuit: " << "\n" <<  sample_circ << "\n\n"; 
    // std::cout << "printing sample circuit for the reduced circuit: " << "\n" <<  sample_reduced << "\n\n"; 

    // this sampling is pretty slow
    // std::vector<std::pair<std::vector<bool>, int64_t>> outcomes = sample_circ.measure(shots); 
    // std::cout << "Sampled distribution \n"; 
    // for (std::pair<std::vector<bool>, int64_t> pr : outcomes) {
    //     std::cout << pr.first << " " << pr.second << "\n"; 
    // }
    // std::cout << looptest1(); 
}


// #include <iostream>
// #include <chrono>
// #include <vector>
// #include <random>
// #include <cassert>

// using namespace std;
// using namespace std::chrono;

// // Helper to create a random BitString
// BitString random_bitstring(size_t num_bits) {
//     size_t num_words = (num_bits + BitString::BITS_PER_INT - 1) / BitString::BITS_PER_INT;
//     std::vector<uint64_t> data(num_words);
//     std::random_device rd;
//     std::mt19937_64 gen(rd());
//     std::uniform_int_distribution<uint64_t> dis;

//     for (auto& word : data) {
//         word = dis(gen);
//     }

//     BitString bs;
//     bs.bs = data;
//     bs.num_bits = num_bits;
//     return bs;
// }

// // Template to benchmark any function
// template<typename Func>
// void benchmark(const std::string& label, Func func, size_t iterations = 30000) {
//     auto start = high_resolution_clock::now();
//     func();
//     auto end = high_resolution_clock::now();
//     std::chrono::duration<double, std::milli> duration_ms = end - start;
//     cout << label << ": " << duration_ms.count() << " ms" << endl;
// }

// // Benchmark all BitString operations
// void benchmark_bitstring_operations() {
//     constexpr size_t bits = 1000;
//     constexpr size_t iterations = 30000;

//     BitString a = random_bitstring(bits);
//     BitString b = random_bitstring(bits);
//     BitString c;

//     // XOR
//     benchmark("operator^", [&]() {
//         for (size_t i = 0; i < iterations; ++i) {
//             c = a ^ b;
//         }
//     });

//     // XOR assignment
//     benchmark("operator^=", [&]() {
//         BitString tmp = a;
//         for (size_t i = 0; i < iterations; ++i) {
//             tmp ^= b;
//         }
//     });

//     // Bit access
//     benchmark("operator[]", [&]() {
//         volatile bool val = false;
//         for (size_t i = 0; i < iterations; ++i) {
//             val ^= a[i % bits];
//         }
//     });

//     // Addition (concatenation)
//     benchmark("operator+", [&]() {
//         for (size_t i = 0; i < iterations; ++i) {
//             c = a + b;
//         }
//     });

//     // Addition (concatenation)
//     benchmark("operator+=", [&]() {
//         for (size_t i = 0; i < iterations; ++i) {
//             BitString tmp = a;
//             tmp += b;
//         }
//     });

//     // Equality
//     benchmark("operator==", [&]() {
//         volatile bool equal = false;
//         for (size_t i = 0; i < iterations; ++i) {
//             equal ^= (a == b);
//         }
//     });

//     // Set bits
//     benchmark("set", [&]() {
//         BitString tmp = a;
//         for (size_t i = 0; i < iterations; ++i) {
//             tmp.set(i % bits, i % 2);
//         }
//     });
// }

// int main() {
//     benchmark_bitstring_operations();
//     return 0;
// }
</file>

<file path="Operator.cc">
#include "Operator.h"

// Cliffords 

std::set<int> Clifford::support() const {
    return pauli.support(); 
}

int Clifford::weight() const {
    return pauli.weight(); 
}

int Clifford::qubits() const {
    return pauli.qubits(); 
}
bool Clifford::operator<(const Clifford &C) const {
    return pauli < C.pauli; 
}

void Clifford::permute(const Permutation& perm) {
    pauli.permute(perm); 
}

Clifford random_Clifford(
    std::optional<int> qubits, 
    std::optional<double> probability, 
    std::optional<int> max_weight,
    std::optional<int> exact_weight,
    std::optional<std::set<int>> max_support,
    std::optional<std::set<int>> exact_support,
    std::vector<char> pauli_terms
) {
    return Clifford(random_Pauli(
        qubits,
        probability,
        max_weight,
        exact_weight,
        max_support,
        exact_support,
        pauli_terms
    ));
}

std::ostream& operator<<(std::ostream& os, const Clifford& C) {
    os << " C |" << C.pauli; 
    return os; 
}

std::string fixed_length_string(const Clifford& C, int qubits) {
    std::string str = " C | "; 
    str += fixed_length_string(C.pauli, qubits); 
    // std::cout << "string for Clifford: " << str << "\n"; 
    return str; 
}

Clifford commute(const Clifford& C, const Reset& R) {
    Pauli P = C.pauli; 
    P.delete_term(R.qubits());
    return Clifford(P); 
}

// Resets 

Reset::Reset(int index) 
    : Reset("Z" + std::to_string(index)) {}


Reset::Reset(const std::string& pauli_string) 
    : Reset(Pauli(pauli_string)) {}


std::set<int> Reset::support() const {
    return pauli.support(); 
}

int Reset::weight() const {
    return pauli.weight(); 
}

int Reset::qubits() const {
    return pauli.qubits(); 
}

void Reset::permute(const Permutation& perm) {
    pauli.permute(perm); 
}

bool Reset::operator<(const Reset &R) const {
    return pauli < R.pauli; 
}

std::ostream& operator<<(std::ostream& os, const Reset& R) {
    os << " R | " << R.pauli; 
    return os; 
}

std::string fixed_length_string(const Reset& R, int qubits) {
    std::string str = " R | "; 
    str += fixed_length_string(R.pauli, qubits); 
    return str;     
}

Reset commute(const Reset& R1, const Reset& op) {
    throw std::invalid_argument("Cannot commute a Reset forward with any operator"); 
}

Pauli commute(const Pauli& P, const Reset& R) {
    Pauli P1 = P; 
    P1.delete_term(R.qubits());
    return Pauli(P1); 
}

// Measures

std::set<int> Measure::support() const {
    return pauli.support(); 
}

int Measure::weight() const {
    return pauli.weight(); 
}

int Measure::qubits() const {
    return pauli.qubits(); 
}

void Measure::permute(const Permutation& perm) {
    pauli.permute(perm); 
}

bool Measure::operator<(const Measure &M) const {
    return pauli < M.pauli; 
}

std::ostream& operator<<(std::ostream& os, const Measure& M) {
    os << (M.sign ? "-" : "+") << "M | " << M.pauli << " | " << M.probability; 
    return os; 
}

std::string fixed_length_string(const Measure& M, int qubits) {
    std::string str = (M.sign ? "-" : "+"); 
    str += "M | "; 
    str += fixed_length_string(M.pauli, qubits); 
    str += " | "; 
    str += std::to_string(M.probability); 
    return str;     
}

Measure commute(const Measure& M, const Reset& op) {
    throw std::invalid_argument("Cannot commute a measure forward with any operator"); 
} 

// Errors

Error::Error(const Pauli& P) {
    paulis = {Pauli(), P}; 
    weights = Weights({0.5, 0.5});
} 

Error::Error(const Reset& R) 
    : Error(R.pauli) {}


Error::Error(const Measure& M) 
    : Error(M.pauli) {}

// simplified model where every non-identity Pauli errors occur with the same probability 
Error::Error(
    double probability, // probability that an error will occur (i.e. not just identity)
    const std::set<int>& support, 
    std::vector<char> pauli_terms
) {
    // Ensure 'I' is the first in the pauli terms 
    if (std::find(pauli_terms.begin(), pauli_terms.end(), 'I') != pauli_terms.begin()) {
        if (std::find(pauli_terms.begin(), pauli_terms.end(), 'I') != pauli_terms.end()) 
            pauli_terms.erase(std::find(pauli_terms.begin(), pauli_terms.end(), 'I')); 
        pauli_terms.insert(pauli_terms.begin(), 'I'); 
        // std::cout << "shouldn't happend for now \n"; 
    }

    std::vector<Pauli> _paulis;
    std::vector<double> _weights;
    int w = static_cast<int>(std::pow(pauli_terms.size(), support.size())) - 1;

    _weights.push_back(1.0 - probability);
    for (int i = 0; i < w; ++i) {
        _weights.push_back(probability / w);
    }

    std::vector<std::vector<char>> combined_terms;
    cartesian_product(pauli_terms, support.size(), combined_terms);

    // std::cout << "after the cartesian_product: \n"; 
    // for (const std::vector<char>& term: combined_terms) 
    // {
    //     for (char c: term) std::cout << c; 
    //     std::cout << "\n"; 
    // }
        
    for (const std::vector<char>& term_seq : combined_terms) {
        std::vector<std::pair<char, int>> zipped;
        for (int i = 0; i < (int) support.size(); ++i) {
            int index = *std::next(support.begin(), i); 
            std::pair<char, int> zip(term_seq[i], index); 
            zipped.push_back(zip);
        }
        // std::cout << "The pushed pauli: " << Pauli(zipped) << "\n"; 
        _paulis.push_back(Pauli(zipped));
    }

    paulis = _paulis;
    weights = _weights; 
}

std::set<int> Error::support() const {
    std::set<int> res; 
    for (const Pauli& P : paulis) {
        std::set<int> supp = P.support(); 
        res.insert(supp.begin(), supp.end()); 
    }
    return res; 
}   

int Error::weight() const {
    return support().size(); 
}

int Error::qubits() const {
    const std::set<int>& supp = support(); 
    return supp.empty() ? 0 : *supp.rbegin(); // reverse begin points to the last and hence largest element
}

void Error::permute(const Permutation& perm) {
    for (Pauli P: paulis) {
        P.permute(perm); 
    }
}

Error commute(const Error& E, const Clifford& C) {
    std::vector<Pauli> new_paulis;
    for (const Pauli& P : E.paulis) {
        new_paulis.push_back(commute(P, C.pauli)); 
    }
    return Error(new_paulis, E.weights);  
}

Pauli commute(const Pauli& P, const Clifford& C) {
    return commute(P, C.pauli); 
}

Error commute(const Error& E1, const Error& E2) {
    return E1; 
}

Error commute(const Error& E, const Measure& M) {
    return E; 
}

Error commute(const Error& E, const Reset& R) {
    std::vector<Pauli> new_paulis; 
    int q = R.qubits(); 
    for (Pauli P : E.paulis) {
        P.delete_term(q);
        new_paulis.push_back(P);
    }
    return Error(new_paulis, E.weights); 
}

Error commute_back(const Error& E, const Clifford& C) {
    std::vector<Pauli> new_paulis;
    for (const Pauli& P : E.paulis) {
        new_paulis.push_back(commute(P, C.pauli)); 
    }
    return Error(new_paulis, E.weights);  
}

Error commute_back(const Error& E1, const Error& E2) {
    return E1; 
}

// an Error will only commute backwards with a measurement if the measurement does not measure the 
Error commute_back(const Error& E, const Measure& M) {
    throw std::invalid_argument("Cannot commute an error back through a measure on the same qubit"); 
}

Error commute_back(const Error& E, const Reset& R) {
    throw std::invalid_argument("Cannot commute an error back through a reset on the same qubit"); 
}

std::ostream& operator<<(std::ostream& os, const Error& E) {
    int q = E.qubits(); 
    for (int i = 0; i < (int) E.paulis.size(); ++i) {
        os << " E | " << fixed_length_string(E.paulis[i], q) << " | " << std::to_string(E.weights.get(i));
        if (i != (int)E.paulis.size() - 1) {
            os << "\n";
        }
    }
    return os; 
}

std::string fixed_length_string(const Error& E, int qubits) {
    std::string str = " E | "; 
    std::set<int> supp = E.support(); 
    int index = 1; 
    while (index <= qubits) {
        if (supp.find(index) != supp.end()) str += "E"; 
        else str += "."; 
        ++index; 
    }
    str += " | " + std::to_string(1 - E.weights.get(0)); 
    return str; 
}

bool operator<(const Operator& op1, const Operator& op2) {
    if (std::holds_alternative<Reset>(op1) && std::holds_alternative<Reset>(op2)) {
        return std::get<Reset>(op1) < std::get<Reset> (op2); 
    }
    else if (std::holds_alternative<Measure>(op1) && std::holds_alternative<Measure>(op2))
        return std::get<Measure>(op1) < std::get<Measure>(op2);
    else if (std::holds_alternative<Clifford>(op1) && std::holds_alternative<Clifford>(op2))
        return std::get<Clifford>(op1) < std::get<Clifford>(op2);
    else if (std::holds_alternative<Error>(op1) && std::holds_alternative<Error>(op2)) 
        return std::get<Error>(op1) < std::get<Error>(op2);
    else
        throw std::invalid_argument("Must compare two operators of the same type"); 
}

std::ostream& operator<<(std::ostream& os, const Operator& op) {
    if (std::holds_alternative<Reset>(op)) 
        os << std::get<Reset> (op); 
    else if (std::holds_alternative<Measure>(op))
        os << std::get<Measure>(op);
    else if (std::holds_alternative<Clifford>(op))
        os << std::get<Clifford>(op);
    else if (std::holds_alternative<Error>(op)) 
        os << std::get<Error>(op);
    return os; 
}

std::string fixed_length_string(const Operator& op, int qubits) {
    if (std::holds_alternative<Reset>(op)) 
        return fixed_length_string(std::get<Reset>(op), qubits); 
    else if (std::holds_alternative<Measure>(op))
        return fixed_length_string(std::get<Measure>(op), qubits);
    else if (std::holds_alternative<Clifford>(op)) {
        return fixed_length_string(std::get<Clifford>(op), qubits);
    }
    else if (std::holds_alternative<Error>(op)) 
        return fixed_length_string(std::get<Error>(op), qubits);
    throw std::logic_error("The Operator must be one of: Reset, Measure, Clifford, or Error"); 
}

// helper functions

// outputs the cartesian product of length lists
void cartesian_product(
    const std::vector<char>& lst,
    int n,
    std::vector<std::vector<char>>& result
) {
    int choices = lst.size();
    std::vector<int> indices(n, 0);
    std::vector<char> current(n, 'I');
    int pos = 0; 
    // int j = 0; 
    while (true) {
        // std::cout << pos << "\n";
        // std::cout << indices[pos] << "\n";  
        while (indices[pos] <= choices - 1) {
            current[pos] = lst[indices[pos]]; 
            result.push_back(current);
            ++indices[pos];
        }
        --indices[pos]; // make it go back to choices - 1
        while (pos < n && indices[pos] == choices - 1) ++pos; 
        // std::cout << pos << "\n";
        if (pos == n) break; 
        else {
            ++indices[pos]; 
            for (int i = 0; i < pos; ++i) {
                indices[i] = 0; 
                current[i] = 'I'; 
            }
            current[pos] = lst[indices[pos]]; 
            pos = 0; 
        }
        // std::cout << "new loop\n"; 
        // ++j; 
    }
}

// int main() {
//     std::vector<std::vector<char>> combined_terms;
//     int count = 0; 
//     cartesian_product({'I', 'X', 'Y', 'Z'}, 3, combined_terms); 
//     for (std::vector<char> lst : combined_terms) {
//         for (char c : lst) std::cout << c; 
//         std::cout << "\n"; 
//         ++count; 
//     }
//     std::cout << count;  
// }
</file>

<file path="Operator.h">
#ifndef _QULIA_OPERATOR
#define _QULIA_OPERATOR

#include "Pauli.h"
#include "Weights.h"
#include <variant>

// struct Operator {
//     // enum class Type {CLIFFORD, RESET, MEASURE, ERROR}; 
//     // Type ty; 
//     // union {
//     //     Clifford clifford; 
//     //     Reset reset;
//     //     Measure measure; 
//     //     Error error;
//     // }; 
//     // // constructors
//     // Operator(const Clifford& c) : ty(Type::CLIFFORD) { new(&clifford) Clifford(c); }
//     // Operator(const Reset& r) : ty(Type::RESET) { new(&reset) Reset(r); }
//     // Operator(const Measure& m) : ty(Type::MEASURE) { new(&measure) Measure(m); }
//     // Operator(const Error& e) : ty(Type::ERROR) { new(&error) Error(e); }

//     // // destructor
//     // ~Operator() {
//     //     switch (ty) {
//     //         case Type::CLIFFORD: clifford.~Clifford(); break;
//     //         case Type::RESET: reset.~Reset(); break;
//     //         case Type::MEASURE: measure.~Measure(); break;
//     //         case Type::ERROR: error.~Error(); break;
//     //     }
//     // }

//     std::variant<Clifford, Reset, Measure, Error> op;
//     Operator(const Clifford& c) : op(c) {}
//     Operator(const Reset& r) : op(r) {}
//     Operator(const Measure& m) : op(m) {}
//     Operator(const Error& e) : op(e) {}
// }; 

struct Clifford {
    Pauli pauli; 

    Clifford(const Pauli& P) : pauli(P) {}
    Clifford(const Clifford&) = default;
    Clifford& operator=(const Clifford&) = default;
    Clifford() = default; 
    template <typename T>
    Clifford(T any)
        : Clifford(Pauli(any)) {}

    std::set<int> support() const; 
    int weight() const; 
    int qubits() const; 
    void permute(const Permutation& perm); 
    bool operator<(const Clifford& C) const; 
} ; 
 
Clifford random_Clifford(
    std::optional<int> qubits=std::nullopt, 
    std::optional<double> probability=std::nullopt, 
    std::optional<int> max_weight=std::nullopt,
    std::optional<int> exact_weight=std::nullopt,
    std::optional<std::set<int>> max_support=std::nullopt,
    std::optional<std::set<int>> exact_support=std::nullopt,
    std::vector<char> pauli_terms = {'I', 'X', 'Y', 'Z'}
); 

struct Reset {
    Pauli pauli; 

    Reset(const Pauli& P) : pauli(P.weight() == 1 ? P : throw std::invalid_argument("Reset only valid for single-qubit Pauli")) {}
    Reset(const Reset&) = default;
    Reset& operator=(const Reset&) = default;
    Reset() = default; 
    Reset(int index);
    Reset(const std::string& pauli_string); 

    std::set<int> support() const;
    int weight() const; 
    int qubits() const; 
    void permute(const Permutation& perm); 
    bool operator<(const Reset& R) const; 
} ;

struct Measure {
    Pauli pauli; 
    bool sign; 
    double probability; 

    Measure() = default; 
    Measure(const Measure&) = default;
    Measure& operator=(const Measure&) = default;
    Measure(const Pauli& P, bool sgn=false, double prob=0) : 
            pauli(P), sign(sgn), probability((0 <= prob && prob <= 1) ? prob : throw std::invalid_argument("Probability must be between 0 and 1")) {}
    template <typename T>
    Measure(T any, bool sign=false, double probability=0) 
        : Measure(Pauli(any), sign, probability) {}
    

    std::set<int> support() const;
    int weight() const; 
    int qubits() const;  
    void permute(const Permutation& perm); 
    bool operator<(const Measure& M) const; 
} ;

struct Error {
    std::vector<Pauli> paulis;
    Weights weights;  

    Error() = default; 
    Error(const Error&) = default;
    Error& operator=(const Error&) = default;
    Error(const std::vector<Pauli>& Ps, const Weights& w) : 
        paulis(Ps), weights(Ps.size() == w.size() ? w : throw std::invalid_argument("unmatched length")) {}
    Error(const Pauli& P);
    Error(const Reset& R);
    Error(const Measure& M);
    template <typename T>
    Error(T any) 
        : Error(Pauli(any)) {}
    

    // simplified model where every non-identity Pauli errors occur with the same probability 
    Error(
        double probability, // probability that an error will occur (i.e. not just identity)
        const std::set<int>& support, 
        std::vector<char> pauli_terms = {'I', 'X', 'Y', 'Z'}
    );

    std::set<int> support() const;
    int weight() const; 
    int qubits() const; 
    void permute(const Permutation& perm); 
} ;

// define Operator which is composed of Clifford, Reset, Measure, and Error
using Operator = std::variant<Clifford, Reset, Measure, Error>;

Clifford commute(const Clifford& C, const Reset& R); 
Pauli commute(const Pauli& P, const Clifford& C);
std::ostream& operator<<(std::ostream& os, const Clifford& C); 
std::string fixed_length_string(const Clifford& C, int qubits);

std::ostream& operator<<(std::ostream& os, const Reset& R); 
std::string fixed_length_string(const Reset& R, int qubits);
Reset commute(const Reset& R1, const Reset& R2); 
Pauli commute(const Pauli& P, const Reset& R); 

Measure commute(const Measure& M, const Reset& op);

std::ostream& operator<<(std::ostream& os, const Measure& M); 
std::string fixed_length_string(const Measure& M, int qubits);

Error commute(const Error& E, const Clifford& C);
Error commute(const Error& E1, const Error& E2); 
Error commute(const Error& E, const Measure& M); 
Error commute(const Error& E, const Reset& R); 
Error commute_back(const Error& E, const Clifford& C); 
Error commute_back(const Error& E1, const Error& E2); 
Error commute_back(const Error& E, const Measure& M); 
Error commute_back(const Error& E, const Reset& R); 
std::ostream& operator<<(std::ostream& os, const Error& E); 
std::string fixed_length_string(const Error& E, int qubits);  

bool operator<(const Operator& op1, const Operator& op2); 
std::ostream& operator<<(std::ostream& os, const Operator& op);
std::string fixed_length_string(const Operator& op, int qubits);  

// helper function 

void cartesian_product(
    const std::vector<char>& lst,
    int n,
    std::vector<std::vector<char>>& result
); 

#endif
</file>

<file path="Pauli.cc">
#include "Pauli.h"

Pauli::Pauli(const std::set<int> &xval, const std::set<int> &zval) {
    x = xval; 
    y = binary_XOR(xval, zval); 
    z = zval; 
}

Pauli::Pauli(const std::vector<std::pair<char, int>>& pauli_tuples) {
    std::set<int> _x, _y, _z;
    for (std::pair<char, int> tuple : pauli_tuples)
    {
        if (std::toupper(tuple.first) == 'X')
        {
            binary_XOR(_y, tuple.second); 
            binary_XOR(_z, tuple.second); 
        }
        else if (std::toupper(tuple.first) == 'Y')
        {
            binary_XOR(_x, tuple.second); 
            binary_XOR(_z, tuple.second);
        }
        else if (std::toupper(tuple.first) == 'Z')
        {
            binary_XOR(_x, tuple.second); 
            binary_XOR(_y, tuple.second); 
        }
    }
    x = _x; 
    y = _y; 
    z = _z; 
}

Pauli::Pauli(const std::string& pauli_string) {
    std::set<int> _x, _y, _z;
    std::vector<std::string> terms = split_terms(pauli_string);
    for (const std::string& term : terms) {
        auto [str, index] = split_pauli_term(term);
        std::transform(str.begin(), str.end(), str.begin(), ::toupper);
        if (str == "X") {
            binary_XOR(_y, index);
            binary_XOR(_z, index);
        } else if (str == "Y") {
            binary_XOR(_x, index);
            binary_XOR(_z, index);
        } else if (str == "Z") {
            binary_XOR(_x, index);
            binary_XOR(_y, index);
        }
    }
    x = _x; 
    y = _y; 
    z = _z; 
}

Pauli::Pauli(const std::vector<std::string>& pauli_strings) {
    std::set<int> _x, _y, _z;

    for (const std::string& pauli_string : pauli_strings) {
        std::vector<std::string> terms = split_terms(pauli_string);
        for (const std::string& term : terms) {
            auto [str, index] = split_pauli_term(term);
            std::transform(str.begin(), str.end(), str.begin(), ::toupper);
            if (str == "X") {
                binary_XOR(_y, index);
                binary_XOR(_z, index);
            } else if (str == "Y") {
                binary_XOR(_x, index);
                binary_XOR(_z, index);
            } else if (str == "Z") {
                binary_XOR(_x, index);
                binary_XOR(_y, index);
            }
        }
    }
    x = _x; 
    y = _y; 
    z = _z;
}

std::ostream& operator<<(std::ostream& os, const Pauli& P) {
    if (P.isI()) os << "I"; 
    
    const std::set<int>& supp = P.support(); 
    for (int index: supp) {
        if (P.y.find(index) != P.y.end() && P.z.find(index) != P.z.end()) 
            os << "X" << std::to_string(index); 
        else if (P.x.find(index) != P.x.end() && P.z.find(index) != P.z.end())
            os << "Y" << std::to_string(index); 
        else if (P.y.find(index) != P.y.end() && P.x.find(index) != P.x.end())
            os << "Z" << std::to_string(index); 
        if (index != *supp.rbegin()) os << " "; 
    }
    return os; 
} 

std::string string(const Pauli& P) {
    std::string str = "";
    if (P.isI())
        str += "I";
    const std::set<int>& supp = P.support(); 
    for (int index: supp) {
        if (P.y.find(index) != P.y.end() && P.z.find(index) != P.z.end()) 
            str += "X" + std::to_string(index); 
        else if (P.x.find(index) != P.x.end() && P.z.find(index) != P.z.end())
            str += "Y" + std::to_string(index); 
        else if (P.y.find(index) != P.y.end() && P.x.find(index) != P.x.end())
            str += "Z" + std::to_string(index);
        if (index != *supp.rbegin()) str += " "; 
    }
    return str; 
}

std::string fixed_length_string(const Pauli& P, int qubits) {
    std::string str = ""; 
    int index = 1; 
    while (index <= qubits) {
        if (P.y.find(index) != P.y.end() && P.z.find(index) != P.z.end()) 
            str += "X"; 
        else if (P.x.find(index) != P.x.end() && P.z.find(index) != P.z.end())
            str += "Y"; 
        else if (P.y.find(index) != P.y.end() && P.x.find(index) != P.x.end())
            str += "Z";
        else 
            str += "."; 
        ++index; 
    }
    return str; 
}

void Pauli::set_index(char c, int index) {
    if (std::toupper(c) == 'X') {
        x.erase(index); 
        y.insert(index);
        z.insert(index);
    } else if (std::toupper(c) == 'Y') {
        x.insert(index); 
        y.erase(index);
        z.insert(index);
    } else if (std::toupper(c) == 'Z') {
        x.insert(index); 
        y.insert(index);
        z.erase(index);
    }
}

void Pauli::delete_term(int index) {
    x.erase(index); 
    y.erase(index); 
    z.erase(index);
}

char Pauli::operator[](int index) const {
    if (y.find(index) != y.end() && z.find(index) != z.end()) 
        return 'X'; 
    else if (x.find(index) != x.end() && z.find(index) != z.end())
        return 'Y'; 
    else if (y.find(index) != y.end() && x.find(index) != x.end())
        return 'Z';
    else
        return 'I'; 
}

bool Pauli::operator<(const Pauli& P) const {
    if (P.isI()) return false; 
    else if (isI()) return true; 
    int i1, i2; 
    if (x.empty()) i1 = *y.begin(); 
    else if (y.empty()) i1 = *z.begin(); 
    else if (z.empty()) i1 = *x.begin(); 
    else i1 = std::min({*x.begin(), *y.begin(), *z.begin()}); 
    if (P.x.empty()) i2 = *P.y.begin(); 
    else if (P.y.empty()) i2 = *P.z.begin();
    else if (P.z.empty()) i2 = *P.x.begin(); 
    else i2 = std::min({*(P.x.begin()), *P.y.begin(), *P.z.begin()}); 
    // std::cout << "With the new method: " << P << " " << i1 << " " << i2 << std::endl;
    // i1 = *support().begin(); 
    // i2 = *P.support().begin(); 
    // std::cout << "With the old method: " << P << " " << i1 << " " << i2 << std::endl;
    return (i1 > i2) || ((i1 == i2) && ((*this)[i1] < P[i1])); 
}

Pauli Pauli::operator*(const Pauli& P) const {
    return Pauli(binary_XOR(x, P.x), binary_XOR(y, P.y), binary_XOR(z, P.z)); 
}

Pauli& Pauli::operator*=(const Pauli& P) {
    x = binary_XOR(x, P.x); 
    y = binary_XOR(y, P.y); 
    z = binary_XOR(z, P.z); 
    return *this; 
}

Pauli Pauli::operator^(bool b) const {
    return b ? Pauli(x, y, z) : Pauli(); 
}

bool Pauli::operator%(const Pauli& P) const { // symplectic inner prod
    return std::abs((int)(set_intersect(x, P.z).size() - set_intersect(z, P.x).size()) % 2); 
}

Pauli commute(const Pauli& P1, const Pauli& P2) {
    return P1 * (P2^(P1 % P2)); 
}

Pauli commute_back(const Pauli& P1, const Pauli& P2) {
    return P1 * (P2^(P1 % P2)); 
}

void Pauli::permute(Permutation perm) {
    perm.permute(x); 
    perm.permute(y); 
    perm.permute(z); 
}

std::vector<Pauli> Pauli::basis_rep() const {
    std::vector<Pauli> elements; 
    if (isI()) return elements; 
    const std::set<int>& supp = support(); 
    elements.reserve(supp.size() * 2); 

    std::set<int>::iterator it_x = x.begin();
    std::set<int>::iterator it_y = y.begin();
    std::set<int>::iterator it_z = z.begin();
    std::set<int>::iterator it_s = supp.begin();
    std::set<int>::const_iterator end_x = x.end();
    std::set<int>::const_iterator end_y = y.end();
    std::set<int>::const_iterator end_z = z.end();

    for (; it_s != supp.end(); ++it_s) {
        int index = *it_s; 
        while (it_x != end_x && *it_x < index) ++it_x;
        while (it_y != end_y && *it_y < index) ++it_y;
        while (it_z != end_z && *it_z < index) ++it_z;
        bool inX = (it_x != end_x && *it_x == index);
        bool inY = (it_y != end_y && *it_y == index);
        bool inZ = (it_z != end_z && *it_z == index);

        if (inX && inZ) {
            elements.emplace_back(Pauli({}, {index}, {index}));
            elements.emplace_back(Pauli({index}, {index}, {}));
        }
        else if (inZ && inY) {
            elements.emplace_back(Pauli({}, {index}, {index}));
        }
        else if (inX && inY) {
            elements.emplace_back(Pauli({index}, {index}, {}));
        }
        else {
            throw std::logic_error("An index in support appears in only one set for a Pauli");
        }
    }
    return elements; 
}

bool Pauli::isI() const {
    return x.empty() && y.empty() && z.empty();
}

bool Pauli::isIX() const {
    return x.empty();
}

bool Pauli::isIY() const {
    return y.empty();
}

bool Pauli::isIZ() const {
    return z.empty();
}

// index of non-identity qubits 
std::set<int> Pauli::support() const {
    // for (int i : x) std::cout << i << std::endl; 
    // for (int i : y) std::cout << i << std::endl; 
    // for (int i : z) std::cout << i << std::endl;
    return set_union(x, set_union(y, z)); 
}

int Pauli::weight() const {
    return support().size(); 
}

// returns the index of the largest qubit used  
int Pauli::qubits() const {
    std::set<int> supp = support(); 
    return supp.empty() ? 0 : *supp.rbegin(); // reverse begin returns the index of the last and largest element 
}

Pauli random_Pauli(
    std::optional<int> qubits, 
    std::optional<double> probability, 
    std::optional<int> max_weight,
    std::optional<int> exact_weight,
    std::optional<std::set<int>> max_support,
    std::optional<std::set<int>> exact_support,
    std::vector<char> pauli_terms
) {
    if (!qubits && !max_support && !exact_support) 
        throw std::invalid_argument("Must input qubits or support"); 
    int q = !qubits ? std::max(
        max_support ? max_support->size() : 0, 
        exact_support ? exact_support->size() : 0) : *qubits; 

    double prob = probability ? *probability : 0.75;

    int binom_n = max_weight ? *max_weight : q;     
    std::binomial_distribution<> dist(binom_n, prob);
    static std::mt19937 rng{std::random_device{}()};
    int weight = exact_weight ? *exact_weight : dist(rng);
    std::set<int> max_supp = max_support ? *max_support : 
                                [q] {
                                    std::set<int> s;
                                    for (int i = 1; i <= q; ++i)
                                        s.insert(i);
                                    return s;
                                }();
    std::set<int> support = exact_support ? * exact_support : 
                                [max_supp, weight] { // samples a subset of indices w/o replacement from max_supp
                                    std::vector<int> copied(max_supp.begin(), max_supp.end()); 
                                    std::vector<int> sampled;
                                    std::sample(copied.begin(), copied.end(),std::back_inserter(sampled), 
                                        std::min(weight, (int) max_supp.size()), std::mt19937{std::random_device{}()});
                                    return std::set<int>(sampled.begin(), sampled.end()); 
                                }();

    std::vector<std::pair<char, int>> result;
    std::uniform_int_distribution<> pauli_dist(0, pauli_terms.size() - 1); 
    std::mt19937 gen(std::random_device{}()); 
    for (int index : support) {
        result.emplace_back(pauli_terms[pauli_dist(gen)], index);
    }

    return Pauli(result);
}

// helper functions 

std::set<int> set_union(const std::set<int>& s1, const std::set<int>& s2) {
    std::vector<int> s; 
    // std::set<int>::iterator itr1 = s1.begin();
    // std::set<int>::iterator itr2 = s2.begin();
    // while (itr1 != s1.end() && itr2 != s2.end()) {
    //     if (*itr1 < *itr2) {
    //         s.insert(s.end(), *itr1); 
    //         ++itr1; 
    //     }
    //     else if (*itr1 > *itr2) {
    //         s.insert(s.end(), *itr2); 
    //         ++itr2;
    //     } else {
    //         s.insert(s.end(), *itr1); 
    //         ++itr1; 
    //         ++itr2; 
    //     }
    // } 
    // while (itr1 != s1.end()) {
    //     s.insert(s.end(), *itr1); 
    //     ++itr1;  
    // }
    // while (itr2 != s2.end()) {
    //     s.insert(s.end(), *itr2); 
    //     ++itr2; 
    // }
    std::set_union(s1.cbegin(), s1.cend(),
                s2.cbegin(), s2.cend(),
                std::back_inserter(s));
    return std::set<int> (s.begin(), s.end()); 
}

std::set<int> set_intersect(const std::set<int>& s1, const std::set<int>& s2) {
    std::set<int> res; 
    std::set_intersection(
        s1.begin(), s1.end(),
        s2.begin(), s2.end(),
        std::inserter(res, res.begin())
    );
    return res; 
}

// ⊻ in the Julia code
std::set<int> binary_XOR(const std::set<int>& s1, const std::set<int>& s2) {
    std::set<int> res; 
    std::set_symmetric_difference(
        s1.begin(), s1.end(), 
        s2.begin(), s2.end(),
        std::inserter(res, res.end())
    ); 
    // std::set<int> s; 
    // std::set<int>::iterator itr1 = s1.begin();
    // std::set<int>::iterator itr2 = s2.begin();
    // while (itr1 != s1.end() && itr2 != s2.end()) {
    //     if (*itr1 < *itr2) {
    //         s.insert(s.end(), *itr1); 
    //         ++itr1; 
    //     }
    //     else if (*itr1 > *itr2) {
    //         s.insert(s.end(), *itr2); 
    //         ++itr2;
    //     } else {
    //         ++itr1; 
    //         ++itr2; 
    //     }
    // } 
    // if (itr1 != s1.end()) s.insert(itr1, s1.end()); 
    // else s.insert(itr2, s2.end()); 
    return res; 
}

// ⊻ in the Julia code
void binary_XOR(std::set<int>& s, int index) { // verify that this is fine 
    if (s.erase(index) == 0) s.insert(index); 
}

// Split the pauli string by space (split(pauli_string) in the Julia code)
std::vector<std::string> split_terms(const std::string& s) {
    std::istringstream iss(s);
    std::vector<std::string> terms;
    std::string term;
    while (iss >> term)
        terms.push_back(term);
    return terms;
}

// Split "X1" into {"X", "1"} or "10Z" into {"10", "Z"} using regex 
// (split(pauli_term, r"(?<=\d)(?=\D)|(?<=\D)(?=\d)") in the Julia code) 
std::pair<std::string, int> split_pauli_term(const std::string& term) {
    std::regex re(R"((\D+)(\d+)|(\d+)(\D+))");
    std::smatch match;
    if (std::regex_match(term, match, re)) {
        if (match[1].matched && match[2].matched)
            return {match[1], std::stoi(match[2])};
        else
            return {match[4], std::stoi(match[3])};
    } else {
        throw std::invalid_argument("Invalid Pauli term format: " + term);
    }
}
</file>

<file path="Pauli.h">
#ifndef _QULIA_PAULI
#define _QULIA_PAULI

#include "Permutation.h"

#include <sstream>
#include <iostream>
#include <cstring>
#include <vector>
#include <set>
#include <optional>
#include <random>
#include <regex>
#include <numeric>

struct Pauli {
    // using sets instead of vectors so everything will be in sorted order
    std::set<int> x; // ones in the second half of the rep
    std::set<int> y; // add the two halfs of the rep
    std::set<int> z; // ones in the first half of the rep

    Pauli() = default; 
    Pauli(const Pauli&) = default;
    Pauli& operator=(const Pauli&) = default;
    Pauli(const std::set<int>& xval, const std::set<int>& yval, const std::set<int>& zval) 
        : x(xval), y(yval), z(zval) {} 
    Pauli(const std::set<int> &xval, const std::set<int> &zval);
    Pauli(const std::vector<std::pair<char, int>>& pauli_tuples); 
    Pauli(const std::string& pauli_string); 
    Pauli(const std::vector<std::string>& pauli_strings); 

    void set_index(char c, int index); 
    void delete_term(int index); 
    bool operator<(const Pauli& P) const; 
    char operator[](int index) const;
    Pauli operator*(const Pauli& P) const; 
    Pauli& operator*=(const Pauli& P); 
    Pauli operator^(bool b) const; 
    bool operator%(const Pauli& P) const; // sym inner prod 
    void permute(Permutation perm); 
    std::vector<Pauli> basis_rep() const; 

    bool isI() const;
    bool isIX() const;
    bool isIY() const; 
    bool isIZ() const;

    std::set<int> support() const; 
    int weight() const; 
    int qubits() const; 
}; 

std::string string(const Pauli& P); 
Pauli commute(const Pauli& P1, const Pauli& P2);
Pauli commute_back(const Pauli& P1, const Pauli& P2); 
Pauli random_Pauli(
    std::optional<int> qubits=std::nullopt, 
    std::optional<double> probability=std::nullopt, 
    std::optional<int> max_weight=std::nullopt,
    std::optional<int> exact_weight=std::nullopt,
    std::optional<std::set<int>> max_support=std::nullopt,
    std::optional<std::set<int>> exact_support=std::nullopt,
    std::vector<char> pauli_terms = {'X', 'Y', 'Z'}
); 
std::ostream& operator<<(std::ostream& os, const Pauli& P); 
std::string fixed_length_string(const Pauli& P, int qubits);  

// helper functions

std::set<int> set_union(const std::set<int>& s1, const std::set<int>& s2);
std::set<int> set_intersect(const std::set<int>& s1, const std::set<int>& s2);
std::set<int> binary_XOR(const std::set<int>& s1, const std::set<int>& s2);
void binary_XOR(std::set<int>& s, int index);
std::vector<std::string> split_terms(const std::string& s);
std::pair<std::string, int> split_pauli_term(const std::string& term); 

#endif
</file>

<file path="Permutation.cc">
#include "Permutation.h"

Permutation::Permutation(const std::vector<std::vector<int>>& cy) {
    for (const std::vector<int>& cycle : cy) {
        std::set<int> unique(cycle.begin(), cycle.end());
        if (unique.size() != cycle.size()) {
            throw std::invalid_argument("Cycles cannot have repeated elements");
        }
    }
    cycles = cy;
}

Permutation::Permutation(const std::initializer_list<std::vector<int>>& cycles) {
    Permutation(std::vector<std::vector<int>> (cycles)); 
}

Permutation::Permutation(const std::initializer_list<int>& indices) {
    Permutation(std::vector<std::vector<int>>{ std::vector<int> (indices)}); 
}

int Permutation::operator[](int index) const {
    for (const std::vector<int>& cycle : cycles) {
        std::vector<int>::const_iterator it = std::find(cycle.begin(), cycle.end(), index);
        if (it != cycle.end()) {
            if (it + 1 == cycle.end()) {
                return cycle.front();  
            } else {
                return *(it + 1);  
            }
        }
    }
    return index;  
}

int Permutation::permute(int i) const{ // permute! in the original code: doesn't change the struct?
    return (*this)[i]; 
}

void Permutation::permute(std::vector<int>& V) const {
    std::transform(V.begin(), V.end(), V.begin(), [this] (int x) {return this->permute(x);}); 
}

void Permutation::permute(std::set<int>& V) const {
    std::set<int> res; 
    for (int x : V) res.insert(this->permute(x)); 
    V = std::move(res); 
}

std::set<int> Permutation::permute(const std::set<int>& S) const {
    std::set<int> set; 
    for (int i : S) set.insert((*this)[i]); 
    return S; 
}
</file>

<file path="Permutation.h">
#ifndef _QULIA_PERMUTATION
#define _QULIA_PERMUTATION

#include <vector>
#include <set>
#include <regex>

struct Permutation {
    std::vector<std::vector<int>> cycles; 

    Permutation() = default; 
    Permutation(const Permutation&) = default; 
    Permutation& operator=(const Permutation&) = default; 
    Permutation(const std::vector<std::vector<int>>& cy);
    Permutation(const std::initializer_list<std::vector<int>>& cycles);
    Permutation(const std::initializer_list<int>& indices);

    int operator[](int index) const; 
    int permute(int i) const; // permute! in the original code: doesn't change the struct?
    void permute(std::vector<int>& V) const;
    void permute(std::set<int>& V) const;
    std::set<int> permute(const std::set<int>& S) const; 
} ; 

#endif
</file>

<file path="SampleCircuit.cc">
#include "SampleCircuit.h"

// SampleOperators

int SampleOperator::length() const {
    return flips.size(); 
}

int SampleOperator::measurements() const {
    return (*flips.begin()).size(); 
}

bool SampleOperator::iszero() const {
    for (std::vector<bool> measurement : flips)
        for (bool flip: measurement)
            if (flip) return false; 
    return true; 
}

// randomly picks a bit string for that operator
std::vector<bool> SampleOperator::measure() const {
    // std::cout << "inside picking a bitstring for operator \n" ; 
    // std::cout << "size of flips" << flips.size() << "\n"; 
    // std::cout << "size of weights" << weights.size() << "\n"; 
    // std::cout << "total weight: " << weights.total() << "\n"; 
    std::mt19937 gen(std::random_device{}());
    // std::cout << "still valid \n"; 
    std::discrete_distribution<> dist(weights.begin(), weights.end());
    // std::cout << "still valid \n"; 
    // std::cout << "exiting picking a bitstring for operator \n" ; 
    return flips[dist(gen)]; 
}

std::ostream& operator<<(std::ostream& os, const SampleOperator& op) {
    int index = 0; 
    while (index < op.length()) {
        os << op.flips[index] << " " << std::to_string(op.weights.get(index)); 
        if (index != op.length() - 1) os << "\n"; 
        ++index; 
    }
    return os; 
}

// SampleCircuits

SampleCircuit::SampleCircuit(const std::vector<SampleOperator>& _samples) {
    int mlength = _samples.begin()->measurements(); 
    for (std::vector<SampleOperator>::const_iterator it = _samples.begin() + 1; it <= _samples.end(); ++it) {
        if (it->measurements() != mlength) throw std::invalid_argument("not of the same length"); 
    }
    samples = _samples; 
}

SampleCircuit::SampleCircuit(const Circuit& circ, bool ancilla_measures) {
    Circuit modified_circ = circ; 
    if (ancilla_measures) modified_circ.extract_measures(); 
    modified_circ.add_resets();
    if (!ancilla_measures) modified_circ.add_measure_errors(); 
    modified_circ.reorder(); 
    modified_circ.add_reset_errors(); 
    std::cout << "The fully modified circuit: " << "\n" << modified_circ; 
    SampleCircuit sample_circ = SampleCircuit(); 
    int m = modified_circ.measurements(); 
    int m_index = 0; 
    for (int index = 0; index < (int) modified_circ.operators.size(); ++index) {
        Operator op1 = modified_circ[index]; 
        // run each error through (the rest of) the circuit and determine its bit flips 
        // i.e. flips is all zero initally and if the error does not commute with the measurement, 
        // a bit flip occurs on the specified bit and you record the new bit flips for that measurement
        // for all other operators, you pull the error through and update it by commuting it with the next operator
        if (std::holds_alternative<Error>(op1)) {
            Error E = std::get<Error>(op1); 
            std::vector<std::vector<bool>> flips;
            // initalizes all flips to 0; same number of Paulis as the bitarrays 
            for (int i = 0; i < (int) E.paulis.size(); ++i) {
                flips.push_back(std::vector<bool>(m, false));
            }
            int m_index2 = 0;
            // checks all operators that comes after this error
            for (int i = index + 1; i < (int) modified_circ.operators.size(); ++i) {
                const Operator& op2 = modified_circ.operators[i];
                if (std::holds_alternative<Measure>(op2)) {
                    const Measure& M = std::get<Measure>(op2);
                    for (int j = 0; j < (int) E.paulis.size(); ++j) {
                        flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
                    }
                    ++m_index2;
                }
                // std::cout << "Before commuting error: " << E.paulis[1] << "\n"; 

                // std::visit([E](const auto& _op2) {std::cout << "Commuting with: " << _op2 <<"\n"; }, op2);
                E = std::visit([E](const auto& _op2) {return commute(E, _op2); }, op2);
                // std::cout << "After commuting error: " << E << "\n"; 
            }
            // std::cout << "In construction of samplecircuit with error: " << E << "\n"; 
            // std::cout<< "and sample error: " << SampleOperator(flips, E.weights) << "\n"; 
            sample_circ.push(SampleOperator(flips, E.weights));
        // for each measurement, adds a bitflip at the measurement qubit with some given probability  
        } else if (std::holds_alternative<Measure>(op1)) {
            std::vector<std::vector<bool>> flips(2, std::vector<bool>(m, false));
            Measure M = std::get<Measure>(op1); 
            flips[1][m_index] = true;
            if (M.probability > 0) {
                sample_circ.push(SampleOperator(flips, Weights({1.0 - M.probability, M.probability})));
            }
            m_index += 1;
        }
    }
    sample_circ.reduce(); 
    samples = sample_circ.samples; 
}

int SampleCircuit::measurements() const {
    return samples[0].measurements(); 
}

void SampleCircuit::reduce() {
    int m = measurements(); 
    for (std::vector<SampleOperator>::iterator it = samples.begin(); it < samples.end();) {
        if (it->iszero()) samples.erase(it);
        else ++it;  
    } 
    if (samples.size() == 0) {
        std::vector<bool> no_flip(m, false); 
        std::vector<std::vector<bool>> sample = {no_flip}; 
        samples.push_back(SampleOperator(sample, Weights({1.0}))); 
    }
}

void SampleCircuit::push(const SampleOperator& sample_op) {
    samples.push_back(sample_op); 
}

std::vector<std::pair<std::vector<bool>, int64_t>> SampleCircuit::measure(int shots) const {
    std::unordered_map<std::vector<bool>, int64_t> sample;
    for (int i = 0; i < shots; ++i) {
        std::vector<bool> result = xor_reduce(samples);
        ++(sample[result]);
        if (i % 1000 == 0) std::cout << i << "\n"; 
    }

    // Convert to vector of pairs for sorting
    std::vector<std::pair<std::vector<bool>, int64_t>> sorted_counts(sample.begin(), sample.end());
    std::sort(sorted_counts.begin(), sorted_counts.end(), sort_criteria);

    return sorted_counts;
}

std::ostream& operator<<(std::ostream& os, const SampleCircuit& sample_circ) {
    for (std::vector<SampleOperator>::const_iterator it = sample_circ.samples.begin(); it < sample_circ.samples.end(); ++it) {
        os << *it; 
        os << "\n";
        if (it != sample_circ.samples.end() - 1) 
            os << std::string(sample_circ.measurements(), '-') << "\n"; 
    }
    return os; 
}

// helper functions
std::ostream& operator<<(std::ostream& os, const std::vector<bool>& vec) {
    for (int i = 0; i < (int) vec.size(); ++i)
        os << (vec[i] ? '1' : '0');
    return os;
}

size_t hamming_weight(const std::vector<bool>& v) {
    return std::count(v.begin(), v.end(), true);
}

bool sort_criteria(const std::pair<std::vector<bool>, int>& a,
                   const std::pair<std::vector<bool>, int>& b) {
    size_t ha = hamming_weight(a.first);
    size_t hb = hamming_weight(b.first);
    return (ha < hb) || (ha == hb && a.first < b.first);
}

// this is slow
std::vector<bool> xor_reduce(const std::vector<SampleOperator>& ops) {
    std::vector<bool> result = ops[0].measure();
    for (size_t i = 1; i < ops.size(); ++i) {
        std::vector<bool> flips = ops[i].measure();
        for (size_t j = 0; j < result.size(); ++j) {
            result[j] = (bool)flips[j] ^ (bool)result[j];
        }
    }
    return result;
}
</file>

<file path="SampleCircuit.h">
#ifndef _QUILIA_SAMPLECIRCUIT
#define _QUILIA_SAMPLECIRCUIT

#include "Circuit.h"

#include <unordered_map>

// should a BitArray / BitVector struct be defined?

struct SampleOperator {
    // 0 = false, 1 = true
    // for each operator, you store a array of strings of bitflips and the associated probability for each of them
    std::vector<std::vector<bool>> flips; 
    Weights weights; 

    SampleOperator() = default; 
    SampleOperator(const SampleOperator&) = default; 
    SampleOperator& operator=(const SampleOperator&) = default; 
    SampleOperator(const std::vector<std::vector<bool>>& _f, const Weights& _w) :
        flips(_f), weights(_f.size() == _w.size() ? _w : throw std::invalid_argument("not of equal lengths")) {}  

    int length() const; 
    int measurements() const; 
    bool iszero() const; 
    std::vector<bool> measure() const; 
} ; 

std::ostream& operator<<(std::ostream& os, const SampleOperator& op); 

struct SampleCircuit {
    std::vector<SampleOperator> samples; 

    SampleCircuit() = default; 
    SampleCircuit(const SampleCircuit&) = default; 
    SampleCircuit& operator=(const SampleCircuit&) = default; 
    SampleCircuit(const std::vector<SampleOperator>& _samples); 
    SampleCircuit(const Circuit& circ, bool ancilla_measures=true); 

    int measurements() const; 
    void reduce(); 
    void push(const SampleOperator& sample_op); 
    std::vector<std::pair<std::vector<bool>, int64_t>> measure(int shots = 10) const; 
} ; 

std::ostream& operator<<(std::ostream& os, const SampleCircuit& op); 

std::ostream& operator<<(std::ostream& os, const std::vector<bool>& vec); 
size_t hamming_weight(const std::vector<bool>& v); 
bool sort_criteria(const std::pair<std::vector<bool>, int>& a,
                   const std::pair<std::vector<bool>, int>& b); 
std::vector<bool> xor_reduce(const std::vector<SampleOperator>& ops); 

#endif
</file>

<file path="SampleLoop.cc">
#include "SampleLoop.h"
#include <chrono>

BitString BitString::operator^(const BitString& other) const {
    if (bs.size() != other.bs.size()) [[unlikely]] {
        throw std::runtime_error("Vectors must have the same size");
    }
    BitString result; 
    result.num_bits = num_bits; 
    result.bs.resize(bs.size()); 
    
    const uint64_t* lhs = bs.data();
    const uint64_t* rhs = other.bs.data();
    uint64_t* res = result.bs.data();

    for (size_t i = 0; i < bs.size(); ++i) {
        res[i] = lhs[i] ^ rhs[i];
    }

    return result;
}

BitString& BitString::operator^=(const BitString& other) {
    if (bs.size() != other.bs.size()) [[unlikely]] {
        throw std::runtime_error("Vectors must have the same size");
    }
    uint64_t* lhs = bs.data();
    const uint64_t* rhs = other.bs.data();
    for (size_t i = 0; i < bs.size(); ++i)
        lhs[i] ^= rhs[i];
    return *this;
}

std::ostream& operator<<(std::ostream& os, const BitString& bs) {
    for (size_t i = 0; i < bs.num_bits; ++i) {
        os << (bs[i] ? '1' : '0'); 
    }
    return os;
}

bool BitString::operator[](size_t i) const {
    size_t w = i / BITS_PER_INT;
    size_t b = i % BITS_PER_INT;
    return (bs[w] >> b) & 1ULL; // (unsigned long long) 1
}

void BitString::set(size_t i, bool value) {
    size_t w = i / BITS_PER_INT;
    size_t b = i % BITS_PER_INT; 
    if (w >= bs.size()) {
        std::cerr << "ERROR: BitString::set index out of bounds. i=" << i
              << ", w=" << w << ", bs.size()=" << bs.size() << std::endl;
        std::exit(1);
    }
    if (value) {
        bs[w] |= (1ULL << b);
    }
    else {
        bs[w] &= ~(1ULL << b);
    }
}

BitString BitString::operator+(const BitString& other) const {
    BitString result(num_bits + other.num_bits);

    const size_t w = num_bits / BITS_PER_INT;
    const size_t b = num_bits % BITS_PER_INT;

    std::copy(bs.begin(), bs.end(), result.bs.begin());

    if (b == 0) {
        std::copy(other.bs.begin(), other.bs.end(), result.bs.begin() + w);
    } else {
        const size_t shift = BITS_PER_INT - b;;
        uint64_t carry = 0;

        for (size_t i = 0; i < other.bs.size(); ++i) {
            uint64_t current = other.bs[i];
            result.bs[w + i]     |= current << b;
            carry = current >> shift;
            result.bs[w + i + 1] |= carry;
        }
    }
    return result;
}

BitString& BitString::operator+=(const BitString& other) {
    const size_t old_num_bits = num_bits;
    const size_t new_num_bits = num_bits + other.num_bits;

    bs.resize((new_num_bits + BITS_PER_INT - 1) / BITS_PER_INT, 0);  
    num_bits = new_num_bits;

    const size_t w = old_num_bits / BITS_PER_INT;
    const size_t b = old_num_bits % BITS_PER_INT;

    if (b == 0) {
        std::copy(other.bs.begin(), other.bs.end(), bs.begin() + w);
    } else {
        const size_t shift = BITS_PER_INT - b;
        uint64_t carry = 0;

        for (size_t i = 0; i < other.bs.size(); ++i) {
            uint64_t current = other.bs[i];
            bs[w + i]     |= current << b;
            carry = current >> shift;
            bs[w + i + 1] |= carry;
        }
    }

    return *this;
}


bool BitString::operator==(const BitString& other) const {
    return num_bits == other.num_bits && bs == other.bs;
}

SampleLoop::SampleLoop(const Loop& L) {
    repeat = L.repeat;
    size_t index = 0; 
    const std::vector<Operator>& ops = L.reduced_circ.operators;
    while (index < ops.size() && std::holds_alternative<Reset>(ops[index])) {
        ++index; 
    }
    rqubits = resets_list(L.reduced_circ, 0, index - 1); 
    // rmap = resets_block(L.reduced_circ, 0, index - 1); 
    while (index < ops.size() && std::holds_alternative<Error>(ops[index])) {
        errors.push_back(std::get<Error>(ops[index])); 
        ++index; 
    }
    int start = index; 
    while (index < ops.size() && std::holds_alternative<Clifford>(ops[index])) {
        ++index; 
    }
    map = gates_block(L.reduced_circ, start, index - 1); 
    while (index < ops.size() && std::holds_alternative<Measure>(ops[index])) {
        const Measure& M = std::get<Measure>(ops[index]); 
        measures.push_back(M); 
        mflips.push_back(M.probability); 
        ++index; 
    }
    while (index < ops.size()) {
        merrors.push_back(std::get<Error>(ops[index])); 
        ++index; 
    }
}

// TEST FUNCTION FOR COMPUTING BITSTRING DISTRIBUTION
// Maps an error to what it would be after it passes through the resets as represented by map 
Error map_error_resets(const std::map<Pauli, Pauli>& map, const Error& E) {
    std::vector<Pauli> new_paulis; 
    for (Pauli P: E.paulis) {
        Pauli res; 
        for (const Pauli& basis: P.basis_rep()) {
            res *= map.find(basis)->second; 
        }
        new_paulis.push_back(res); 
    }
    return Error(new_paulis, E.weights);
}


// TEST FUNCTION FOR COMPUTING BITSTRING DISTRIBUTION
// Maps an error to what it would be after it passes through the resets as represented by map 
Error map_error_gates(const std::map<Pauli, std::pair<Pauli, BitString>>& map, const Error& E) {
    std::vector<Pauli> new_paulis; 
    for (Pauli P: E.paulis) {
        Pauli res; 
        for (const Pauli& basis: P.basis_rep()) {
            res *= (map.find(basis)->second).first; 
        }
        new_paulis.push_back(res); 
    }
    return Error(new_paulis, E.weights);
}

void map_sampled_error_resets(const std::set<int>& rqubits, Pauli& P) {
    for (int i : rqubits) {
        P.delete_term(i); 
    }
}

// Pauli map_sampled_error_resets(const std::map<Pauli, Pauli>& map, const Pauli& P) {
//     Pauli pauli; 
//     for (const Pauli& basis: P.basis_rep()) {
//         pauli *= map.find(basis)->second; 
//     }
//     return pauli;
// }

void map_sampled_error_gates(
    const std::map<Pauli, std::pair<Pauli, BitString>>& map, 
    const std::vector<double>& mflips, 
    Pauli& P, BitString& bs
) {
    static std::mt19937 gen(std::random_device{}()); 
    static std::uniform_real_distribution<double> dist(0, 1);
    BitString flips = BitString(map.begin()->second.second.num_bits); 
    Pauli _P; 
    const int bits = bs.BITS_PER_INT; 
    for (const Pauli& basis: P.basis_rep()) {
        const std::pair<Pauli, BitString>& transformed = map.find(basis)->second; 
        _P *= transformed.first; 
        flips ^= transformed.second;
    }
    for (size_t i = 0; i < mflips.size(); ++i) {
        if (dist(gen) < mflips[i]) {
            flips.bs[i / bits] ^= (1ULL << (i % bits));
        }
    } 
    P = _P; 
    bs += flips; 
}

// std::pair<Pauli, BitString> map_sampled_error_gates(const std::map<Pauli, std::pair<Pauli, BitString>>& map, const Pauli& P) {
//     Pauli pauli; 
//     BitString flips = BitString(map.begin()->second.second.num_bits); 
//     for (const Pauli& basis: P.basis_rep()) {
//         pauli *= (map.find(basis)->second).first; 
//         flips ^= (map.find(basis)->second).second; 
//     }
//     return std::pair{pauli, flips};
// }

std::set<int> resets_list(
    const Circuit& circ, 
    std::optional<int> start,
    std::optional<int> end
) {
    int first = circ.operators.size();
    int last = -1; 
    std::set<int> resets; 
    if (start) first = *start; 
    else {
        for (size_t i = 0; i < circ.operators.size(); ++i) {
            if (std::holds_alternative<Reset>(circ.operators[i])) {
                first = i; 
                break; 
            }
        }
    }
    if (end) last = *end; 
    else {
        for (int i = circ.operators.size() - 1; i >= 0; --i) {
            if (std::holds_alternative<Reset>(circ.operators[i])) {
                last = i; 
                break; 
            }
        }
    }
    for (int i = first; i <= last; ++i) {
        resets.insert(std::get<Reset>(circ[i]).qubits()); 
    }
    return resets; 
}

// std::map<Pauli, Pauli> resets_block(
//     const Circuit& circ, 
//     std::optional<int> start,
//     std::optional<int> end
// ) {
//     int first = circ.operators.size();
//     int last = -1; 
//     std::map<Pauli, Pauli> resets; 
//     if (start) first = *start; 
//     else {
//         for (int i = 0; i < (int) circ.operators.size(); ++i) {
//             if (std::holds_alternative<Reset>(circ.operators[i])) {
//                 first = i; 
//                 break; 
//             }
//         }
//     }
//     if (end) last = *end; 
//     else {
//         for (int i = circ.operators.size() - 1; i >= 0; --i) {
//             if (std::holds_alternative<Reset>(circ.operators[i])) {
//                 last = i; 
//                 break; 
//             }
//         }
//     }

//     resets.emplace_hint(resets.begin(), Pauli(), Pauli()); 
//     for (int q = 1; q <= circ.qubits(); ++q) {
//         Pauli X = Pauli("X" + std::to_string(q)); 
//         Pauli Z = Pauli("Z" + std::to_string(q)); 
//         for (int i = first; i <= last; ++i) {
//             X = commute(X, std::get<Reset>(circ.operators[i])); 
//             Z = commute(Z, std::get<Reset>(circ.operators[i])); 
//         }
//         resets.emplace_hint(resets.end(), Pauli("X" + std::to_string(q)), X); 
//         resets.emplace_hint(resets.end(), Pauli("Z" + std::to_string(q)), Z); 
//     }
//     return resets; 
// }

std::map<Pauli, std::pair<Pauli, BitString>> gates_block(
    const Circuit& circ, 
    std::optional<int> start, 
    std::optional<int> end
) {
    const int n = static_cast<int>(circ.operators.size());
    int first = circ.operators.size();
    int last = -1; 
    int mlast = -1; 
    std::map<Pauli, std::pair<Pauli, BitString>> gates; 
    if (start) first = *start; 
    else {
        for (int i = 0; i < n; ++i) {
            if (std::holds_alternative<Clifford>(circ.operators[i])) {
                first = i; 
                break; 
            }
        }
    }
    if (end) last = *end; 
    else {
        for (int i = n - 1; i >= 0; --i) {
            if (std::holds_alternative<Clifford>(circ.operators[i])) {
                last = i; 
                break; 
            }
        }
    }
    for (int i = n - 1; i >= 0; --i) {
        if (std::holds_alternative<Measure>(circ.operators[i])) {
            mlast = i; 
            break; 
        }
    }

    // no measurements 
    if (mlast == -1) mlast = last; 
    std::cout << first << "\n"; 
    std::cout << last << "\n"; 
    gates.emplace_hint(gates.begin(), Pauli(), std::pair{Pauli(), BitString(mlast - last)}); 

    for (int q = 1; q <= circ.qubits(); ++q) {
        Pauli X = Pauli("X" + std::to_string(q));
        Pauli Z = Pauli("Z" + std::to_string(q));
        for (int i = first; i <= last; ++i) {
            X = commute(X, std::get<Clifford>(circ.operators[i])); 
            Z = commute(Z, std::get<Clifford>(circ.operators[i])); 
        }
        BitString Xflip = BitString(mlast - last); 
        BitString Zflip = BitString(mlast - last); 
        // goes through all the measures 
        // the flips correspond to the measurement outputs AFTER the basis pauli has gone through all the gates 
        for (int i = last + 1; i <= mlast; ++i) {
            const Measure& M = std::get<Measure>(circ[i]);
            // const Measure& M = std::get<Measure>(circ.operators[i]);
            Xflip.set(i - last - 1, ((X % M.pauli) != M.sign)); 
            Zflip.set(i - last - 1, ((Z % M.pauli) != M.sign));
        }
        gates.emplace_hint(gates.end(), Pauli("X" + std::to_string(q)), std::pair{X, Xflip}); 
        gates.emplace_hint(gates.end(), Pauli("Z" + std::to_string(q)), std::pair{Z, Zflip}); 
    }
    return gates;
}

Pauli sample(const std::vector<Error>& errors) {
    static std::mt19937 gen(std::random_device{}()); 
    Pauli P; 

    for (const Error& E: errors) {
        std::discrete_distribution<> dist(E.weights.begin(), E.weights.end()); 
        const Pauli& choice = E.paulis[dist(gen)]; 
        P *= choice; 
    }

    return P; 
}

std::vector<std::pair<BitString, int64_t>> SampleLoop::measure(int shots) const {
    std::unordered_map<BitString, int64_t> samples; 
    for (int i = 0; i < shots; ++i) {
        Pauli P; 
        BitString res; 
        for (int r = 0; r < repeat; ++r) {
            map_sampled_error_resets(rqubits, P); 
            Pauli new_error = sample(errors); 
            P *= new_error; 
            map_sampled_error_gates(map, mflips, P, res); 
            new_error = sample(merrors); 
            P *= new_error; 
        }
        ++(samples[res]); 
    }
    std::vector<std::pair<BitString, int64_t>> sorted(samples.begin(), samples.end()); 
    std::sort(sorted.begin(), sorted.end(), 
        [](const std::pair<BitString, int64_t>& a, const std::pair<BitString, int64_t>& b) { return a.second < b.second; }); 
    return sorted; 
}

std::vector<std::pair<BitString, int64_t>> SampleLoop::measure(int shots, const Circuit& preCircuit, const Circuit& postCircuit) const {
    std::unordered_map<BitString, int64_t> samples; 
    Circuit circ = Circuit(preCircuit);  
    Circuit postcirc = Circuit(postCircuit); 
    circ.add_resets(); 
    circ.add_reset_errors(); 
    circ.add_measure_errors(); 
    postcirc.add_reset_errors(); 
    postcirc.add_measure_errors(); 
    for (int i = 0; i < shots; ++i) {
        if (i % 1000 == 0) std::cout << i << "\n"; 
        const std::pair<Pauli, BitString>& temp = process_precircuit(circ); 
        Pauli P = temp.first; 
        BitString res = temp.second; 
        for (int r = 0; r < repeat; ++r) {
            map_sampled_error_resets(rqubits, P); 
            const Pauli& new_error = sample(errors); 
            P *= new_error; 
            map_sampled_error_gates(map, mflips, P, res); 
            const Pauli& measure_error = sample(merrors); 
            P *= measure_error; 
        }
        res += process_postcircuit(postcirc, P); 
        ++(samples[res]); 
    }
    std::vector<std::pair<BitString, int64_t>> sorted(samples.begin(), samples.end()); 
    std::sort(sorted.begin(), sorted.end(), 
        [](const std::pair<BitString, int64_t>& a, const std::pair<BitString, int64_t>& b) { return a.second < b.second; }); 
    return sorted; 
}

std::pair<Pauli, BitString> process_precircuit(const Circuit& circ) {
    Pauli P; 
    BitString res = BitString(circ.measurements()); 
    int m = 0; 
    for (const Operator& op: circ.operators) {
        if (std::holds_alternative<Reset>(op)) {
            P = commute(P, std::get<Reset>(op)); 
        } else if (std::holds_alternative<Error>(op)) {
            P *= sample(std::vector{std::get<Error>(op)}); 
        } else if (std::holds_alternative<Measure>(op)) {
            const Measure& M = std::get<Measure>(op); 
            res.set(m, ((P % M.pauli) != M.sign));
            ++m;
        } else { // Clifford
            P = commute(P, std::get<Clifford>(op)); 
        }
    }
    return std::pair{P, res}; 
}

BitString process_postcircuit(const Circuit& circ, Pauli P) {
    BitString res = BitString(circ.measurements()); 
    int m = 0; 
    for (const Operator& op: circ.operators) {
        if (std::holds_alternative<Reset>(op)) {
            P = commute(P, std::get<Reset>(op)); 
        } else if (std::holds_alternative<Error>(op)) {
            P *= sample(std::vector{std::get<Error>(op)}); 
        } else if (std::holds_alternative<Measure>(op)) {
            const Measure& M = std::get<Measure>(op); 
            res.set(m, ((P % M.pauli) != M.sign));
            ++m;
        } else { // Clifford
            P = commute(P, std::get<Clifford>(op)); 
        }
    }
    return res; 
}

std::vector<std::pair<BitString, int64_t>> measure(int shots, const std::initializer_list<SampleLoop>& lst) {
    std::unordered_map<BitString, int64_t> samples; 
    std::vector<Error> first_reset_errors; 
    for (size_t q = 1; q <= lst.begin()->map.size() / 2; ++q) {
        if (lst.begin()->rqubits.find(q) == lst.begin()->rqubits.end())
            first_reset_errors.emplace_back(Pauli("Z" + std::to_string(q)));
    }
    for (Error E: first_reset_errors) std::cout << E << "\n"; 
    for (int i = 0; i < shots; ++i) {
        if (i % 1000 == 0) std::cout << i << "\n"; 
        Pauli P = sample(first_reset_errors); 
        BitString res = BitString(0); 
        for (const SampleLoop& sloop : lst) {
            for (int r = 0; r < sloop.repeat; ++r) {
                map_sampled_error_resets(sloop.rqubits, P); 
                const Pauli& new_error = sample(sloop.errors); 
                //std::cout << "Before error: " << P << "\n"; 
                P *= new_error; 
                //std::cout << "After error: " << P << "\n"; 
                map_sampled_error_gates(sloop.map, sloop.mflips, P, res); 
                // std::cout << "After map: " << P << "\n"; 
                // std::cout << "At this point: " << res << "\n"; 
                const Pauli& measure_error = sample(sloop.merrors); 
                P *= measure_error; 
                //std::cout << "After merror: " << P << "\n"; 
            }
        }
        ++(samples[res]); 
    }
    std::vector<std::pair<BitString, int64_t>> sorted(samples.begin(), samples.end()); 
    std::sort(sorted.begin(), sorted.end(), 
        [](const std::pair<BitString, int64_t>& a, const std::pair<BitString, int64_t>& b) { return a.second < b.second; }); 
    return sorted; 
}

// test fcn that prints the bitstring distribution 
// To use this, I need to reimplement rmap 
// void printCircuitwithLoop(const Circuit& circ1, const Loop& loop, const Circuit& circ2) {
//     std::cout << "at top \n"; 
//     Circuit modified1 = circ1; 
//     modified1.extract_measures(); 
//     std::cout << "extracted measures \n"; 
//     modified1.add_resets(); 
//     std::cout << "added resets \n"; 
//     modified1.reorder();
//     std::cout << "reordered \n"; 
//     modified1.add_reset_errors(); 
//     std::cout << "added reset errors \n"; 
//     modified1.add_measure_errors(); 
//     std::cout << "finished modifying circuit 1 \n"; 
//     Circuit modified2 = circ2; 
//     modified2.extract_measures(); 
//     modified2.reorder();
//     modified2.add_reset_errors(); 
//     modified2.add_measure_errors(); 

//     std::cout << "The circuit looks like: \n";
//     std::cout << modified1 << "\n";
//     for (int i = 0; i < loop.repeat; ++i)
//         std::cout << loop.reduced_circ << "\n";
//     std::cout << modified2 << "\n";

//     SampleCircuit sample_circ = SampleCircuit(); 
//     SampleLoop sample_loop = SampleLoop(loop); 

//     int m = modified1.measurements() + modified2.measurements() + loop.reduced_circ.measurements() * loop.repeat; 
//     int m_index = 0; 
//     // calculating bit flips from the first Circuit
//     for (int index = 0; index < (int) modified1.operators.size(); ++index) {
//         Operator op1 = modified1[index]; 
//         if (std::holds_alternative<Error>(op1)) {
//             Error E = std::get<Error>(op1); 
//             std::vector<std::vector<bool>> flips;
//             for (int i = 0; i < (int) E.paulis.size(); ++i) {
//                 flips.push_back(std::vector<bool>(m, false));
//             }
//             // not all the measurements are at the very end now 
//             int m_index2 = m_index;
//             for (int i = index + 1; i < (int) modified1.operators.size(); ++i) {
//                 const Operator& op2 = modified1.operators[i];
//                 if (std::holds_alternative<Measure>(op2)) {
//                     const Measure& M = std::get<Measure>(op2);
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//                 E = std::visit([E](const auto& _op2) {return commute(E, _op2); }, op2);
//             }
//             for (int i = 0; i < loop.repeat; ++i) {
//                 E = map_error_resets(sample_loop.rmap, E); 
//                 E = map_error_gates(sample_loop.map, E); 
//                 for (const Measure& M: sample_loop.measures) {
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//             }
//             for (int i = 0; i < (int) modified2.operators.size(); ++i) {
//                 const Operator& op2 = modified2.operators[i];
//                 if (std::holds_alternative<Measure>(op2)) {
//                     const Measure& M = std::get<Measure>(op2);
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//                 E = std::visit([E](const auto& _op2) {return commute(E, _op2); }, op2);
//             }
//             sample_circ.push(SampleOperator(flips, E.weights));
//         } else if (std::holds_alternative<Measure>(op1)) {
//             std::vector<std::vector<bool>> flips(2, std::vector<bool>(m, false));
//             Measure M = std::get<Measure>(op1); 
//             flips[1][m_index] = true;
//             if (M.probability > 0) {
//                 sample_circ.push(SampleOperator(flips, Weights({1.0 - M.probability, M.probability})));
//             }
//             m_index += 1;
//         }
//     }

//     // calculating bitflips for the loop 
//     for (int r = 0; r < sample_loop.repeat; ++r) {
//         for (Error E :sample_loop.errors) {
//             std::vector<std::vector<bool>> flips;
//             for (int i = 0; i < (int) E.paulis.size(); ++i) {
//                 flips.push_back(std::vector<bool>(m, false));
//             }
//             int m_index2 = m_index;
//             // takes Error through rest of the loop
//             E = map_error_gates(sample_loop.map, E); 
//             for (const Measure& M: sample_loop.measures) {
//                 for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                     flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                 }
//                 ++m_index2;
//             }
//             for (int j = r + 1; j < sample_loop.repeat; ++j) {
//                 E = map_error_resets(sample_loop.rmap, E); 
//                 E = map_error_gates(sample_loop.map, E); 
//                 for (const Measure& M: sample_loop.measures) {
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//             }
//             // takes error through next part of circuit
//             for (int i = 0; i < (int) modified2.operators.size(); ++i) {
//                 const Operator& op2 = modified2.operators[i];
//                 if (std::holds_alternative<Measure>(op2)) {
//                     const Measure& M = std::get<Measure>(op2);
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//                 E = std::visit([E](const auto& _op2) {return commute(E, _op2); }, op2);
//             }
//             sample_circ.push(SampleOperator(flips, E.weights));
//         }
//         for (const Measure& M: sample_loop.measures) {
//             std::vector<std::vector<bool>> flips(2, std::vector<bool>(m, false));
//             flips[1][m_index] = true;
//             if (M.probability > 0) {
//                 sample_circ.push(SampleOperator(flips, Weights({1.0 - M.probability, M.probability})));
//             }
//             ++m_index;
//         }
//         for (Error E: sample_loop.merrors) {
//             std::vector<std::vector<bool>> flips;
//             for (int i = 0; i < (int) E.paulis.size(); ++i) {
//                 flips.push_back(std::vector<bool>(m, false));
//             }
//             int m_index2 = m_index;
//             // takes Error through rest of the loop
//             for (int j = r + 1; j < sample_loop.repeat; ++j) {
//                 E = map_error_resets(sample_loop.rmap, E); 
//                 E = map_error_gates(sample_loop.map, E); 
//                 for (const Measure& M: sample_loop.measures) {
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//             }
//             // takes error through next part of circuit
//             for (int i = 0; i < (int) modified2.operators.size(); ++i) {
//                 const Operator& op2 = modified2.operators[i];
//                 if (std::holds_alternative<Measure>(op2)) {
//                     const Measure& M = std::get<Measure>(op2);
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//                 E = std::visit([E](const auto& _op2) {return commute(E, _op2); }, op2);
//             }
//             sample_circ.push(SampleOperator(flips, E.weights));
//         }
//     }

//     // calculating bitflips from the last circuit
//     for (int index = 0; index < (int) modified2.operators.size(); ++index) {
//         Operator op1 = modified2[index]; 
//         if (std::holds_alternative<Error>(op1)) {
//             Error E = std::get<Error>(op1); 
//             std::vector<std::vector<bool>> flips;
//             for (int i = 0; i < (int) E.paulis.size(); ++i) {
//                 flips.push_back(std::vector<bool>(m, false));
//             }
//             // not all the measurements are at the very end now 
//             int m_index2 = m_index;
//             for (int i = index + 1; i < (int) modified2.operators.size(); ++i) {
//                 const Operator& op2 = modified2.operators[i];
//                 if (std::holds_alternative<Measure>(op2)) {
//                     const Measure& M = std::get<Measure>(op2);
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//                 E = std::visit([E](const auto& _op2) {return commute(E, _op2); }, op2);
//             }
//             sample_circ.push(SampleOperator(flips, E.weights));
//         } else if (std::holds_alternative<Measure>(op1)) {
//             std::vector<std::vector<bool>> flips(2, std::vector<bool>(m, false));
//             Measure M = std::get<Measure>(op1); 
//             flips[1][m_index] = true;
//             if (M.probability > 0) {
//                 sample_circ.push(SampleOperator(flips, Weights({1.0 - M.probability, M.probability})));
//             }
//             m_index += 1;
//         }
//     }

//     sample_circ.reduce(); 
//     std::cout << "printing sample circuit: \n" << sample_circ << "\n"; 
// }

// void printSampledLoop(const Loop& loop) {
//     Circuit modified_circ = loop.circ; 
//     modified_circ.extract_measures(); 
//     modified_circ.add_resets();
//     modified_circ.reorder(); 
//     modified_circ.add_reset_errors(); 
//     modified_circ.add_measure_errors(); 
//     std::cout << "The fully modified normal circuit is: " << "\n" << modified_circ; 
//     SampleCircuit sample_circ = SampleCircuit(); 
//     int m = modified_circ.measurements(); 
//     int m_index = 0; 
//     for (int index = 0; index < (int) modified_circ.operators.size(); ++index) {
//         Operator op1 = modified_circ[index]; 
//         // run each error through (the rest of) the circuit and determine its bit flips 
//         // i.e. flips is all zero initally and if the error does not commute with the measurement, 
//         // a bit flip occurs on the specified bit and you record the new bit flips for that measurement
//         // for all other operators, you pull the error through and update it by commuting it with the next operator
//         if (std::holds_alternative<Error>(op1)) {
//             Error E = std::get<Error>(op1); 
//             std::vector<std::vector<bool>> flips;
//             // initalizes all flips to 0; same number of Paulis as the bitarrays 
//             for (int i = 0; i < (int) E.paulis.size(); ++i) {
//                 flips.push_back(std::vector<bool>(m, false));
//             }
//             int m_index2 = 0;
//             // checks all operators that comes after this error
//             for (int i = index + 1; i < (int) modified_circ.operators.size(); ++i) {
//                 const Operator& op2 = modified_circ.operators[i];
//                 if (std::holds_alternative<Measure>(op2)) {
//                     const Measure& M = std::get<Measure>(op2);
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//                 // std::cout << "Before commuting error: " << E.paulis[1] << "\n"; 

//                 // std::visit([E](const auto& _op2) {std::cout << "Commuting with: " << _op2 <<"\n"; }, op2);
//                 E = std::visit([E](const auto& _op2) {return commute(E, _op2); }, op2);
//                 // std::cout << "After commuting error: " << E << "\n"; 
//             }
//             // std::cout << "In construction of samplecircuit with error: " << E << "\n"; 
//             // std::cout<< "and sample error: " << SampleOperator(flips, E.weights) << "\n"; 
//             sample_circ.push(SampleOperator(flips, E.weights));
//         // for each measurement, adds a bitflip at the measurement qubit with some given probability  
//         } else if (std::holds_alternative<Measure>(op1)) {
//             std::vector<std::vector<bool>> flips(2, std::vector<bool>(m, false));
//             Measure M = std::get<Measure>(op1); 
//             flips[1][m_index] = true;
//             if (M.probability > 0) {
//                 sample_circ.push(SampleOperator(flips, Weights({1.0 - M.probability, M.probability})));
//             }
//             m_index += 1;
//         }
//     }
//     sample_circ.reduce(); 
//     std::cout << "printing sample circuit for the normal circuit: " << "\n" <<  sample_circ << "\n\n"; 


//     // LOOP format
//     Circuit reduced = loop.reduced_circ; 
//     reduced.add_initial_resets();
//     std::cout << "The fully modified reduced circuit is: " << "\n" << reduced; 
//     SampleCircuit sample_reduced = SampleCircuit(); 
//     m = reduced.measurements(); 
//     m_index = 0; 
//     for (int index = 0; index < (int) reduced.operators.size(); ++index) {
//         Operator op1 = reduced[index]; 
//         // run each error through (the rest of) the circuit and determine its bit flips 
//         // i.e. flips is all zero initally and if the error does not commute with the measurement, 
//         // a bit flip occurs on the specified bit and you record the new bit flips for that measurement
//         // for all other operators, you pull the error through and update it by commuting it with the next operator
//         if (std::holds_alternative<Error>(op1)) {
//             Error E = std::get<Error>(op1); 
//             std::vector<std::vector<bool>> flips;
//             // initalizes all flips to 0; same number of Paulis as the bitarrays 
//             for (int i = 0; i < (int) E.paulis.size(); ++i) {
//                 flips.push_back(std::vector<bool>(m, false));
//             }
//             int m_index2 = 0;
//             std::cout << "Before mapping error: \n" << E << "\n"; 
//             E = map_error(loop.map, E); 
//             std::cout << "After mapping error: \n" << E << "\n"; 
//             for (int i = index + 1; i < (int) reduced.operators.size(); ++i) {
//                 if (std::holds_alternative<Measure>(reduced.operators[i])) {
//                     const Measure& M = std::get<Measure>(reduced.operators[i]);
//                     for (int j = 0; j < (int) E.paulis.size(); ++j) {
//                         flips[j][m_index2] = ((E.paulis[j] % M.pauli) != M.sign);
//                     }
//                     ++m_index2;
//                 }
//             }
//             sample_reduced.push(SampleOperator(flips, E.weights));
//         // for each measurement, adds a bitflip at the measurement qubit with some given probability  
//         } else if (std::holds_alternative<Measure>(op1)) {
//             std::vector<std::vector<bool>> flips(2, std::vector<bool>(m, false));
//             Measure M = std::get<Measure>(op1); 
//             flips[1][m_index] = true;
//             if (M.probability > 0) {
//                 sample_reduced.push(SampleOperator(flips, Weights({1.0 - M.probability, M.probability})));
//             }
//             m_index += 1;
//         }
//     }
//     sample_reduced.reduce(); 
//     std::cout << "printing sample circuit for the reduced circuit: " << "\n" <<  sample_reduced << "\n\n"; 
// }
</file>

<file path="SampleLoop.h">
#ifndef _QULIA_SAMPLELOOP
#define _QULIA_SAMPLELOOP

#include "Loop.h"
#include "SampleCircuit.h"

struct BitString {
    std::vector<uint64_t> bs; 
    size_t num_bits; 

    static constexpr size_t BITS_PER_INT = 64;

    BitString(size_t n) : num_bits(n) {
        bs.resize((n + BITS_PER_INT - 1) / BITS_PER_INT, 0);
    }

    BitString() = default;
    BitString(const BitString&) = default; 
    BitString& operator=(const BitString&) = default; 
    BitString(const std::vector<uint64_t>& _bs) : bs(_bs) {} 

    BitString operator^(const BitString& BS) const; 
    BitString& operator^=(const BitString& other); 
    bool operator[](size_t i) const; 
    BitString operator+(const BitString& b) const; 
    BitString& operator+=(const BitString& other); 
    bool operator==(const BitString& other) const; 
    void set(size_t i, bool value); 
}; 

std::ostream& operator<<(std::ostream& os, const BitString& loop); 

namespace std {
    template<>
    struct hash<BitString> {
        std::size_t operator()(const BitString& b) const {
            std::size_t h = std::hash<size_t>{}(b.num_bits);
            for (uint64_t word : b.bs) {
                h ^= std::hash<uint64_t>{}(word) + 0x9e3779b9 + (h << 6) + (h >> 2);
            }
            return h;
        }
    };
}

struct SampleLoop {
    int repeat; 
    // std::map<Pauli, Pauli> rmap; 
    std::set<int> rqubits; 
    std::vector<Error> errors; 
    std::map<Pauli, std::pair<Pauli, BitString>> map; 
    std::vector<Measure> measures; 
    std::vector<Error> merrors; 
    std::vector<double> mflips; 

    SampleLoop() = default; 
    SampleLoop(const SampleLoop&) = default; 
    SampleLoop& operator=(const SampleLoop&) = default; 
    SampleLoop(const Loop& L); 

    // samples from the errors 
    std::vector<std::pair<BitString, int64_t>> measure(int shots) const; 
    std::vector<std::pair<BitString, int64_t>> measure(int shots, const Circuit& preCircuit, const Circuit& postCircuit) const; 
}; 

std::set<int> resets_list(
    const Circuit& circ, 
    std::optional<int> start,
    std::optional<int> end
); 
std::map<Pauli, Pauli> resets_block(
    const Circuit& circ, 
    std::optional<int> start=std::nullopt,
    std::optional<int> end=std::nullopt
);
std::map<Pauli, std::pair<Pauli, BitString>> gates_block(
    const Circuit& circ, 
    std::optional<int> start=std::nullopt, 
    std::optional<int> end=std::nullopt
); 
Pauli sample(const std::vector<Error>& errors); 
void map_sampled_error_resets(const std::set<int>& rqubits, Pauli& P); 
void map_sampled_error_gates(
    const std::map<Pauli, std::pair<Pauli, BitString>>& map, 
    const std::vector<double>& mflips,
    Pauli& P, 
    BitString& bs
); 
std::pair<Pauli, BitString> process_precircuit(const Circuit& circ); 
BitString process_postcircuit(const Circuit& circ, Pauli P); 
std::vector<std::pair<BitString, int64_t>> measure(int shots, const std::initializer_list<SampleLoop>& lst); 
void printSampledLoop(const Loop& loop);
void printCircuitwithLoop(const Circuit& circ1, const Loop& loop, const Circuit& circ2); 

#endif
</file>

<file path="tests.cc">
#include "tests.h"

Circuit test1() {
    double error_prob = 0.000003; 
    double measure_prob = 0.000003; 
    int repeats = 5; 
    std::vector<Operator> operators; 
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Y3"));
    operators.push_back(Clifford("Y4"));
    operators.push_back(Clifford("Z3 X5"));
    operators.push_back(Clifford("Z3")); 
    operators.push_back(Clifford("X5")); 
    operators.push_back(Clifford("Z4 X2"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X2"));
    operators.push_back(Clifford("Y2"));
    operators.push_back(Clifford("Z4 X5"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X5"));
    operators.push_back(Clifford("Z2 X1"));
    operators.push_back(Clifford("Z2")); 
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Z3"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Z2"));
    operators.push_back(Clifford("Z5 X1"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Y5"));
    operators.push_back(Clifford("Z5 X2"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X2"));

    for (int i = 0; i < repeats; i++) {
        if (error_prob > 0) {
            for (int i = 1; i <= 5; ++i) {
                operators.emplace_back(Error(error_prob, std::set<int>{i}));
            }
        }
        operators.emplace_back(Measure("X1 Z2 Z3 X4", false, measure_prob));
        operators.emplace_back(Measure("X2 Z3 Z4 X5", false, measure_prob));
        operators.emplace_back(Measure("X3 Z4 Z5 X1", false, measure_prob));
        operators.emplace_back(Measure("X4 Z5 Z1 X2", false, measure_prob));
    }

    return Circuit(operators); 
}

Circuit test2() {
    std::vector<Operator> operators; 
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Y3"));
    operators.push_back(Clifford("Y4"));
    operators.push_back(Clifford("Z3 X5"));
    operators.push_back(Clifford("Z3")); 
    operators.push_back(Clifford("X5")); 
    operators.push_back(Clifford("Z4 X2"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X2"));
    operators.push_back(Clifford("Y2"));
    operators.push_back(Clifford("Z4 X5"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X5"));
    operators.push_back(Clifford("Z2 X1"));
    operators.push_back(Clifford("Z2")); 
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Z3"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Z2"));
    operators.push_back(Clifford("Z5 X1"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X1"));
    operators.push_back(Clifford("Y5"));
    operators.push_back(Clifford("Z5 X2"));
    operators.push_back(Clifford("Z5"));
    operators.push_back(Clifford("X2"));

    return Circuit(operators); 
}

Loop looptest1() {
    double error_prob = 0.000003; 
    double measure_prob = 0.000003; 
    int repeats = 5; 
    std::vector<Operator> operators;  
    operators.push_back(Clifford("Z1"));
    operators.push_back(Clifford("Y3"));
    operators.push_back(Clifford("Y4"));
    operators.push_back(Clifford("Z3 X5"));
    operators.push_back(Clifford("Z3")); 
    operators.push_back(Clifford("X5")); 
    operators.push_back(Clifford("Z4 X2"));
    operators.push_back(Clifford("Z4"));
    operators.push_back(Clifford("X2"));
    operators.push_back(Clifford("Y2"));
    operators.push_back(Clifford("Z4 X5"));
    if (error_prob > 0) {
        for (int i = 1; i <= 5; ++i) {
            operators.emplace_back(Error(error_prob, std::set<int>{i}));
        }
    }
    operators.emplace_back(Measure("X1 Z2 Z3 X4", false, measure_prob));
    operators.emplace_back(Measure("X2 Z3 Z4 X5", false, measure_prob));
    operators.emplace_back(Measure("X3 Z4 Z5 X1", false, measure_prob));
    operators.emplace_back(Measure("X4 Z5 Z1 X2", false, measure_prob));

    return Loop(Circuit(operators), repeats); 
}

Loop looptest2() {
    double error_prob = 0.00003; 
    double measure_prob = 0.00003; 
    int repeats = 5; 
    std::vector<Operator> operators;  
    if (error_prob > 0) {
        for (int i = 1; i <= 5; ++i) {
            operators.emplace_back(Error(error_prob, std::set<int>{i}));
        }
    }
    operators.emplace_back(Measure("X1 Z2 Z3 X4", false, measure_prob));
    operators.emplace_back(Measure("X2 Z3 Z4 X5", false, measure_prob));
    operators.emplace_back(Measure("X3 Z4 Z5 X1", false, measure_prob));
    operators.emplace_back(Measure("X4 Z5 Z1 X2", false, measure_prob));

    return Loop(Circuit(operators), repeats, false); 
}
</file>

<file path="tests.h">
#ifndef _STIM_TESTS
#define _STIM TESTS 

#include "Loop.h"
#include "SampleLoop.h"
#include "Circuit.h"
#include "SampleCircuit.h"

Circuit test1(); 
Circuit test2(); 
Loop looptest1(); 
Loop looptest2(); 

#endif
</file>

<file path="Weights.h">
#ifndef _QULIA_WEIGHT
#define _QULIA_WEIGHT

#include <array>
#include <complex>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <vector>
#include <numeric>

struct Weights {
    std::vector<double> values;

    Weights(const std::vector<double>& w) : values(w) {
    if (w.empty())
        throw std::invalid_argument("Weights cannot be empty");
    for (double v : w)
        if (v < 0.0)
            throw std::invalid_argument("Weights must be non-negative");
    }
    Weights() = default; 
    Weights(const Weights&) = default;
    Weights& operator=(const Weights&) = default;

    inline std::vector<double>::const_iterator begin() const {
        return values.begin(); 
    }

    inline std::vector<double>::const_iterator end() const {
        return values.end(); 
    }

    inline double get(int index) const {
        return values[index];
    }

    inline void set(int index, int val) {
        values[index] = val; 
    }

    inline double total() const {
        return std::accumulate(values.begin(), values.end(), 0.0);
    }

    inline double normalized(int i) const {
        return values[i] / total();
    }

    inline size_t size() const {
        return values.size();
    }
} ; 
    

#endif
</file>

</files>
